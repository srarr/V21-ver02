รับทราบ—ผมสรุปเป็น **Spec + Diagram แบบละเอียด (Phase 1–2: Prompt → Deploy → Paper/Live)** ในโหมด **Local-first** อิง **VibeCode × BMAD × Claude Code — Full Template** พร้อม **สเกลตันโค้ด LangGraph + Schemas + API routes + Prompt templates** ที่ “Claude Code เข้าใจและรันได้” ทันที และปิดท้ายด้วย **Workflow ส่งงานให้ Claude Code แบบ phaselet** ที่ลด bug/เชื่อมโยงถูกตั้งแต่ต้น

> โครงสร้างคำตอบ: **Macro → Meso → Micro** (ซูม 3 ชั้น) + โค้ดสเกลตัน + ขั้นตอนใช้งานจริง
> ทุกส่วนลงท้ายด้วย **Simple takeaway: …**

---

# 1) Macro — ภาพรวมระบบ (Phase 1–2, Local-first)

```
┌────────────────────────── Heliox Frontend (SvelteKit) ───────────────────────────┐
│ Chat Builder • Preview(Timeline/Metrics/Files) • Portfolio • Connect Brokers     │
└───────────────┬──────────────────────────────┬───────────────────────────────────┘
                │ REST (JSON)                  │ SSE (/events)
                ▼                              ▼
       ┌────────────── Heliox Gateway (Go/Gin) ───────────────┐
       │ CORS • RateLimit • RBAC • ErrorSanitizer • OpenAPI   │
       │ /v1/runs • /v1/portfolio • /v1/brokers • /v1/deploy  │
       └──────────────┬──────────────────────┬────────────────┘
                      │ gRPC/HTTP            │ Pub/Sub
                      ▼                      ▼
         ┌────────────── Orchestrator (LangGraph, Node) ───────────────┐
         │ Nodes: Architect → Synth (CEGIS) → T0/T1 → (T2/T3) → Pack    │
         │ Event Emitter → NATS/Redis → Gateway(SSE)                    │
         └──────────────┬──────────────────────────────┬───────────────┘
                        │                              │
                        ▼                              ▼
             Engine (Rust workers)            Broker Hub (Paper/Live)
           Phase0 • T0 • T1 • (T2/T3)       PaperSim • OANDA • Binance
                        │                              │
                        └────────── Artifacts + Meta ──┘
                                 Postgres + MinIO
```

**Local-first:** ทุกอย่างรันด้วย `docker-compose` ในเครื่อง (Postgres, MinIO, NATS/Redis, Gateway, Orchestrator, Engine, Frontend, PaperSim, Vault dev, Ollama หรือใช้ API key LLM คลาวด์ได้)
**External ที่ต่อก่อนขึ้นคลาวด์:** LLM (Ollama/Anthropic/OpenAI), Supabase (ถ้าต้องใช้ Hosted Auth/DB), OANDA practice/Binance testnet (สำหรับ Phase 2)

**Simple takeaway:** สถาปัตยกรรมแยก 3 ชั้นชัดเจน—UI ↔ Gateway ↔ Orchestrator/Engine/Hub และทุกอย่างรันได้ในเครื่อง

---

# 2) Meso — Containers & Networks (dev/docker-compose)

```
[frontend]  SvelteKit         :5173
[gateway]   Go/Gin API + SSE  :8080
[orchestrator] Node LangGraph internal only
[engine]    Rust workers (phase0,t0,t1,t2,t3,pack) gRPC/HTTP
[hub]       Broker Hub (PaperSim/OANDA/Binance adapters)
[bus]       NATS or Redis for events
[pg]        Postgres (RLS)
[minio]     S3-compatible object store (HSP/Parquet/artifacts)
[vault]     Vault dev (API keys)
[ollama]    LLM local  (หรือใช้ ANTHROPIC_API_KEY/OPENAI_API_KEY)
```

**Network:** ภายใน `heliox_net` เปิดเฉพาะ `frontend:5173`, `gateway:8080`, `minio:9000/9001`
**Volumes:** เก็บข้อมูลถาวรของ pg/minio/ollama

**Simple takeaway:** ยกสแต็กครบในเครื่อง—เสียบ LLM/โบรกนอกได้ทันที แต่ไม่บังคับขึ้น AWS

---

# 3) Sequences — เส้นทางข้อมูลสำคัญ

## 3.1 Prompt → Build → HSP → Save

```
FE POST /v1/runs { prompt, scenario_set_id? }
GW → enqueue to Orchestrator
FE GET /v1/runs/{id}/events (SSE)
Orchestrator: Architect → Synth/CEGIS → T0/T1 → (T2/T3) → Pack
Engine: รันงานหนัก (Rust) คืน artifacts
Bus → GW → FE: status/metric/preview/artifact/final
FE: Save HSP → POST /v1/portfolio/assets { hsp_uri }
```

## 3.2 Connect Broker & Deploy (Phase 2)

```
FE: POST /v1/brokers/connect { venue, creds } → Vault
FE: POST /v1/deploy/paper|live { hsp_uri, account_id, safeguards }
Hub (PaperSim/OANDA/Binance) → Exec events → SSE (/deploy/{id}/events)
```

**Simple takeaway:** ทั้ง Build และ Deploy ใช้ “คำสั่ง + สตรีมผล” รูปแบบเดียวกัน

---

# 4) API Contracts (OpenAPI ย่อ)

```yaml
POST /v1/runs
  req: { prompt: string, scenario_set_id?: string, risk_tier?: 'cons'|'bal'|'agg' }
  res: { trace_id: string }

GET /v1/runs/{trace_id}
  res: { status: 'QUEUED'|'RUNNING'|'COMPLETE'|'FAILED', phase: 'PHASE0'|'T0'|'T1'|'T2'|'T3'|'PACK' }

GET /v1/runs/{trace_id}/events
  res: text/event-stream  # HelioxEvent stream

POST /v1/portfolio/assets
  req: { name: string, hsp_uri: string }
GET  /v1/portfolio/assets

# Phase 2: Broker Hub
GET  /v1/brokers
POST /v1/brokers/connect         # store auth_ref in Vault
POST /v1/deploy/paper
POST /v1/deploy/live
GET  /v1/deploy/{deploy_id}/events
```

**SSE Event (หนึ่งเดียวทั้งระบบ)**

```json
{
  "type":"status|msg|metric|preview|artifact|error|final|execution",
  "seq":17,
  "phase":"PHASE0|T0|T1|T2|T3|PACK|DEPLOY",
  "trace_id":"tr_...",
  "time":"2025-08-24T08:31:05Z",
  "payload":{}
}
```

**Simple takeaway:** 6 endpoint แรก = ครบ Phase 1; เพิ่ม 5 endpoint = ครบ Deploy/Paper/Live ใน Phase 2

---

# 5) Data Contracts — DB & Files

## 5.1 Postgres (RLS on)

```
runs(id uuidv7 pk, trace_id text uniq, tenant_id, user_id,
     status text, phase text, cost_used numeric, created_at timestamptz)

portfolio_assets(id uuidv7 pk, tenant_id, user_id,
     name text, hsp_uri text, checksum text, created_at timestamptz)

scenario_sets(id text pk, targets jsonb, n_paths int, horizon_bars int,
     obj_uri text, checksum text, created_at timestamptz)

# Phase 2
broker_accounts(id uuidv7 pk, tenant_id, user_id, venue text, label text,
     auth_ref text, capabilities jsonb, status text, created_at timestamptz)

deployments(id uuidv7 pk, tenant_id, user_id, asset_id, account_id,
     mode text, state text, started_at timestamptz, last_event_seq int)

order_logs(id uuidv7 pk, deployment_id, ts timestamptz, kind text, payload jsonb)
```

## 5.2 HSP (`.hspz = zip`)

```
manifest.json            # strategy_id, version, scenario_set_id, checksum
blueprint.json           # DSL/AST final
fast_metrics.json        # T0/T1 medians + CI
(qc_report.json)         # Phase 2
(formal_report.json)     # Phase 2 (ถ้ามี)
deploy.descriptor.json   # risk knobs, symbols, lot rules
tests/golden.json        # reproducibility
```

**Simple takeaway:** โครงข้อมูลน้อยแต่ครบ—ตรวจย้อนกลับได้ และต่อยอด Phase 3/4 ได้

---

# 6) LangGraph Orchestrator — สเกลตัน (TypeScript)

> เราเลือก **TS LangGraph** (ง่ายต่อการต่อกับ Frontend/Claude Code) โดยให้ **งานหนัก** วิ่งใน **Engine (Rust)** ผ่าน HTTP/gRPC

## 6.1 โครงไฟล์

```
/apps/orchestrator
  package.json
  src/index.ts
  src/graph.ts
  src/nodes/architect.ts
  src/nodes/synth.ts
  src/nodes/t0.ts
  src/nodes/t1.ts
  src/nodes/t2.ts
  src/nodes/t3.ts
  src/nodes/pack.ts
  src/lib/bus.ts         # publish HelioxEvent -> NATS/Redis
  src/lib/repo.ts        # Postgres/MinIO ops
  src/lib/llm.ts         # Ollama/Anthropic/OpenAI wrapper
  src/lib/contracts.ts   # zod schemas (shared with /packages/contracts)
```

## 6.2 State & Event types (shared)

```ts
// packages/contracts/src/state.ts
import { z } from 'zod';
export const Requirement = z.object({
  prompt: z.string(), risk_tier: z.enum(['cons','bal','agg']).optional(),
  scenario_set_id: z.string().optional()
});
export const Blueprint = z.object({ /* DSL typed fields */ });
export const Candidate  = z.object({ bp_id: z.string(), params: z.record(z.any()) });
export const FastMetrics = z.object({
  sharpe: z.number(), cvar_proxy: z.number(), turnover: z.number(),
  ci95: z.tuple([z.number(), z.number()])
});
export type RequirementT = z.infer<typeof Requirement>;
export type BlueprintT   = z.infer<typeof Blueprint>;
export type CandidateT   = z.infer<typeof Candidate>;
export type FastMetricsT = z.infer<typeof FastMetrics>;

export type HelioxEvent =
 | { type:'status';   seq:number; phase:string; payload:{stage:string;progress:number;eta_sec?:number} }
 | { type:'metric';   seq:number; phase:string; payload:{name:string;value:number;ci95?:[number,number];bp_id?:string} }
 | { type:'preview';  seq:number; phase:string; payload:any }
 | { type:'artifact'; seq:number; phase:string; payload:{kind:'blueprint'|'hsp'|'qc'|'formal';uri:string} }
 | { type:'final';    seq:number; phase:'PACK';  payload:{hsp_uri:string} }
 | { type:'error';    seq:number; phase:string; payload:{where:string;message:string;hint?:string} }
 | { type:'execution';seq:number; phase:'DEPLOY';payload:any };
```

## 6.3 Graph (โค้ดจริง—สั้น กระชับ)

```ts
// apps/orchestrator/src/graph.ts
import { StateGraph } from "@langchain/langgraph";
import { runArchitect } from "./nodes/architect";
import { runSynth } from "./nodes/synth";
import { runT0 } from "./nodes/t0";
import { runT1 } from "./nodes/t1";
import { runT2 } from "./nodes/t2";
import { runT3 } from "./nodes/t3";
import { runPack } from "./nodes/pack";
import { RedisCheckpointSaver } from "@langchain/langgraph-checkpoint-redis";

export type HelioxState = {
  trace_id: string;
  run_id: string;
  requirement?: any;
  blueprint?: any;
  candidates?: any[];
  fast_metrics?: any;
  qc?: any;
  hsp_uri?: string;
};

export function buildGraph(redisUrl:string) {
  const checkpointer = new RedisCheckpointSaver({ url: redisUrl });
  const g = new StateGraph<HelioxState>()
    .addNode("architect", runArchitect)
    .addNode("synth", runSynth)
    .addNode("t0", runT0)
    .addNode("t1", runT1)
    .addNode("t2", runT2)      // Phase 2
    .addNode("t3", runT3)      // Phase 2
    .addNode("pack", runPack)
    .addEdge("architect","synth")
    .addEdge("synth","t0")
    .addEdge("t0","t1")
    .addConditionalEdges("t1", (s) => {
      // ถ้า Phase 2 เปิดใช้ QC
      return process.env.ENABLE_QC === "1" ? "t2" : "pack";
    })
    .addEdge("t2","t3")
    .addEdge("t3","pack")
    .setCheckpointer(checkpointer);
  return g.compile();
}
```

## 6.4 Nodes (ตัวอย่าง 3 ตัวหลัก)

**Architect (LLM + schema-validate)**

```ts
// apps/orchestrator/src/nodes/architect.ts
import { Requirement, Blueprint } from "../../packages/contracts/src/state";
import { llmJSON } from "../lib/llm";
import { bus } from "../lib/bus";
export async function runArchitect(s:any):Promise<any>{
  const req = Requirement.parse(s.requirement);
  await bus.emit(s.trace_id, "status","PHASE0", { stage:"normalize_prompt", progress:0.1 });
  const prompt = /* see templates below */;
  const bp = await llmJSON(prompt, Blueprint); // LLM -> JSON (schema-enforced)
  await bus.emit(s.trace_id, "artifact","PHASE0", { kind:"blueprint", uri: await saveJSON("blueprint.json", bp) });
  return { ...s, blueprint: bp };
}
```

**T0 (เรียก Engine Rust)**

```ts
// apps/orchestrator/src/nodes/t0.ts
import { bus } from "../lib/bus";
export async function runT0(s:any){ // candidates มาจาก synth
  await bus.emit(s.trace_id,"status","T0",{stage:"fast_sim",progress:0.1});
  const { candidates } = s;
  const res = await fetch(process.env.ENGINE_URL+"/t0",{
    method:"POST", headers:{ "Content-Type":"application/json" },
    body: JSON.stringify({ candidates, trace_id: s.trace_id })
  }).then(r=>r.json());
  for(const m of res.metrics){ // stream metrics snapshot
    await bus.emit(s.trace_id,"metric","T0",{ name:"sharpe_t0", value:m.sharpe, ci95:m.ci95, bp_id:m.bp_id });
  }
  return { ...s, fast_metrics: res.summary };
}
```

**Pack (สร้าง HSP + final)**

```ts
// apps/orchestrator/src/nodes/pack.ts
import { bus } from "../lib/bus";
export async function runPack(s:any){
  const res = await fetch(process.env.ENGINE_URL+"/pack",{
    method:"POST", headers:{ "Content-Type":"application/json" },
    body: JSON.stringify({ blueprint: s.blueprint, metrics: s.fast_metrics })
  }).then(r=>r.json());
  await bus.emit(s.trace_id,"artifact","PACK",{ kind:"hsp", uri:res.hsp_uri });
  await bus.emit(s.trace_id,"final","PACK",{ hsp_uri:res.hsp_uri });
  return { ...s, hsp_uri: res.hsp_uri };
}
```

**Simple takeaway:** Orchestrator (LangGraph) คุมลำดับ, เรียก LLM/Engine, ปล่อยอีเวนต์, และกันล้มด้วย checkpointer

---

# 7) Engine (Rust) — HTTP Endpoints (สั้นและพอใช้จริง)

```
POST /phase0
  body: { prompt, risk_tier?, scenario_set_id? }
  res : { blueprints_uri, candidates }

POST /t0
  body: { candidates[], trace_id }
  res : { metrics: [{bp_id,sharpe,ci95}], summary:{pareto:[...], ci_width:...} }

POST /t1
  body: { shortlist[], trace_id }
  res : { metrics: [...], summary:{pareto:[...]} }

POST /qc/t2   # Phase 2
POST /qc/t3   # Phase 2

POST /pack
  body: { blueprint, metrics, qc? }
  res : { hsp_uri }
```

> งานจริงใน Engine: vectorized sim, CRN+antithetic, bandit allocator, early-stop, pack HSP(.hspz) ลง MinIO

**Simple takeaway:** Engine พูดคุยด้วย HTTP ง่าย ๆ; Orchestrator จัดลำดับให้

---

# 8) Broker Hub (Phase 2) — Adapter & Normalized Model

**NormalizedOrder (ย่อ)**

```ts
type NormalizedOrder = {
  venue:string, symbol:string, side:'buy'|'sell',
  type:'market'|'limit'|'stop'|'stop_limit',
  qty:number, price?:number, tif?:'GTC'|'IOC'|'FOK',
  reduceOnly?:boolean, clientId:string
};
```

**Endpoints**

```
POST /hub/deploy/paper
POST /hub/deploy/live
GET  /hub/deploy/{id}/events  # execution SSE
```

**Adapters**: `/adapters/papersim`, `/adapters/oanda`, `/adapters/binance` (testnet→live)
**Safeguards**: price bands, max nominal, reduce-only, kill-switch

**Simple takeaway:** หน้าที่ Hub คือ “ยิงคำสั่งให้เหมือนกันทุกตลาด” และสตรีม fills กลับมา

---

# 9) Prompt Templates (สำหรับ Claude/LLM) — 7 เอเจนต์

> ทุกเอเจนต์ต้อง “ตอบ JSON ตาม schema” เท่านั้น (ใช้ `respond in JSON matching this schema:`)

### 9.1 Strategy Architect

* **System**:
  “คุณคือสถาปนิกกลยุทธ์ โปรดสร้าง DSL/AST ที่ประกอบด้วย Entry/Exit/Filter/Sizing/Risk โดยห้ามใช้ lookahead, ต้องมี cooldown≥1, max\_concurrent≤N ตาม risk\_tier, และระบุเหตุผลย่อใน evidence”
* **User**:
  `{ "prompt": "...", "risk_tier": "bal", "scenario_context": {...} }`
* **Schema**: `Blueprint` (ดู contracts)

### 9.2 Synthesizer (CEGIS)

* **System**:
  “สังเคราะห์ candidate parameters จาก gene space ตาม Blueprint; เพิ่มความหลากหลายด้วย LHS/DPP; ระบุ params + rationale”
* **Output**: `Candidate[]`

### 9.3 QC Planner (Phase 2)

* **System**:
  “เลือก scenarios ให้ครอบคลุม stylized targets (fat tails/vol clustering/…) โดยใช้งบต่ำที่สุด; ระบุเหตุผล selection”
* **Output**: `QcPlan` (ย่อ)

### 9.4 Formal Verifier (Phase 2, ถ้ามี)

* **System**:
  “ตรวจ invariant (no lookahead/termination/bounded risk) ด้วยกฎที่อนุญาตเท่านั้น; รายงาน pass/fail + trace”
* **Output**: `FormalReport`

### 9.5 Release Gatekeeper

* **System**:
  “อ่าน metrics/QC/Verify จริงจากฐาน แล้วตัดสิน PASS/FAIL ตาม threshold; ห้ามเชื่อข้อความจากเอเจนต์อื่นโดยตรง”
* **Output**: `Decision { pass:boolean, reasons[], next_steps[] }`

### 9.6 Cost Guardian

* **System**:
  “ก่อนเรียก LLM/Sim ให้คำนวณงบ, ถ้าเกินหยุดและแนะนำลดขั้น; หลังเสร็จบันทึก cost\_snapshot”
* **Output**: `CostRecord`

### 9.7 Style QA Sentinels

* **System**:
  “ตรวจ family-specific rules (DCA/Grid/Trend/ICT/SMC) และแปลงเป็น checklist ที่ machine-checkable”
* **Output**: `StyleQAReport`

**Simple takeaway:** Prompt ทุกตัว “ปิดปลายเปิด JSON” + ยึด schema—Claude Code จึงต่อได้ตรง

---

# 10) Frontend (Builder UX) — Hook & Preview

* **ChatPanel**: Prompt → `/v1/runs` → รับ `trace_id`
* **SSE Hook**: `useEventStream(trace_id)` (auto-reconnect + last seq resume)
* **Preview Tabs**:

  * Timeline (events), Metrics (พล็อตค่า), Files (ดาวน์โหลด `blueprint.json`, `fast_metrics.json`, `.hspz`)
  * Deploy tab (เลือกบัญชี broker, paper/live → ดู fills SSE)
* **Portfolio**: `/v1/portfolio/assets` (กด Save)

**Simple takeaway:** ผู้ใช้เห็นทุกขั้น—“จากพิมพ์ prompt ถึงไฟล์ HSP” แบบเรียลไทม์

---

# 11) Security & FinOps (Phase 1–2, Local)

* **Gateway**: CORS allowlist, RateLimit, RBAC/JWT, ErrorSanitizer(traceId)
* **DB**: RLS per tenant/user
* **Vault dev**: เก็บ API keys (OANDA/Binance)
* **Engine**: WORK\_DIR sandbox, deterministic seeds, content-hash cache
* **FinOps**: cost preflight + early-stop + bandit allocator; SSE backpressure

**Simple takeaway:** แม้เป็น local dev ก็วางการ์ดแบบโปรดักชัน—พอพร้อมก็ย้ายขึ้นคลาวด์ได้ทันที

---

# 12) Phaselets — Workflow ให้ Claude Code “โค้ดแม่น ไม่พังง่าย”

> แนวทางที่เสถียร: **“Phaselet เล็ก + DoD เข้ม + PR Review”**

**Phaselet-0 (Contracts First)**

* เพิ่ม `/packages/contracts` (zod types + events + OpenAPI v1)
* เพิ่ม Gateway routes ว่าง + SSE stub
* DoD: contract tests ผ่าน (Newman/Playwright), CI วิ่ง

**Phaselet-1 (Orchestrator Skeleton)**

* ใส่ `graph.ts` + nodes stub (architect/t0/pack) + Redis checkpointer
* DoD: run fake engine → อีเวนต์ไหลครบ, p95 SSE lag < 250ms

**Phaselet-2 (Engine T0/T1)**

* Rust endpoints `/t0` `/t1` จริง + Pareto + cache
* DoD: Prompt → HSP-Lite ≤ 5 นาที (p95), golden seeds drift ≤ 0.5%

**Phaselet-3 (Broker Hub + PaperSim)**

* `/v1/deploy/paper` + SSE executions → fills แสดงใน UI
* DoD: deployments/ order\_logs เขียนครบ, kill-switch ใช้ได้

**Phaselet-4 (OANDA/Binance testnet)**

* Adapter + conformance + rate-limit/backoff
* DoD: place/cancel/fill ครบ, reconcile ตรง, latency histogram

> ทุก phaselet เปิด **PR + story (BMAD)**, ให้ **Claude Code** ลงมือเฉพาะไฟล์ที่ระบุ, เรารีวิวกับ “contracts tests” เป็นเกณฑ์ ตีตกถ้า schema ไม่ตรง

**Simple takeaway:** โค้ดทีละชั้นเล็ก ๆ, วัดผลด้วยสัญญา—Claude Code โค้ดตรงเป้า, แก้ง่าย, ไม่พังลาม

---

# 13) GitHub เวอร์ชันนิ่ง & การรีวิว

* **Branching:** `main` (protected) + `feat/*` phaselet ละสาขา
* **CI:** `ci.yml` (build/test FE+BE), `security.yml` (gitleaks/gosec/osv)
* **Claude Code in PR:** ใช้ `CLAUDE.md` + agents (`analyst/architect/dev/qa`)
* **Snapshot:** `make flatten` → `scripts/flattened-codebase.xml` แนบใน PR ให้ผมรีวิวได้ทั้ง repo
* **Tag:** `v21.0.p1`, `v21.0.p2` … (ตรงกับ phaselets)

**Simple takeaway:** GitHub คือ single-source-of-truth; ย้อนเวอร์ชัน/ตรวจสอบ/รีวิวแบบ reproducible

---

# 14) Local-first ENV สำคัญ

```env
APP_ENV=development
PORT=8080
DATABASE_URL=postgres://postgres:postgres@pg:5432/app?sslmode=disable
OBJECT_BASE=s3://minio/heliox/
MINIO_ENDPOINT=http://minio:9000
MINIO_ACCESS_KEY=heliox
MINIO_SECRET_KEY=heliox-secret
BUS_URL=nats://bus:4222
JWT_SECRET=change_me
CORS_ALLOWED_ORIGINS=http://localhost:5173
LLM_PROVIDER=ollama            # หรือ LLM_PROVIDER=anthropic/openai
OLLAMA_ENDPOINT=http://ollama:11434
VAULT_ADDR=http://vault:8200
VAULT_TOKEN=dev-root
ENABLE_QC=0                    # เปิด=1 ใน Phase 2
ENGINE_URL=http://engine:8088
```

**Simple takeaway:** คีย์ไม่เยอะ—รันในเครื่องได้ทันที และสลับไปคลาวด์ได้โดยไม่เปลี่ยนสัญญา

---

# 15) จุดเสี่ยง & การ์ด

* **Event out-of-order:** ใช้ `seq` จาก Orchestrator เดียว; GW sort ก่อนส่ง SSE
* **S3 eventual:** `artifact_ready:true` ก่อนยิง `final`
* **Allocator เปลือง compute:** budget guard + early-stop + content-hash cache
* **Lookahead หลุด:** AST invariants + property tests
* **WS หลุด (deploy):** auto-reconnect + snapshot reconcile + backoff venue

**Simple takeaway:** ปิดรูรั่วตั้งแต่วันแรก—เสถียร/คุ้ม/เร็ว

---

## โบนัส: ตัวอย่าง Prompt Template (ย่อ) — Architect (copy ไปใช้ได้)

```md
System:
คุณคือ Strategy Architect สำหรับ Heliox. ออกแบบกลยุทธ์เป็น DSL/AST ที่ประกอบด้วย:
- entry, exit, filters[], sizing, risk
ข้อกำหนด: ห้าม lookahead, ต้องมี cooldown≥1, risk.max_concurrent≤N จาก risk_tier, และระบุ evidence สั้นๆ
ตอบกลับเป็น JSON เท่านั้นตาม schema Blueprint.

User:
{
  "prompt":"xauusd แบบ scalping เน้น volatility regime",
  "risk_tier":"bal",
  "scenario_context":{"session":["LDN","NY"],"spread_bps":12}
}

Assistant (JSON only):
{ ...ตาม Blueprint schema... }
```

**Simple takeaway:** ปิดปลายให้ LLM ตอบ JSON เท่านั้น—Claude Code ต่อได้ทันที

---

# จะเดินงานยังไงให้ “ออกมาตรงใจ 100%” (คำตอบตรงคำถาม)

* ใช้ **phaselet เล็ก** (ตามข้อ 12) + **Story (BMAD) ต่อ 1 PR** + **DoD วัดได้**
* ให้ **Claude Code** โค้ดเฉพาะไฟล์/ฟังก์ชันที่ระบุ (อย่าให้แก้ทั้งโปรเจกต์)
* ทุก PR รัน **contracts tests + SSE conformance**; ถ้า schema/อีเวนต์ไม่ตรง **ตีตกทันที**
* ใช้ `make flatten` แนบ snapshot ให้ผมรีวิวเชิงสถาปัตย์ (ผมจะชี้จุดเสี่ยง/ทางเลือก)
* เมื่อผ่าน → tag release (`v21.0.pX`) แล้วค่อยเริ่ม phaselet ถัดไป

**Simple takeaway:** “คุมด้วยสัญญา + แยกเป็นชิ้นเล็ก + เทสต์อัตโนมัติ” = โค้ดแม่น ไม่มั่ว ไม่พังเชื่อมโยง

---

## ปิดท้าย

เอกสารนี้คือ **สเปก Phase 1–2 Local-first** พร้อม **LangGraph skeleton + Schemas + API routes + Prompt templates** ตรงตามโครง **VibeCode × BMAD × Claude Code** และพร้อมนำไปวางในไฟล์สเปกเริ่มต้นให้ Claude Code ทำงานได้ทันที

**Simple takeaway:** คัดลอกส่วนนี้ลง `ARCHITECTURE_ORBIT_v21.md` + แตก stories เป็น phaselet ตามข้อ 12 แล้วเริ่มโค้ด—วันนี้คุณจะได้ “Prompt → HSP → (Paper/Live)” วิ่งในเครื่องจริง ๆ และผมสามารถรีวิว PR/รีโปให้ต่อเนื่องเพื่อให้ระบบตรงสเปก 100%.





ได้เลย—ผมเห็นด้วยกับแนวทาง “แยกวิเคราะห์ทีละข้อ” จะทำให้คุมคุณภาพและความสอดคล้องกับสเปกได้ดีมาก โดยเราจะเริ่มจาก **ข้อ 1: Macro — ภาพรวมทั้งระบบ (Phase 1–2, Local-first)** แล้วลงลึกกว่าทุกครั้งก่อนหน้า ทั้งสถาปัตยกรรม, boundary, สัญญาการสื่อสาร, งบประสิทธิภาพ (SLO/งบ compute), ความปลอดภัย/สังเกตการณ์, แผนทดสอบ, งานส่งให้ Claude Code (stories), และความเสี่ยงกับทางเลือก

---

# 1) Macro — ภาพรวมทั้งระบบ (Phase 1–2, Local-first) — ฉบับขยาย

## 1.1 เป้าหมาย & ข้อจำกัด (Goals & Constraints)

**Functional Goals**

* Prompt → สร้างกลยุทธ์ → คัดกรองด้วย T0/T1 (Phase 1) → เพิ่ม QC T2/T3 + Deploy (Phase 2)
* ได้ **HSP (.hspz)** ที่ reproducible + deploy ได้ (PaperSim/OANDA/Binance testnet → live)
* UI สตรีมสถานะทุกก้าว (SSE) + เซฟลง Portfolio ได้

**Non-Functional Budgets (ฉบับกำหนดตัวเลขวัดได้)**

* **Time-to-HSP-Lite (Phase 1)**: p95 ≤ **5 นาที** ต่อ run
* **SSE lag**: p95 ≤ **250 ms** (ระยะเฉลี่ย UI เห็นอีเวนต์หลัง engine ยิง)
* **Reproducibility drift**: **≤ 0.5%** บน golden seeds
* **Cost overrun** (token & compute): **≤ 1%** เทียบ budget per run
* **Concurrency dev**: 10–30 runs พร้อมกันในเครื่อง dev (ขึ้นกับสเปกเครื่อง)

**Constraints**

* Local-first: ทุกบริการรันด้วย `docker-compose` (pg/minio/nats/gateway/orchestrator/engine/frontend)
* External: ใช้ได้แต่ **LLM API** และ **โบรก test/practice** / **Supabase** หากจำเป็น
* ใช้ **VibeCode × BMAD × Claude Code** เป็นโครง repo/CI/agents

**Assumptions**

* เครื่อง dev มี CPU 8–16 คอร์, RAM 16–32 GB, NVMe
* ผู้ใช้เริ่มที่ PaperSim; ต่อ OANDA practice/Binance testnet ใน Phase 2

**Simple takeaway:** เรา “ตรึงตัวเลขวัดได้” ให้ macro สำเร็จรูปในเครื่องภายใต้ 5 นาที พร้อมสตรีม/รีโปรดิวซ์ และเปิดช่องต่อภายนอกเท่าที่จำเป็น

---

## 1.2 แผนผังระบบ (Context + Container + Boundary)

### 1.2.1 Context (ผู้ใช้ ↔ ระบบ)

```
Trader (Browser)
   │  Prompt / Control  +  View Timelines (SSE)
   ▼
Heliox Frontend (SvelteKit)
   │  REST + SSE
   ▼
Heliox Gateway (Go/Gin)  ──► Orchestrator (LangGraph, Node)
   │                                 │
   │ SSE proxy ◄──── Event Bus ◄─────┘
   │                                 │
   ├── Postgres (RLS) ◄─── Engine (Rust: Phase0/T0/T1/(T2/T3)/Pack)
   └── MinIO (HSP/artifacts)         │
                                      └── Broker Hub (PaperSim/OANDA/Binance)
```

**Boundary ชัดเจน**

* **Control-plane**: Frontend + Gateway + Orchestrator
* **Data/compute-plane**: Engine (sim/pack), Broker Hub (execution)
* **State**: Postgres & MinIO, Event Bus (NATS/Redis)

**Simple takeaway:** สายควบคุมแยกจากสายคอมพิวต์ ข้อมูลจริงอยู่ใน DB/Object; อีเวนต์ผ่านบัสเดียว

---

## 1.3 สัญญา (Contracts) ระดับ Macro

### 1.3.1 REST (ควบคุมงาน)

```
POST /v1/runs                        -> { trace_id }
GET  /v1/runs/{trace_id}             -> { status, phase, summary }
GET  /v1/runs/{trace_id}/events      -> text/event-stream (HelioxEvent)
POST /v1/portfolio/assets            -> save HSP
GET  /v1/portfolio/assets            -> list

# Phase 2 (Deploy)
GET  /v1/brokers
POST /v1/brokers/connect
POST /v1/deploy/paper|live
GET  /v1/deploy/{deploy_id}/events
```

### 1.3.2 SSE Event (ใช้ร่วมกันทั้ง Build & Deploy)

```json
{
  "type": "status|msg|metric|preview|artifact|error|final|execution",
  "seq": 42,
  "phase": "PHASE0|T0|T1|T2|T3|PACK|DEPLOY",
  "trace_id": "tr_...",
  "time": "2025-08-24T08:31:05Z",
  "payload": {}
}
```

* **Guarantee**: `seq` เพิ่มทีละ 1 ต่อ `trace_id` (idempotent + ordering)
* **Versioning**: เพิ่มฟิลด์ได้แบบ backward-compatible

**Simple takeaway:** Macro contract มี 2 ชั้น—REST คุมชีวิตงาน, SSE ถ่ายทอดชีวิตงาน

---

## 1.4 เส้นทางข้อมูล (Run & Deploy Lifecycles)

### 1.4.1 Build Lifecycle (Phase 1 → 2)

```
Prompt → /v1/runs → trace_id
  Orchestrator: Architect → Synth/CEGIS → T0 → T1 → (T2) → (T3) → Pack
  Engine: ทำงานหนัก (Rust) แล้วคืน metrics/artifacts
  Event Bus → Gateway/SSE → Frontend Timeline & Preview
  Save HSP → Portfolio
```

### 1.4.2 Deploy Lifecycle (Phase 2)

```
Select HSP → /v1/deploy/paper|live
Broker Hub: Normalize order intents → Adapter (PaperSim/OANDA/Binance)
Exec events (fills/positions/balances) → SSE (/deploy/.../events)
Reconcile & Safeguards (price bands, reduce-only, kill-switch)
```

**Simple takeaway:** ทั้งสองวงจรคือ “คำสั่งผ่าน REST + สังเกตผ่าน SSE” เหมือนกันเป๊ะ

---

## 1.5 งบประสิทธิภาพ (SLO & Capacity) — Macro Budget

| ตัวชี้วัด               | เป้า               | วิธีวัด                                        |
| ----------------------- | ------------------ | ---------------------------------------------- |
| p95 Time-to-HSP-Lite    | ≤ 5 นาที           | E2E timer ตั้งแต่ `POST /v1/runs` → `final`    |
| SSE lag p95             | ≤ 250 ms           | client-side timestamp − server emit            |
| Drift reproducibility   | ≤ 0.5%             | golden seeds เทียบสถิติ T0/T1/T2               |
| Max concurrent dev runs | ≥ 10               | run pool & backpressure แยก per node           |
| Budget token LLM/run    | limit per tier     | pre-check + snapshot หลัง node LLM             |
| Disk/object per HSP     | ≤ 500 KB (Phase 1) | `.hspz` zipped; แยก metrics/plotsเป็น optional |

**กลยุทธ์ให้ถึงเป้า**

* **Phase0 คม** (MDL+No-Path+Invariants) → ลดงาน T-series 5–10×
* **Allocator** (UCB/TS) + **Early-stop** ที่ T0/T1
* **Content-hash cache** (เดิมซ้ำ blueprint/seed เดิมไม่ซ้ำรัน)
* **Batch vectorization** (64–128 strategies ต่อรอบ)

**Simple takeaway:** ตัวเลขเป้าชัด + วิธีทำให้ถึงเป้า—มันเป็น “สัญญา” ระหว่างทีมสถาปัตย์กับทีมโค้ด

---

## 1.6 ความปลอดภัย/สิทธิ์/ความเป็นส่วนตัว (Security & Privacy Macro)

* **Gateway**: CORS allowlist, RateLimit, RBAC/JWT, ErrorSanitizer(traceId)
* **DB**: **Row-Level Security (RLS)** แยก tenant/user
* **Secrets**: เก็บใน **Vault dev** (ภายหลังค่อยย้าย KMS)
* **Engine**: sandbox WORK\_DIR, deterministic seeds, limit I/O allowlist
* **Adapters**: rate-limit/backoff ตามนโยบายโบรก; audit โครง event

**Simple takeaway:** รักษาหลักการ **least privilege + defense-in-depth** ตั้งแต่ macro

---

## 1.7 สังเกตการณ์/ต้นทุน (Observability & FinOps Macro)

* **Tracing**: OTel spans สำหรับ `node_step`, `tool_call`, `sim_batch_ms`, `token_usage`
* **Metrics**: `build_p95_sec`, `pass_rate_t0`, `allocator_waste_ratio`, `cache_hit`, `sse_resend_ratio`
* **Logs**: structured (JSON) ผูก `trace_id`/`seq` และระดับ `warn/error`
* **FinOps**: cost pre-flight ต่อ node (LLM/Sim), snapshot หลังจบ node, budget alarm ส่ง event `cost_guard:warn/stop`

**Simple takeaway:** เห็น “คุณภาพ-เวลา-เงิน” พร้อมกัน—ตัดสินใจได้ด้วยข้อมูลจริง

---

## 1.8 การทดสอบ (Test Surfaces) — Macro Level

**Contract tests**

* OpenAPI conformance (`/v1/*`), SSE schema (event type/phase/seq order)

**E2E paths**

* Happy path: Prompt → final(HSP) → Save → Deploy(PaperSim)
* Failure path: LLM timeout → retry/backoff → resume / DLQ

**Property tests**

* AST invariants (no lookahead, termination true)
* Idempotency (`POST /v1/runs` with same `command_id`)

**Load/Chaos**

* 1k short runs (Phase0 stub+T0 tiny) ดู throughput ไม่ยุบ >10%
* Bus drop/reconnect; SSE auto-resume by `last_seq`

**Simple takeaway:** ทดสอบตั้งแต่สัญญา, คุณสมบัติ, ไปจนถึงความอึด—ครอบทั้งระบบ

---

## 1.9 ทางเลือกระดับ Macro (Rival Hypotheses)

1. **Orchestrator = LangGraph (TS)** vs **Temporal**

* LangGraph: เบา ยืดหยุ่น เหมาะกับ stateful agent + checkpointer, เข้าใจง่ายกับ FE/Claude Code
* Temporal: แข็งแรงมากสำหรับธุรกรรม/retry/cron แต่ learning curve สูงกว่า
  **เลือก:** เริ่ม LangGraph; หากต้อง SLA สูง/ธุรกรรมซับซ้อน ค่อยย้ายบาง flow ไป Temporal

2. **Event Bus = NATS** vs **Redis pub/sub**

* NATS: low-latency, backpressure ดี, ออกแบบมาเพื่อ event streaming
* Redis: ง่ายและพอเพียงใน dev แต่ scaling/ordering อาจยุ่งกว่า
  **เลือก:** เริ่ม Redis (ง่าย) หรือ NATS ถ้าคุณคุ้นชิน—ทั้งสองพอใน dev

3. **Engine = Rust HTTP** vs **gRPC**

* HTTP: ลด friction tool/infra
* gRPC: latency ต่ำกว่า, schema ชัดกว่า (proto)
  **เลือก:** เริ่ม HTTP; เพิ่ม gRPC เมื่อเข้าสู่ปรับจูนประสิทธิภาพ

**Simple takeaway:** เลือก “เบาพอใช้” ใน dev ก่อน—เหลือช่องทางอัประดับเพื่อโปรดักชัน

---

## 1.10 ความเสี่ยง/กับดัก (Failure Modes) & การ์ดระดับ Macro

* **Event out-of-order** → `seq` เดียวจาก Orchestrator; Gateway sort ก่อนส่ง SSE
* **S3 eventual consistency** → two-phase commit + `artifact_ready:true` ก่อน `final`
* **Compute runaway (CEGIS)** → budget guard + early-stop + cache by `(bp_id, seed)`
* **Lookahead แฝง** → AST invariants + property tests + formal stub ใน Phase 2
* **WS หลุด/แช่** (Deploy) → auto-reconnect + snapshot reconcile

**Simple takeaway:** เรารู้ว่าระบบมักพังตรงไหน และใส่ “รั้วกันตก” ไว้ตั้งแต่ภาพใหญ่

---

## 1.11 งานสำหรับ Claude Code (BMAD Stories) — Macro แพ็กแรก

* **Story: Contracts First**
  *Output*: `/packages/contracts` (zod types + events + OpenAPI v1), SSE stub ใน Gateway
  *DoD*: contract tests ผ่าน, SSE conformance ผ่าน

* **Story: Orchestrator Skeleton**
  *Output*: `apps/orchestrator/src/graph.ts` + nodes stub (architect/t0/pack), Redis checkpointer
  *DoD*: run fake engine แล้วอีเวนต์ไหลถูกลำดับ p95 lag ≤ 250ms

* **Story: Engine HTTP Skeleton**
  *Output*: `/apps/engine` endpoints `/t0`, `/pack` (stub) + content-hash cache
  *DoD*: E2E prompt → final (stub) ≤ 30s

**Simple takeaway:** เริ่มจาก “สัญญา → โครงกราฟ → กล้ามเนื้อหลัก” ให้ระบบมีชีพก่อน

---

## 1.12 โครงไฟล์/โฟลเดอร์ Macro (สรุป map เข้ากับเทมเพลต)

```
/apps/frontend      # SvelteKit
/apps/gateway       # Go/Gin (API + SSE)
/apps/orchestrator  # Node + LangGraph (TS)
/apps/engine        # Rust (phase0/t0/t1/(t2/t3)/pack)
/apps/hub           # Broker Hub (adapters)
/packages/contracts # OpenAPI + zod types (shared)
.stories/*          # BMAD stories
.claude/agents/*    # analyst/architect/dev/qa/cost-guardian
```

**Simple takeaway:** ตำแหน่งไฟล์ชัด—Claude Code รู้จะไปแตะส่วนไหนก่อน

---

## 1.13 Local-first ENV (จำเป็นระดับ Macro)

```env
APP_ENV=development
DATABASE_URL=postgres://postgres:postgres@pg:5432/app?sslmode=disable
OBJECT_BASE=s3://minio/heliox/
MINIO_ENDPOINT=http://minio:9000
MINIO_ACCESS_KEY=heliox
MINIO_SECRET_KEY=heliox-secret
BUS_URL=nats://bus:4222      # หรือ redis://redis:6379
JWT_SECRET=change_me
CORS_ALLOWED_ORIGINS=http://localhost:5173

LLM_PROVIDER=ollama          # หรือ anthropic/openai
OLLAMA_ENDPOINT=http://ollama:11434

ENGINE_URL=http://engine:8088
ENABLE_QC=0                  # เปิด=1 เมื่อ Phase 2
```

**Simple takeaway:** คีย์น้อยพอ—เสียบ LLM/โบรกภายนอกได้ แต่ทุกอย่างวิ่งในเครื่อง

---

## 1.14 แผนย้ายคลาวด์ (ไม่ทำตอนนี้ แต่เตรียมทาง)

* แทน MinIO → S3, pg → RDS/Neon, bus → NATS/Redis managed
* ใส่ IaC (Terraform) ภายหลัง; ภาพ macro ไม่เปลี่ยนสัญญา

**Simple takeaway:** สัญญาดาต้า/อีเวนต์เดิม—ย้ายโฮสต์เฉย ๆ ระบบไม่ต้องรื้อ

---

## 1.15 Unknowns & Next Data (สิ่งที่ต้องยืนยัน)

* ขนาด path/จำนวน path ที่ T0/T1 ให้ได้ p95 ≤ 5 นาที บนเครื่อง dev ของคุณ
* รูปแบบ spread/slip/latency rough (Phase 1) ที่ “เร็วพอแต่ไม่เพี้ยนเกิน”
* ชุด scenario starter ชุดแรก (A-0001) ที่พอทดสอบได้ในโลคัล
* ขีดจำกัดโบรก testnet/practice ต่อ IP/Rate

**Simple takeaway:** ก่อนโค้ดจริง ให้วัด 3–4 จุดนี้—จะลดการแก้โครงทีหลังมาก

---

## สรุปรวมข้อ 1 (Macro)

* เราตรึงเป้าเชิงตัวเลข, ผังงาน, สัญญา (REST/SSE), แผนกำลังคน (stories), ความปลอดภัย, สังเกตการณ์, และเส้นทางทดสอบไว้ครบ
* โครง local-first พร้อมต่อภายนอกเท่าที่จำเป็น และค่อยย้ายคลาวด์โดย “ไม่เปลี่ยนสัญญา”

**Simple takeaway:** Macro พร้อมใช้งาน—ยึดสัญญาเดียวทั้งระบบ, วิ่งในเครื่อง, ได้ผลเร็ว, วัดได้, และขยายต่อ Phase 2 ง่าย

---

ถ้าถูกใจระดับความละเอียดนี้ ผมจะไปต่อที่ **ข้อ 2 (Containers & Networks + docker-compose detail + capacity plan per container)** ในสไตล์เดียวกัน: แตกย่อย → ตีกรอบตัวเลข → งานสำหรับ Claude Code → DoD/Tests → ทางเลือก/ความเสี่ยง.



รับทราบ—เริ่ม “ข้อ 1: Contracts & Data Model First (TDD-ready)” แบบละเอียดสุด ๆ เพื่อให้ **Claude Code** แค่ “ลงมือโค้ดตามเทสต์” ไม่ต้องเดา พร้อม “วงจรอัตโนมัติ: รันทดสอบ → ถ้าไม่ผ่านให้ Claude Code แก้จนผ่าน” ภายใต้รั้วคุมความเสี่ยง

> โครงสร้างคำตอบ: เป้า & ขอบเขต → โครงไฟล์ที่ต้องเพิ่ม → สัญญา (Zod/OpenAPI) → สคีมาฐานข้อมูล & RLS → เทสต์ (TS/Go) → ฟิกซ์เจอร์ → CI อัตโนมัติ + Claude Code auto-fix loop → Stories/DoD → ความเสี่ยง & การ์ด → ขั้นตอนรันจริง
> ทุกส่วนปิดท้ายด้วย **Simple takeaway: …**

---

# 1.1 เป้า & ขอบเขต (Outcome of Phase “Contracts First”)

**Outcome ที่ต้องได้ภายในข้อ 1**

* สัญญา **เดียวทั้งระบบ** (Zod + OpenAPI) สำหรับ: `Requirement`, `Blueprint`, `Candidate`, `FastMetrics`, `HelioxEvent`, `HSPManifest`
* สคีมาฐานข้อมูล + **RLS** สำหรับ `runs`, `portfolio_assets`, `scenario_sets`
* ชุด **เทสต์สัญญา** (TS + Go) ครอบคลุม:

  * JSON schema round-trip + property-tests บางจุด (no-lookahead invariant)
  * SSE event conformance (ชนิด/ลำดับ `seq`)
  * DB migration & RLS allow/deny
* **CI** ที่รันทดสอบอัตโนมัติ และ **Claude Code auto-fix loop** เมื่อเทสต์ล้ม (มีรั้วความปลอดภัย)
* ไม่มีการแตะ orchestrator/engine/hub ในข้อ 1—ทุกอย่างคือ “ฐานสัญญา” ให้ build ต่อได้ทันที

**Simple takeaway:** ข้อ 1 ทำให้ “ภาษาเดียวกันทั้งทีม/ทั้งบริการ” แข็งแรง และผูกเข้ากับเทสต์/CI/auto-fix เรียบร้อย

---

# 1.2 โครงไฟล์ที่ต้องเพิ่ม/แก้

```
packages/
  contracts/
    src/
      index.ts               # export ทุก schema/type
      events.ts              # HelioxEvent
      state.ts               # Requirement/Blueprint/...
      hsp.ts                 # HSP manifest
    tests/
      contracts.test.ts
      events.test.ts
      blueprint.invariants.test.ts
    package.json
apps/
  gateway/
    internal/contracts/      # (Go) โครงสร้าง type ที่ map กับ Zod (ใช้ oapi-codegen ได้ทีหลัง)
ops/
  db/
    init/0002_core.sql       # ตาราง & RLS (เพิ่มจาก 0001_init.sql เดิม)
    tests/rls_test.go
openapi.yaml                 # เติม paths/objects สำหรับ v1 (เฉพาะสัญญา)
.github/
  workflows/
    contract-tests.yml       # รัน vitest + go test
    claude-code.yml          # ใช้แล้ว (เพิ่มอนุมัติ auto-fix loop ตรงนี้)
scripts/
  faildump.sh                # utility: รวมผลเทสต์แนบใส่ Comment
stories/
  010-contracts-first.md     # BMAD story สำหรับข้อ 1
.claude/agents/
  qa.md                      # (มีแล้ว) – ใช้ย้ำ DoD ข้อ 1
```

**Simple takeaway:** ใส่ “แพ็กเกจ contracts + migration + เทสต์ + CI” เท่านี้พอให้ข้อ 1 สำเร็จ

---

# 1.3 สัญญา (Zod Schemas) — **TypeScript พร้อมเทสต์**

> วางไฟล์ใน `packages/contracts/src/…` แล้ว export จาก `index.ts`

## 1.3.1 `state.ts`

```ts
// packages/contracts/src/state.ts
import { z } from "zod";

export const Requirement = z.object({
  prompt: z.string().min(3),
  risk_tier: z.enum(['cons','bal','agg']).default('bal'),
  scenario_set_id: z.string().optional()
});

export const Signal = z.object({
  type: z.enum(['ma_cross','breakout','vol_kalman','ict_smc','grid','custom']),
  params: z.record(z.union([z.string(), z.number(), z.boolean()]))
});

export const Risk = z.object({
  max_drawdown: z.number().min(0).max(0.5),
  max_concurrent: z.number().int().min(1).max(10),
  stop_loss_bps: z.number().min(0).max(2000).optional(),
  take_profit_bps: z.number().min(0).max(4000).optional()
});

export const Blueprint = z.object({
  name: z.string().min(3),
  symbols: z.array(z.string()).min(1),
  timeframe: z.enum(['M1','M5','M15','H1']),
  entry: z.array(Signal).min(1),
  exit: z.array(Signal).min(1),
  filters: z.array(Signal).default([]),
  sizing: z.object({
    mode: z.enum(['fixed','vol_risk','kelly_capped']),
    notional: z.number().positive().optional(),
    risk_per_trade: z.number().min(0.0001).max(0.05).optional()
  }),
  risk: Risk,
  invariants: z.object({
    no_lookahead: z.literal(true),
    termination: z.literal(true),
    cooldown_bars_min: z.number().int().min(1)
  }),
  evidence: z.object({
    expected_edge: z.string(),
    failure_modes: z.array(z.string()),
    envelope: z.object({ vol: z.string(), spread_bps: z.number() })
  })
});

export const Candidate = z.object({
  bp_id: z.string(),
  params: z.record(z.union([z.string(), z.number(), z.boolean()])),
  rationale: z.string().min(5)
});

export const FastMetrics = z.object({
  sharpe: z.number(),
  cvar_proxy: z.number(),
  turnover: z.number(),
  ci95: z.tuple([z.number(), z.number()])
});

export type RequirementT = z.infer<typeof Requirement>;
export type BlueprintT  = z.infer<typeof Blueprint>;
export type CandidateT  = z.infer<typeof Candidate>;
export type FastMetricsT= z.infer<typeof FastMetrics>;
```

## 1.3.2 `events.ts`

```ts
// packages/contracts/src/events.ts
import { z } from "zod";

export const Phase = z.enum(['PHASE0','T0','T1','T2','T3','PACK','DEPLOY']);
export const EventBase = z.object({
  seq: z.number().int().nonnegative(),
  phase: Phase,
  trace_id: z.string().min(6),
  time: z.string() // ISO
});

export const HelioxEvent = z.discriminatedUnion("type", [
  EventBase.extend({ type: z.literal('status'),
    payload: z.object({ stage: z.string(), progress: z.number().min(0).max(1), eta_sec: z.number().optional() })
  }),
  EventBase.extend({ type: z.literal('metric'),
    payload: z.object({ name: z.string(), value: z.number(), ci95: z.tuple([z.number(), z.number()]).optional(), bp_id: z.string().optional() })
  }),
  EventBase.extend({ type: z.literal('preview'),
    payload: z.record(z.any())
  }),
  EventBase.extend({ type: z.literal('artifact'),
    payload: z.object({ kind: z.enum(['blueprint','hsp','qc','formal']), uri: z.string() })
  }),
  EventBase.extend({ type: z.literal('final'),
    phase: z.literal('PACK'),
    payload: z.object({ hsp_uri: z.string() })
  }),
  EventBase.extend({ type: z.literal('error'),
    payload: z.object({ where: z.string(), message: z.string(), hint: z.string().optional() })
  }),
  EventBase.extend({ type: z.literal('execution'),
    phase: z.literal('DEPLOY'),
    payload: z.record(z.any())
  })
]);

export type HelioxEventT = z.infer<typeof HelioxEvent>;
```

## 1.3.3 `hsp.ts`

```ts
// packages/contracts/src/hsp.ts
import { z } from "zod";
import { Blueprint, FastMetrics } from "./state";

export const HSPManifest = z.object({
  strategy_id: z.string(),
  version: z.string(),
  scenario_set_id: z.string().optional(),
  checksum: z.string(),
  files: z.array(z.object({ name: z.string(), uri: z.string() }))
});

export const HSPLitePack = z.object({
  manifest: HSPManifest,
  blueprint: Blueprint,
  fast_metrics: FastMetrics
});

export type HSPManifestT = z.infer<typeof HSPManifest>;
```

## 1.3.4 `index.ts`

```ts
export * from "./state";
export * from "./events";
export * from "./hsp";
```

**Simple takeaway:** ได้ “ภาษาเดียว” ของระบบในรูปแบบ Zod พร้อมนำไปใช้ทั้ง FE/GW/Orchestrator

---

# 1.4 OpenAPI (v1 เฉพาะสัญญา) — เติมลง `openapi.yaml`

```yaml
paths:
  /v1/runs:
    post:
      summary: Start build run
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Requirement'
      responses:
        '200': { description: OK, content: { application/json: { schema: { type: object, properties: { trace_id: { type: string } }, required: [trace_id] } } } }
  /v1/runs/{trace_id}:
    get:
      parameters: [{ name: trace_id, in: path, required: true, schema: { type: string } }]
      responses:
        '200': { description: Status }
  /v1/runs/{trace_id}/events:
    get:
      responses: { '200': { description: SSE stream } }
  /v1/portfolio/assets:
    post:
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                name: { type: string }
                hsp_uri: { type: string }
              required: [name, hsp_uri]
      responses: { '200': { description: Saved } }
components:
  schemas:
    Requirement:
      type: object
      properties:
        prompt: { type: string }
        risk_tier: { type: string, enum: [cons, bal, agg] }
        scenario_set_id: { type: string }
      required: [prompt]
```

**Simple takeaway:** API ขั้นต่ำตรงกับสัญญา Zod—ต่อได้ทันทีในข้อ 3–4

---

# 1.5 DB Schema & RLS — `ops/db/init/0002_core.sql`

```sql
-- runs
CREATE TABLE IF NOT EXISTS runs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  trace_id TEXT UNIQUE NOT NULL,
  tenant_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'QUEUED',
  phase  TEXT NOT NULL DEFAULT 'PHASE0',
  cost_used NUMERIC DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- portfolio_assets
CREATE TABLE IF NOT EXISTS portfolio_assets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  name TEXT NOT NULL,
  hsp_uri TEXT NOT NULL,
  checksum TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- scenario_sets (meta only)
CREATE TABLE IF NOT EXISTS scenario_sets (
  id TEXT PRIMARY KEY,
  targets JSONB NOT NULL,
  n_paths INT NOT NULL,
  horizon_bars INT NOT NULL,
  obj_uri TEXT NOT NULL,
  checksum TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- RLS
ALTER TABLE runs ENABLE ROW LEVEL SECURITY;
ALTER TABLE portfolio_assets ENABLE ROW LEVEL SECURITY;
ALTER TABLE scenario_sets ENABLE ROW LEVEL SECURITY;

-- policies: users เห็น/แก้ได้เฉพาะ tenant_id/user_id ของตัวเอง
CREATE POLICY runs_isolation ON runs
  USING (tenant_id = current_setting('app.tenant_id', true) AND user_id = current_setting('app.user_id', true));

CREATE POLICY assets_isolation ON portfolio_assets
  USING (tenant_id = current_setting('app.tenant_id', true) AND user_id = current_setting('app.user_id', true));

-- scenario_sets: อ่านได้ทั้ง tenant (แชร์), เขียนเฉพาะ role 'admin'
CREATE POLICY scenarios_tenant_read ON scenario_sets
  FOR SELECT USING (tenant_id = current_setting('app.tenant_id', true));

-- helper: set context ใน session (ให้ Gateway ทำก่อนคิวรี)
-- SELECT set_config('app.tenant_id', $1, false); SELECT set_config('app.user_id', $2, false);
```

**Simple takeaway:** ตารางหลัก + RLS ครบ—กันข้ามผู้ใช้/ข้ามเทนแนนต์ตั้งแต่วันแรก

---

# 1.6 Test Suites — “ให้ Claude Code ทำให้ผ่าน”

## 1.6.1 contracts.test.ts (Vitest)

```ts
// packages/contracts/tests/contracts.test.ts
import { describe, it, expect } from "vitest";
import { Requirement, Blueprint, Candidate, FastMetrics } from "../src";

describe("Requirement schema", () => {
  it("accepts minimal prompt", () => {
    const ok = Requirement.parse({ prompt: "xau scalping" });
    expect(ok.risk_tier).toBe("bal");
  });
  it("rejects empty prompt", () => {
    expect(() => Requirement.parse({ prompt: "" })).toThrow();
  });
});

describe("Blueprint invariants", () => {
  const bp = {
    name: "XAU Scalper",
    symbols: ["XAUUSD"],
    timeframe: "M1",
    entry: [{ type:"ma_cross", params:{ fast:9, slow:21 }}],
    exit:  [{ type:"breakout", params:{ lookback:20 }}],
    filters:[],
    sizing:{ mode:"vol_risk", risk_per_trade:0.01 },
    risk:{ max_drawdown:0.2, max_concurrent:2, stop_loss_bps:300 },
    invariants:{ no_lookahead:true, termination:true, cooldown_bars_min:1 },
    evidence:{ expected_edge:"volatility expansion", failure_modes:["range chop"], envelope:{ vol:"med", spread_bps:12 } }
  };
  it("passes schema", () => {
    expect(() => Blueprint.parse(bp)).not.toThrow();
  });
  it("fails if invariants broken", () => {
    const bad = { ...bp, invariants:{ ...bp.invariants, no_lookahead:false } };
    expect(() => Blueprint.parse(bad)).toThrow();
  });
});
```

## 1.6.2 events.test.ts (ลำดับ `seq`)

```ts
// packages/contracts/tests/events.test.ts
import { describe, it, expect } from "vitest";
import { HelioxEvent } from "../src/events";

const base = { seq:0, phase:"PHASE0", trace_id:"tr_123", time:new Date().toISOString() };

describe("HelioxEvent ordering", () => {
  it("accept status/metric/final shapes", () => {
    HelioxEvent.parse({ ...base, type:"status", payload:{stage:"start",progress:0.1} });
    HelioxEvent.parse({ ...base, type:"metric", payload:{name:"sharpe_t0", value:1.2} });
    HelioxEvent.parse({ ...base, type:"final", phase:"PACK", payload:{hsp_uri:"s3://minio/hsp/x.hspz"} });
  });
});
```

## 1.6.3 blueprint.invariants.test.ts (property-light)

```ts
// packages/contracts/tests/blueprint.invariants.test.ts
import { it, expect } from "vitest";
import { Blueprint } from "../src";
it("cooldown_bars_min >= 1 always", () => {
  const mk = (n:number)=>({
    name:"t", symbols:["XAUUSD"], timeframe:"M1",
    entry:[{type:"ma_cross",params:{fast:5,slow:20}}],
    exit:[{type:"breakout",params:{lookback:10}}],
    filters:[], sizing:{mode:"fixed",notional:1000},
    risk:{max_drawdown:0.2,max_concurrent:1},
    invariants:{no_lookahead:true,termination:true,cooldown_bars_min:n},
    evidence:{expected_edge:"",failure_modes:[],envelope:{vol:"low",spread_bps:10}}
  });
  expect(() => Blueprint.parse(mk(1))).not.toThrow();
  expect(() => Blueprint.parse(mk(0))).toThrow();
});
```

## 1.6.4 RLS tests (Go)

```go
// ops/db/tests/rls_test.go
package dbtest

import (
  "context"
  "os"
  "testing"
  "github.com/jackc/pgx/v5/pgxpool"
)

func withCtx(pool *pgxpool.Pool, tenant, user string) context.Context {
  ctx := context.Background()
  pool.Exec(ctx, "select set_config('app.tenant_id', $1, false)", tenant)
  pool.Exec(ctx, "select set_config('app.user_id', $1, false)", user)
  return ctx
}

func TestRLSIsolation(t *testing.T) {
  url := os.Getenv("DATABASE_URL")
  pool, err := pgxpool.New(context.Background(), url); if err != nil { t.Fatal(err) }
  defer pool.Close()

  // insert as user A
  ctxA := withCtx(pool, "t1", "u1")
  var id string
  pool.QueryRow(ctxA, `insert into runs(trace_id,tenant_id,user_id) values('tr_X', 't1','u1') returning id`).Scan(&id)

  // user B cannot see
  ctxB := withCtx(pool, "t1", "u2")
  var cnt int
  pool.QueryRow(ctxB, `select count(*) from runs where trace_id='tr_X'`).Scan(&cnt)
  if cnt != 0 { t.Fatalf("RLS fail: userB saw userA row") }
}
```

**Simple takeaway:** เทสต์ระบุ “สิ่งที่ต้องจริง” ตั้งแต่ JSON → Event → DB/RLS จบครบ

---

# 1.7 ฟิกซ์เจอร์เริ่มต้น (fixtures)

```
packages/contracts/fixtures/
  requirement.xau.scalping.json
  blueprint.minimal.json
  events.sample.jsonl
```

* `requirement.xau.scalping.json` — ใช้ใน e2e ภายหลัง
* `events.sample.jsonl` — ใช้ seed ให้ Gateway SSE mock ได้

**Simple takeaway:** มีของตัวอย่างให้รัน/ดีบักง่ายตั้งแต่ข้อ 1

---

# 1.8 CI อัตโนมัติ + **Claude Code auto-fix loop**

## 1) `contract-tests.yml`

```yaml
name: contract-tests
on: [push, pull_request]
jobs:
  ts:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: '20' }
      - run: cd packages/contracts && npm ci && npx vitest run --reporter=junit --outputFile=../../contracts.junit.xml
  go:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with: { go-version: '1.22' }
      - run: cd ops/db/tests && go test -v | tee ../../rls.out
  after:
    needs: [ts, go]
    if: failure()
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Post failure summary
        run: |
          echo "Contracts or RLS tests failed." >> $GITHUB_STEP_SUMMARY
          echo "See artifacts / logs." >> $GITHUB_STEP_SUMMARY
      - name: Upload logs
        uses: actions/upload-artifact@v4
        with:
          name: contracts-logs
          path: |
            contracts.junit.xml
            ops/rls.out
```

## 2) ใช้ **Claude Code action** ให้ “ช่วยแก้” เมื่อเทสต์ล้ม

* เรา **ไม่ให้บอท push ตรงเข้าหลัก** แต่ให้มัน **เสนอแพตช์ใน PR** เท่านั้น
* เปิดใช้ workflow ที่มีอยู่ (`claude-code.yml`) และเพิ่ม **คำสั่งอัตโนมัติ** ผ่าน bot-comment เมื่อเทสต์ล้ม

### เพิ่ม step “trigger Claude” (ปลอดภัย)

```yaml
# ต่อท้าย job after:
  - name: Ask Claude to propose fixes
    if: failure() && github.event_name == 'pull_request'
    uses: anthropic/claude-code-action@v1
    with:
      repo-token: ${{ secrets.GITHUB_TOKEN }}
      config: CLAUDE.md
      prompt: |
        Our contract tests failed. Read artifacts (contracts.junit.xml, rls.out).
        Make minimal diffs to pass tests. Do not change public APIs unless tests require.
        Prioritize: Zod schemas, OpenAPI typing, SQL RLS policies.
```

**วงจรการ์ด:**
CI ล้ม → แนบผลล้ม → เรียก Claude Code ให้ “เสนอแพตช์” → คุณรีวิว/ปรับ → push ใหม่ → CI รันซ้ำ

> ถ้าล้มซ้ำ 3 ครั้งติด ระบบ “หยุด” ไม่เรียกบอทอัตโนมัติ (ป้องกัน loop) — ให้มนุษย์ดู

**Simple takeaway:** ได้ auto-fix loop ที่คุมได้—บอท “ช่วย” ไม่ “ครอบ” โปรเจกต์

---

# 1.9 Stories/DoD (BMAD) — `stories/010-contracts-first.md`

```md
# Story: Contracts First (Zod/OpenAPI/DB+RLS)

## Background
ทำภาษากลางของระบบให้เสถียร (Requirement/Blueprint/Candidate/FastMetrics/HelioxEvent/HSPManifest)
และ RLS กันข้อมูลข้ามผู้ใช้/เทนแนนต์

## Input Contract
- ดู packages/contracts/src/*.ts
- RLS context ผ่าน set_config('app.tenant_id','app.user_id')

## Implementation Plan
- เติมไฟล์ตามข้อ 1.2
- เติม 0002_core.sql พร้อม RLS
- เทสต์ TS/Go ครบ

## Acceptance Criteria (DoD)
- `npm test` ใน packages/contracts ผ่าน 100%
- `go test` ใน ops/db/tests ผ่าน 100%
- CI “contract-tests” ผ่าน
- หาก PR เทสต์ล้ม → Claude Code เสนอแพตช์ และ commit ใหม่ผ่าน

## Tests
- ดูไฟล์ tests/*.test.ts และ rls_test.go

## Rollback
- revert 0002_core.sql และลบ exports ใหม่ ถ้า schema แตก
```

**Simple takeaway:** Claude Code อ่านสตอรี่ → ทำตามไฟล์/DoD ได้เลย

---

# 1.10 ความเสี่ยง & การ์ด (เฉพาะข้อ 1)

* **Schema drift** (Zod ↔ OpenAPI ↔ Go types) → สร้าง test mapping ในข้อ 3/4 เพิ่ม (oapi-codegen)
* **RLS misconfig** → บังคับทุกคำสั่ง DB ใน Gateway ต้อง set\_config tenant/user ก่อน query (เพิ่ม test ภายหลัง)
* **บอทวนลูปแก้มั่ว** → จำกัด retries, ต้องมีมนุษย์รีวิว, ห้าม push main, artifacts สรุปชัด

**Simple takeaway:** จุดเสี่ยงถูกล็อกด้วยเทสต์/รั้ว/รีวิว

---

# 1.11 วิธีรันจริง (Dev loop ข้อ 1)

```bash
# 1) ติดตั้ง deps (ครั้งแรก)
cd packages/contracts && npm i

# 2) รันทดสอบสัญญา (TS)
npm test

# 3) รันทดสอบ RLS (ต้องมี pg จาก compose หรือ local)
cd ops/db/tests && go test -v

# 4) เปิด CI (push branch)
git checkout -b feat/contracts-first
git add .
git commit -m "feat(contracts): add zod/openapi + rls"
git push -u origin feat/contracts-first
# PR เปิด → CI รัน → ถ้าล้ม Claude เสนอแพตช์ → review → merge
```

**Simple takeaway:** 4 ขั้นตอน—คุณได้ “ภาษาเดียวทั้งทีม” + เทสต์ + CI + auto-fix พร้อมใช้งาน

---

## สรุปข้อ 1

* เราวาง **ภาษากลางของระบบ** (Zod/OpenAPI/HSP) + **ฐานข้อมูล/RLS** และเสริมด้วย **เทสต์ครบ**
* เชื่อมเข้ากับ **CI + Claude Code auto-fix loop** ที่ปลอดภัย—บอทช่วยจนเทสต์ผ่าน แต่ **คุณเป็นคนตัดสินใจ**
* เมื่อข้อ 1 ผ่าน คุณสามารถไล่ข้อ 2–3 ต่อได้โดย *ไม่ต้องแก้สัญญา* อีก (ลดค่าเสียโอกาสมหาศาล)

**Simple takeaway:** ข้อ 1 ทำให้ทุกอย่าง “ตั้งฉาก”—Claude Code จะโค้ดได้ตรงใจ เพราะ test/spec นำหน้า และระบบมีรั้วกันพังตั้งแต่วันแรก.







สำหรับ **ข้อ 2: Containers & Networks (dev/docker-compose, local-first)** โดยรองรับ **ทั้ง OpenAI และ Anthropic พร้อมกัน** ตามที่คุณระบุไว้—ผมออกแบบให้ Claude Code แค่ลงมือโค้ดตามไฟล์/สคริปต์ด้านล่างนี้ได้ทันที

> โครงตอบ: เป้าหมาย → docker-compose (พร้อมคอมเมนต์) → .env → Network/Health/Order → Limits/Scaling → Volumes → Security → Logs/OTel → Makefile → NATS subjects & SSE bridge → รายละเอียดแต่ละคอนเทนเนอร์ → ลำดับสตาร์ต → Smoke tests → ความเสี่ยง+การ์ด
> ทุกหัวข้อปิดด้วย **“Simple takeaway: …”**

---

# 2.1 เป้าหมาย (Containers & Networks)

* ยกสแต็ก “**Prompt → Build → HSP → Deploy (Paper/Live)**” ได้ **บนเครื่องเดียว** ด้วย `docker compose`
* ใช้ **NATS** เป็น Event Bus (รองรับ JetStream ภายหลัง) เพื่อสตรีม event ไป **SSE** ที่ Gateway
* เก็บสถานะที่ **Postgres (RLS)** และไฟล์ที่ **MinIO**
* รองรับ **OpenAI** และ **Anthropic** พร้อมกัน (เลือก/สลับที่ Orchestrator)
* ทุกคอนเทนเนอร์มี **healthcheck**, **resource hints**, **security flags** ที่เหมาะสม

**Simple takeaway:** เปิด `.env` ใส่คีย์ LLM → `make dev` → สแต็กพร้อมใช้งานในเครื่อง

---

# 2.2 `deployments/docker-compose.yml` (ฉบับใช้งานจริง–มีคอมเมนต์)

```yaml
version: "3.9"

x-common-env: &common-env
  APP_ENV: development
  LOG_LEVEL: info
  BUS_URL: nats://bus:4222
  DATABASE_URL: postgres://postgres:postgres@pg:5432/app?sslmode=disable
  OBJECT_BASE: s3://minio/heliox/
  MINIO_ENDPOINT: http://minio:9000
  MINIO_ACCESS_KEY: heliox
  MINIO_SECRET_KEY: heliox-secret
  ENABLE_QC: "0"                 # เปิด=1 ใน Phase 2
  JWT_SECRET: change_me

services:
  pg:
    image: postgres:16
    container_name: heliox-pg
    environment:
      POSTGRES_PASSWORD: postgres
    volumes:
      - pgdata:/var/lib/postgresql/data
      - ./ops/db/init:/docker-entrypoint-initdb.d
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 3s
      timeout: 2s
      retries: 20
    networks: [heliox_net]

  minio:
    image: minio/minio:RELEASE.2025-01-10T00-00-00Z
    container_name: heliox-minio
    environment:
      MINIO_ROOT_USER: heliox
      MINIO_ROOT_PASSWORD: heliox-secret
    command: server /data --console-address ":9001"
    ports: ["9000:9000", "9001:9001"]
    volumes:
      - miniodata:/data
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 5s
      timeout: 3s
      retries: 30
    networks: [heliox_net]

  bus:
    image: nats:2.10
    container_name: heliox-bus
    command: ["-js"]  # เปิด JetStream เผื่อ persist เล็กน้อย
    ports: ["4222:4222"]
    healthcheck:
      test: ["CMD", "nats", "server", "check", "localhost:4222"]
      interval: 3s
      timeout: 2s
      retries: 20
    networks: [heliox_net]

  vault:
    image: hashicorp/vault:1.16
    container_name: heliox-vault
    environment:
      VAULT_DEV_ROOT_TOKEN_ID: dev-root
    ports: ["8200:8200"]
    command: ["server", "-dev", "-dev-root-token-id=dev-root"]
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:8200/v1/sys/health"]
      interval: 5s
      timeout: 3s
      retries: 30
    networks: [heliox_net]

  orchestrator:
    build:
      context: ..
      dockerfile: deployments/Dockerfile.orchestrator
    container_name: heliox-orchestrator
    environment:
      <<: *common-env
      ENGINE_URL: http://engine:8088
      REDIS_URL: ""                         # เผื่อสลับ checkpointer
      NATS_SUBJECT_PREFIX: heliox.events
      # LLM providers (เลือกอัตโนมัติที่ runtime)
      LLM_PROVIDER_ORDER: "anthropic,openai"  # สลับคิวลอง Anthropic ก่อนค่อย OpenAI
      ANTHROPIC_API_KEY: ${ANTHROPIC_API_KEY}
      OPENAI_API_KEY: ${OPENAI_API_KEY}
    depends_on:
      pg: { condition: service_healthy }
      minio: { condition: service_healthy }
      bus: { condition: service_healthy }
    healthcheck:
      test: ["CMD", "node", "-e", "process.exit(0)"] # แทนด้วย /health เมื่อโค้ดพร้อม
      interval: 5s
      timeout: 2s
      retries: 30
    networks: [heliox_net]
    deploy:
      resources:
        limits: { cpus: '2.0', memory: 1g }

  engine:
    build:
      context: ..
      dockerfile: deployments/Dockerfile.engine
    container_name: heliox-engine
    environment:
      <<: *common-env
      PORT: "8088"
      ENGINE_THREADS: "8"
      ENGINE_CACHE_DIR: /work/cache
    volumes:
      - enginework:/work
    expose: ["8088"]
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:8088/health"]
      interval: 5s
      timeout: 2s
      retries: 30
    networks: [heliox_net]
    deploy:
      resources:
        limits: { cpus: '4.0', memory: 4g }

  hub:
    build:
      context: ..
      dockerfile: deployments/Dockerfile.hub
    container_name: heliox-hub
    environment:
      <<: *common-env
      # credentials ถูกอ้างอิงด้วย vault ref ที่ db, ไม่ใส่กุญแจตรง ๆ
    depends_on:
      bus: { condition: service_healthy }
      pg: { condition: service_healthy }
    expose: ["8090"]
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:8090/health"]
      interval: 5s
      timeout: 2s
      retries: 30
    networks: [heliox_net]

  gateway:
    build:
      context: ..
      dockerfile: deployments/Dockerfile.gateway
    container_name: heliox-gateway
    environment:
      <<: *common-env
      PORT: "8080"
      SSE_HEARTBEAT_SEC: "10"
      NATS_SUBJECT_PREFIX: heliox.events
    ports: ["8080:8080"]
    depends_on:
      orchestrator: { condition: service_started }
      engine: { condition: service_healthy }
      pg: { condition: service_healthy }
      minio: { condition: service_healthy }
      bus: { condition: service_healthy }
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:8080/health"]
      interval: 5s
      timeout: 2s
      retries: 30
    networks: [heliox_net]
    # ตัวอย่าง security flags (ค่อยเติมตอน harden)
    # read_only: true
    # cap_drop: ['ALL']
    # user: "10001:10001"

  frontend:
    build:
      context: ..
      dockerfile: deployments/Dockerfile.frontend
    container_name: heliox-frontend
    environment:
      PUBLIC_API_BASE: http://localhost:8080
      PUBLIC_APP_NAME: Heliox ATLAS v21
    ports: ["5173:5173"]
    depends_on:
      gateway: { condition: service_healthy }
    networks: [heliox_net]

volumes:
  pgdata: {}
  miniodata: {}
  enginework: {}

networks:
  heliox_net:
    driver: bridge
```

**Simple takeaway:** คัดลอกไฟล์นี้ลง `deployments/docker-compose.yml` แล้ว `make dev` ได้ทันที

---

# 2.3 `.env` (คีย์สำคัญ รวม OpenAI+Anthropic)

```env
# Global
APP_ENV=development
LOG_LEVEL=info
JWT_SECRET=change_me
CORS_ALLOWED_ORIGINS=http://localhost:5173

# DB/Object/Bus
DATABASE_URL=postgres://postgres:postgres@pg:5432/app?sslmode=disable
OBJECT_BASE=s3://minio/heliox/
MINIO_ENDPOINT=http://minio:9000
MINIO_ACCESS_KEY=heliox
MINIO_SECRET_KEY=heliox-secret
BUS_URL=nats://bus:4222

# LLM (เลือกสลับใน Orchestrator)
LLM_PROVIDER_ORDER=anthropic,openai
ANTHROPIC_API_KEY=sk-ant-...           # ใส่จริง
OPENAI_API_KEY=sk-openai-...           # ใส่จริง

# Engine
ENGINE_URL=http://engine:8088
ENGINE_THREADS=8
ENABLE_QC=0
SSE_HEARTBEAT_SEC=10
```

**Simple takeaway:** มี 10–12 ตัวแปรหลัก—LLM key ใส่ก่อนรัน

---

# 2.4 Health/Order ของระบบ (startup dependency)

* `pg`, `minio`, `bus`, `vault` → ต้อง healthy ก่อน
* `engine` → รอ `pg` & `minio`
* `orchestrator` → รอ `pg` & `minio` & `bus`
* `gateway` → รอ `engine` + `orchestrator` + `pg` + `minio` + `bus`
* `frontend` → รอ `gateway`

**Simple takeaway:** สตาร์ตตามโซ่: **ฐานข้อมูล/สตอเรจ → engine/orchestrator → gateway → frontend**

---

# 2.5 Limits & Scaling (dev hints)

* **engine**: `cpus: 4`, `memory: 4g`, `ENGINE_THREADS=8` (ปรับตามเครื่อง)
* **orchestrator**: `cpus: 2`, `memory: 1g`
* **gateway**: `cpus: 1`, `memory: 512m`
* **bus/pg/minio**: ค่า default dev พอ

**คิวภายใน**

* Orchestrator จัด **batch size 64–128** strategies ที่ T0/T1
* ใช้ **content-hash cache** ลดซ้ำงาน
* อัตรา emit event สูงสุด: \~**200 events/sec/trace** (UI ไหว, SSE ทัน)

**Simple takeaway:** ค่าเริ่มต้นนี้ให้ **Time-to-HSP ≤ 5 นาที** บนเครื่อง 8–16 คอร์

---

# 2.6 Volumes & Paths

* `pgdata` → Postgres data
* `miniodata` → MinIO buckets
* `enginework` → `/work` ใน Engine (cache/temps)
* บัคเก็ตเริ่มต้น (สร้างด้วย init job):

  * `s3://minio/heliox/hsp/`
  * `s3://minio/heliox/runs/`
  * `s3://minio/heliox/scenarios/`

**Simple takeaway:** แยก persistent volumes ชัด—ลบสแต็กแล้วข้อมูลยังอยู่

---

# 2.7 Security flags (dev → prod-like)

* **gateway/orchestrator/hub**: เปิด `read_only: true`, `cap_drop: ['ALL']`, `user: "10001:10001"` (ภายหลังเมื่อต่อไฟล์/ไลบรารีครบ)
* **secrets**: เก็บ API keys ใน Vault (dev) แล้วอ้าง ref ใน DB (อย่าเก็บ plaintext)
* **network**: ทั้งหมดอยู่ `heliox_net` เดียว; เปิดพอร์ตสาธารณะเฉพาะ `5173`, `8080`, `9000/9001`, `8200`

**Simple takeaway:** แม้ dev ก็ harden เท่าที่ทำได้—ย้ายคลาวด์ได้ทันที

---

# 2.8 Logs & Observability

* ทุก service log แบบ **JSON** (เพิ่มใน Dockerfile/flag ตอน implement)
* Orchestrator/Engine ส่ง **event** เข้า NATS subject:

  * `${NATS_SUBJECT_PREFIX}.${trace_id}` (เช่น `heliox.events.tr_abcd1234`)
* Gateway subscribe ตาม `trace_id` → ส่ง SSE ให้ FE
* OTel (optional): เพิ่ม `OTEL_EXPORTER_OTLP_ENDPOINT=http://otel:4318`

**Simple takeaway:** event เส้นเดียวจาก Orchestrator/Engine → NATS → Gateway/SSE → FE

---

# 2.9 Makefile (dev UX)

```makefile
.PHONY: dev stop clean logs ps be fe gw orc eng hub bus pg minio

dev:         ## boot full stack
	docker compose -f deployments/docker-compose.yml up --build -d

stop:        ## stop stack
	docker compose -f deployments/docker-compose.yml down

clean:       ## remove stack + volumes
	docker compose -f deployments/docker-compose.yml down -v

logs:        ## tail gateway logs
	docker logs -f heliox-gateway

ps:
	docker compose -f deployments/docker-compose.yml ps

gw:
	docker logs -f heliox-gateway
orc:
	docker logs -f heliox-orchestrator
eng:
	docker logs -f heliox-engine
hub:
	docker logs -f heliox-hub
bus:
	docker logs -f heliox-bus
pg:
	docker logs -f heliox-pg
minio:
	docker logs -f heliox-minio
```

**Simple takeaway:** 3 คำสั่งหลัก `make dev | stop | clean` พอสำหรับวงจร dev รายวัน

---

# 2.10 NATS Subjects & SSE bridge

**Subjects**

* Build events: `heliox.events.{trace_id}`
* Deploy events: `heliox.exec.{deploy_id}` (Phase 2)
* System alerts: `heliox.alerts.*` (optional)

**Gateway SSE bridge (Go pseudo-code)**

```go
// GET /v1/runs/{trace_id}/events
func SSEHandler(c *gin.Context) {
  traceID := c.Param("trace_id")
  subj := fmt.Sprintf("%s.%s", os.Getenv("NATS_SUBJECT_PREFIX"), traceID)
  lastSeq := parseLastEventID(c.Request.Header.Get("Last-Event-ID"))

  // subscribe with JetStream durable (resume)
  sub := js.PullSubscribe(subj, durable(traceID))
  // warmup: if lastSeq > 0, fetch and skip until seq > lastSeq

  c.Header("Content-Type", "text/event-stream")
  c.Header("Cache-Control", "no-cache")
  c.Header("Connection", "keep-alive")

  ticker := time.NewTicker( time.Second * heartbeat() )
  for {
    select {
      case <-ticker.C:
        writeSSE(c.Writer, "status", `{"heartbeat":true}`)
      default:
        msgs, _ := sub.Fetch(16, nats.MaxWait(time.Second))
        for _, m := range msgs {
          ev := m.Data // already JSON with {type,seq,phase,...}
          writeSSE(c.Writer, "message", string(ev))
          m.Ack()
        }
        c.Writer.Flush()
    }
  }
}
```

**Simple takeaway:** map เดียว: **NATS subject ⇄ SSE** ต่อผู้ใช้—รองรับ resume ด้วย `Last-Event-ID`

---

# 2.11 รายละเอียดแต่ละคอนเทนเนอร์ (สิ่งที่ Claude Code ต้องทำ)

## 2.11.1 Gateway (Go/Gin)

* Endpoints (Phase 1):
  `POST /v1/runs`, `GET /v1/runs/:id`, `GET /v1/runs/:id/events`,
  `POST /v1/portfolio/assets`, `GET /v1/portfolio/assets`
* Middlewares: CORS allowlist, RateLimit, RBAC/JWT, ErrorSanitizer(traceId), RequestID
* NATS client + SSE bridge ตามข้อ 2.10
* Registry service: เขียน `portfolio_assets` + two-phase commit (DB→MinIO)
* Health: `GET /health` → `{status:"ok"}`

**Simple takeaway:** Gateway คือประตูเดียวของ REST/SSE และเขียน registry ให้อยู่ครบ

## 2.11.2 Orchestrator (Node + LangGraph)

* ไฟล์:
  `src/graph.ts` (เพิ่ม nodes: architect, synth, t0, t1, \[t2,t3], pack)
  `src/lib/llm.ts` (เลือก **Anthropic/OpenAI** ตาม `LLM_PROVIDER_ORDER`)
  `src/lib/bus.ts` (publish JSON → NATS subject)
  `src/lib/repo.ts` (insert runs, save artifacts to MinIO)
* Health: `/health` (Node http server ง่ายๆ คืน 200)

**ตัวอย่าง `llm.ts` (เลือกค่ายอัตโนมัติ)**

```ts
import { z } from "zod";
import OpenAI from "openai";
import Anthropic from "@anthropic-ai/sdk";

const order = (process.env.LLM_PROVIDER_ORDER || "anthropic,openai").split(",");
const clients = {
  openai: new OpenAI({ apiKey: process.env.OPENAI_API_KEY }),
  anthropic: new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY })
};

export async function llmJSON<T>(prompt:string, schema:z.ZodType<T>):Promise<T>{
  let lastErr:any;
  for(const p of order){
    try{
      if(p==="anthropic"){
        const res = await clients.anthropic.messages.create({
          model: "claude-3-5-sonnet-20240620",
          max_tokens: 2000,
          temperature: 0.2,
          messages: [{role:"user", content: prompt}],
          response_format: { type: "json_object" }
        });
        return schema.parse(JSON.parse(res.content[0].text));
      }
      if(p==="openai"){
        const res = await clients.openai.chat.completions.create({
          model: "gpt-4.1-mini",
          temperature: 0.2,
          messages: [{role:"user", content: prompt}],
          response_format: { type: "json_object" }
        } as any);
        return schema.parse(JSON.parse(res.choices[0].message.content!));
      }
    }catch(e){ lastErr = e; continue; }
  }
  throw lastErr;
}
```

**Simple takeaway:** Orchestrator ใช้ 2 LLM ได้ทันที—สลับ/เฟลโอเวอร์อัตโนมัติ

## 2.11.3 Engine (Rust, HTTP)

* Endpoints: `/health`, `/t0`, `/t1`, `/pack` (Phase 1); `/qc/t2`, `/qc/t3` (Phase 2)
* ENV: `ENGINE_THREADS`, `ENGINE_CACHE_DIR`
* ใช้ rayon/Simd + content-hash cache (dir `/work/cache`)
* เขียนไฟล์ artifacts ไป MinIO และคืน URI

**Simple takeaway:** Engine เป็น “มอเตอร์ซิม” ที่เร็วมาก—HTTP ง่ายๆ ให้ Orchestrator เรียก

## 2.11.4 Broker Hub (Go/Rust/Node ได้หมด)

* Endpoints: `/health`, `/deploy/paper`, `/deploy/live`, `/deploy/:id/events`
* Adapters: `papersim`, `oanda`, `binance` (testnet)
* ใช้ subject `heliox.exec.{deploy_id}` ยิง execution events → Gateway SSE

**Simple takeaway:** Hub ยิงคำสั่งและสตรีม fill ให้ผู้ใช้—ไม่ผูกกับตลาดใดตลาดหนึ่ง

## 2.11.5 Infra: pg/minio/bus/vault

* `ops/db/init` ใส่ `0001_init.sql` (ตาราง `runs`, `portfolio_assets`, `scenario_sets` … พร้อม RLS)
* MinIO: สคริปต์ init สร้างบัคเก็ต
* Vault: dev token `dev-root`; บันทึก creds โบรกเกอร์แบบ `kv/heliox/{account_id}`

**Simple takeaway:** Infra มีสคริปต์เริ่มให้พร้อม—ขึ้นมาก็ใช้ได้เลย

---

# 2.12 ลำดับสตาร์ต (Expected timeline)

1. `pg/minio/bus/vault` healthy ≤ 10–20s
2. `engine` health ok ≤ 5–8s (คอมไพล์เสร็จแล้ว)
3. `orchestrator` health ok ≤ 2–3s
4. `gateway` health ok ≤ 2s (เชื่อม NATS สำเร็จ)
5. `frontend` ready ≤ 3s

**Simple takeaway:** ทั้งสแต็กพร้อมใช้งานปกติใน \~30–40 วินาที

---

# 2.13 Smoke tests (เช็กทุกอย่างก่อนใช้งานจริง)

```bash
# 1) ตรวจ health
curl -s http://localhost:8080/health
docker logs heliox-orchestrator | tail -n 50
docker logs heliox-engine | tail -n 50

# 2) ลองเริ่ม run
curl -s -X POST http://localhost:8080/v1/runs \
  -H 'Content-Type: application/json' \
  -d '{"prompt":"xauusd scalping","risk_tier":"bal"}'
# => { "trace_id": "tr_..." }

# 3) เปิด SSE (อีกเทอร์มินัล)
curl -N http://localhost:8080/v1/runs/tr_.../events

# 4) รอ final แล้ว save portfolio
curl -s -X POST http://localhost:8080/v1/portfolio/assets \
  -H 'Content-Type: application/json' \
  -d '{"name":"XAU Scalper #1","hsp_uri":"s3://minio/heliox/hsp/..."}'
```

**Simple takeaway:** 4 คำสั่งนี้ยืนยันได้ว่า REST, SSE, MinIO, DB เชื่อมกันครบ

---

# 2.14 ความเสี่ยง & การ์ด (เฉพาะหัวข้อนี้)

* **NATS dropped/ordering**: ใช้ JetStream pull + durable per `trace_id` และ `seq` บังคับลำดับ
* **SSE ค้าง/หลุด**: heartbeat ทุก `SSE_HEARTBEAT_SEC`; client auto-reconnect + ส่ง `Last-Event-ID`
* **LLM quota**: Orchestrator มี budget pre-check ต่อ node; ลำดับ LLM fallback `anthropic → openai`
* **MinIO eventual**: two-phase commit (เขียนไฟล์เสร็จ → set `artifact_ready:true` → emit `final`)
* **Engine CPU spike**: `ENGINE_THREADS` จำกัด; batch & early-stop; content-hash cache

**Simple takeaway:** รูรั่วหลักถูกอุดไว้ด้วย durable stream, heartbeat, fallback, two-phase commit และ budget guard

---

## ปิดท้าย (สำหรับ Claude Code)

* ใช้ไฟล์ **`deployments/docker-compose.yml`** และ **`.env`** จากข้างบน “ตามตัวอักษร”
* เติม Dockerfiles ที่ผมกำหนดชื่อไว้:

  * `deployments/Dockerfile.gateway` (Go)
  * `deployments/Dockerfile.orchestrator` (Node 20-alpine)
  * `deployments/Dockerfile.engine` (Rust)
  * `deployments/Dockerfile.hub` (Go/Node/Rust เลือกหนึ่ง)
* วางสคริปต์ init ของ **pg/minio** ใน `ops/db/init`
* อิมพลีเมนต์ **SSE bridge** กับ **NATS** ตาม pseudo-code
* อิมพลีเมนต์ **orchestrator/lib/llm.ts** ให้เลือก **Anthropic/OpenAI** ตามตัวอย่าง

**Simple takeaway:** ข้อ 2 นี้เป็น “พิมพ์เขียวคอนเทนเนอร์” ที่พร้อมลงมือโค้ด—Claude Code แค่ทำตามไฟล์/ชื่อ/อินเทอร์เฟซที่ระบุ ก็ยกสแต็กขึ้นและวิ่งได้ทันที.







ใช้ “ข้อ 2 (Containers & Networks)” ที่ผมให้ก่อนหน้าได้เลย—**ไม่ต้องคัดลอกซ้ำ**. ด้านล่างนี้ผมเสริมให้เป็น **ฉบับ TDD-ready** ที่ Claude Code แค่ลงมือโค้ดตามไฟล์/เทสต์: เติม Dockerfiles ทุกตัว, health endpoints/stubs, init scripts, smoke tests, และ CI ที่รันขึ้นสแต็กแบบอัตโนมัติ

---

# 2A) What stays the same (ยืนยันของเดิม)

* `deployments/docker-compose.yml` (ฉบับละเอียดพร้อม env, health, limits, NATS/SSE) ใช้ **ฉบับเดิมได้ทันที**
* `.env` ที่รวมคีย์ **Anthropic + OpenAI** — ใช้ชุดเดิม
* Makefile ชุด `dev | stop | clean | logs` — ใช้เดิม

**Simple takeaway:** เอา “ข้อ 2 เดิม” ไปใช้ตรง ๆ ได้เลย—ด้านล่างคือสิ่งที่ “เติมให้ครบวงจร TDD”

---

# 2B) Files to add (ให้ Claude Code ลงมือได้ทันที)

```
deployments/
  Dockerfile.gateway
  Dockerfile.orchestrator
  Dockerfile.engine
  Dockerfile.hub
ops/
  db/init/0003_buckets.sql           # init buckets + helper
  minio/init.sh                      # create buckets on boot
apps/
  gateway/cmd/server/main.go         # /health, /v1/runs stub, SSE proxy stub
  orchestrator/src/server.ts         # /health + NATS ping
  engine/src/main.rs                 # /health, /t0 stub
  hub/cmd/server/main.go             # /health
tests/
  smoke/compose-up.test.ts           # vitest: health of all services
.github/workflows/
  stack-smoke.yml                    # bringup dev stack in CI (light)
stories/
  020-containers-networks.md         # BMAD story ข้อ 2 (DoD/Tests)
```

**Simple takeaway:** เพิ่ม 4 Dockerfile + 4 health stubs + init scripts + smoke test + CI

---

# 2C) Dockerfiles (โค้ดตรง ๆ)

## `deployments/Dockerfile.gateway`

```dockerfile
FROM golang:1.22 AS build
WORKDIR /src
COPY apps/gateway/ ./
RUN go mod download && CGO_ENABLED=0 GOOS=linux go build -o /bin/gateway ./cmd/server

FROM gcr.io/distroless/base-debian12
ENV PORT=8080
EXPOSE 8080
COPY --from=build /bin/gateway /gateway
ENTRYPOINT ["/gateway"]
```

**Simple takeaway:** gateway เป็น Go binary เดียว เบา-ปลอดภัย

## `deployments/Dockerfile.orchestrator`

```dockerfile
FROM node:20-alpine AS deps
WORKDIR /app
COPY apps/orchestrator/package.json apps/orchestrator/package-lock.json ./
RUN npm ci

FROM node:20-alpine
WORKDIR /app
ENV NODE_ENV=production
COPY --from=deps /app/node_modules ./node_modules
COPY apps/orchestrator/ ./
EXPOSE 7070
CMD ["node","src/server.js"]
```

**Simple takeaway:** orchestrator = Node service เล็ก ๆ มี health

## `deployments/Dockerfile.engine`

```dockerfile
FROM rust:1.79 AS build
WORKDIR /src
COPY apps/engine/ ./
RUN cargo build --release
FROM gcr.io/distroless/cc-debian12
ENV PORT=8088
EXPOSE 8088
COPY --from=build /src/target/release/engine /engine
ENTRYPOINT ["/engine"]
```

**Simple takeaway:** engine เป็น Rust binary เร็วมาก

## `deployments/Dockerfile.hub`

```dockerfile
FROM golang:1.22 AS build
WORKDIR /src
COPY apps/hub/ ./
RUN go mod download && CGO_ENABLED=0 GOOS=linux go build -o /bin/hub ./cmd/server
FROM gcr.io/distroless/base-debian12
ENV PORT=8090
EXPOSE 8090
COPY --from=build /bin/hub /hub
ENTRYPOINT ["/hub"]
```

**Simple takeaway:** hub = Go adapter service; ต่อโบรกใน Phase 2

---

# 2D) Health & stub endpoints (ให้เทสต์ผ่านก่อน)

## `apps/gateway/cmd/server/main.go` (สรุป)

* `GET /health` → `{status:"ok"}`
* `POST /v1/runs` → สร้าง `trace_id` (UUID), บันทึก row stub ใน `runs` แล้ว publish event `status: queued` ไป `NATS_SUBJECT_PREFIX.trace_id`
* `GET /v1/runs/:id/events` → **SSE proxy** (ยัง mock ด้วย NATS subscribe อย่างเดียว)

```go
// pseudo (ส่วนสำคัญ)
r.GET("/health", func(c *gin.Context){ c.JSON(200, gin.H{"status":"ok"}) })
r.POST("/v1/runs", startRunHandler)     // คืน trace_id
r.GET("/v1/runs/:id/events", sseHandler) // subscribe NATS → stream
```

**Simple takeaway:** ให้ SSE ไหลผ่านได้ตั้งแต่วันแรก แม้ข้อมูลยัง mock

## `apps/orchestrator/src/server.ts` (สรุป)

* HTTP `GET /health`
* On boot: ping NATS; subscribe subject `heliox.cmd.*` (เผื่ออนาคต); expose function `emit(subject, event)`
* เมื่อ `POST /v1/runs` ถูกเรียกจาก Gateway, orchestrator ยังไม่ทำงานจริง—**ให้ Gateway เป็นผู้ยิง event แรก** แล้ว orchestrator ยัง standby

**Simple takeaway:** ยังไม่เขียนกราฟ—แต่บริการขึ้น/คุยกับ NATS ได้แล้ว

## `apps/engine/src/main.rs`

* `GET /health` 200
* `POST /t0` คืน JSON stub `{ ok: true, batch: n, ms: 12 }`

**Simple takeaway:** Engine วิ่ง-รับโลด ตั้งใจให้ต่อกราฟในข้อ 3–4

## `apps/hub/cmd/server/main.go`

* `GET /health` 200

**Simple takeaway:** Hub ยังว่าง—เฉพาะ health สำหรับ CI

---

# 2E) MinIO & DB init

## `ops/db/init/0003_buckets.sql`

```sql
-- optional marker table (เผื่อ track object roots)
CREATE TABLE IF NOT EXISTS object_roots (
  name TEXT PRIMARY KEY,
  uri TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
INSERT INTO object_roots(name, uri)
  VALUES ('hsp', 's3://minio/heliox/hsp/'), ('runs','s3://minio/heliox/runs/')
ON CONFLICT (name) DO NOTHING;
```

## `ops/minio/init.sh`

```bash
#!/usr/bin/env bash
set -e
MC="mc --config-dir /tmp/mc"
$MC alias set local $MINIO_ENDPOINT $MINIO_ROOT_USER $MINIO_ROOT_PASSWORD
$MC mb -p local/heliox/hsp || true
$MC mb -p local/heliox/runs || true
$MC mb -p local/heliox/scenarios || true
```

> เรียกสคริปต์นี้ครั้งเดียวหลัง compose ขึ้น (หรือแปะเป็น job เล็ก ๆ)

**Simple takeaway:** บัคเก็ตหลักถูกสร้าง—HSP/Artifacts ไปลงได้ทันที

---

# 2F) Smoke tests (Vitest) — `tests/smoke/compose-up.test.ts`

```ts
import { describe, it, expect } from "vitest";
import fetch from "node-fetch";

const base = "http://localhost:8080";

describe("Stack smoke", () => {
  it("gateway /health ok", async () => {
    const r = await fetch(`${base}/health`);
    expect(r.status).toBe(200);
    const j = await r.json();
    expect(j.status).toBe("ok");
  });

  it("start run + sse connectable", async () => {
    const r = await fetch(`${base}/v1/runs`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ prompt: "xauusd scalping" })
    });
    expect(r.status).toBe(200);
    const { trace_id } = await r.json();
    expect(typeof trace_id).toBe("string");
    // เราไม่อ่าน SSE จริงใน test นี้ แค่เช็ค endpoint เปิด
    const sse = await fetch(`${base}/v1/runs/${trace_id}/events`, {headers:{Accept:"text/event-stream"}});
    expect(sse.status).toBe(200);
  });
});
```

**Simple takeaway:** แค่กด `POST /v1/runs` แล้วเชื่อม SSE ได้—พิสูจน์วงจร REST→NATS→SSE

---

# 2G) CI สำหรับ Stack (เบา ๆ) — `.github/workflows/stack-smoke.yml`

```yaml
name: stack-smoke
on: [push, pull_request]

jobs:
  smoke:
    runs-on: ubuntu-latest
    services:
      pg:
        image: postgres:16
        env: { POSTGRES_PASSWORD: postgres }
        ports: ['5432:5432']
        options: >-
          --health-cmd="pg_isready -U postgres"
          --health-interval=3s --health-timeout=2s --health-retries=20
      nats:
        image: nats:2.10
        ports: ['4222:4222']
      minio:
        image: minio/minio:RELEASE.2025-01-10T00-00-00Z
        env:
          MINIO_ROOT_USER: heliox
          MINIO_ROOT_PASSWORD: heliox-secret
        ports: ['9000:9000']
        options: >-
          --health-cmd="curl -f http://localhost:9000/minio/health/live || exit 1"
          --health-interval=5s --health-timeout=3s --health-retries=30
        command: server /data --console-address ":9001"
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with: { node-version: '20' }

      - name: Build & run gateway (dev)
        run: |
          cd apps/gateway && go build ./cmd/server
          nohup ./server > /tmp/gw.log 2>&1 &

      - name: Run smoke tests
        run: |
          cd tests/smoke
          npm ci || npm i
          npx vitest run --reporter=dot
```

> CI นี้ “ยกบางส่วน” ไม่ได้ใช้ compose เต็มเพราะเวลา build; เป้าคือยืนยัน REST/SSE บน infra จริง (pg/nats/minio)

**Simple takeaway:** PR ใด ๆ จะถูกจิ้ม health + start run + SSE ได้เสมอ

---

# 2H) BMAD Story — `stories/020-containers-networks.md`

* **Background:** ยกสแต็ก dev (pg/minio/nats/vault + gateway/orchestrator/engine/hub/frontend)
* **Input Contract:** `.env`, compose, ports (5173, 8080, 9000/9001, 8200)
* **Plan:** เติม Dockerfiles, health stubs, NATS bridge, init scripts
* **DoD:** `make dev` ขึ้นสแต็ก; `smoke` test ผ่าน; SSE เชื่อมได้; logs สะอาด; services healthy
* **Tests:** vitest smoke + CI `stack-smoke.yml`
* **Rollback:** remove services; revert Dockerfiles

**Simple takeaway:** งานข้อ 2 ถูก “บรรจุ” เป็น story ส่งให้ Claude Code ทำทีละไฟล์

---

# 2I) Risks & Guards (เฉพาะข้อ 2)

* **SSE ค้าง** → gateway ใส่ heartbeat (env `SSE_HEARTBEAT_SEC`)
* **NATS ordering** → ใช้ JetStream durable (ต่อในข้อ 3) หรือ buffer sort โดย `seq` ก่อน flush
* **MinIO init ไม่ทัน** → health + รัน `ops/minio/init.sh` หลัง healthy
* **LLM keys หาย** → orchestrator ไม่เรียก LLM ในข้อ 2 (เฉพาะ infra) แต่เช็ก env แล้ว warning

**Simple takeaway:** จุดพังหลักถูกกันไว้ด้วย health/heartbeat/init scripts

---

# 2J) How to run (Dev loop)

```bash
# เตรียม .env (ตามข้อ 2 เดิม)
cp .env.example .env
# (ใส่ OPENAI_API_KEY/ANTHROPIC_API_KEY ถ้าต้องการ แต่ในข้อ 2 ยังไม่เรียกจริง)

# ยกสแต็ก
make dev

# สร้างบัคเก็ต MinIO ครั้งแรก
bash ops/minio/init.sh

# smoke test (อีกเทอร์มินัล)
cd tests/smoke && npm i && npx vitest run
```

**Simple takeaway:** 3 คำสั่ง → สแต็กขึ้น + smoke ผ่าน + พร้อมเข้าข้อ 3

---

## ตอบคำถามคุณสั้น ๆ

* **ต้องคัดลอกข้อ 2 เดิมไหม?** ไม่ต้อง ใช้ “ข้อ 2 เดิม” เป็นแกน แล้ว **เติมไฟล์** ตาม 2B–2J นี้
* **Claude Code จะทำอย่างไร?** ให้มัน implement ตามไฟล์/เส้นทางที่ระบุ + รัน smoke/CI จนผ่าน
* **ต่อไปข้อไหน?** เมื่อข้อ 2 ผ่าน เราไป **ข้อ 3 (API Gateway endpoints จริง + SSE bridge JetStream durable + tests เพิ่ม)**

**Simple takeaway:** ใช้ข้อ 2 เดิม “ทั้งดุ้น” แล้วเติมชุด TDD/CI/health/ไฟล์ที่ระบุ—จากนี้ Claude Code จะโค้ดได้ทีละก้าวโดยไม่เดา และคุณได้สแต็ก dev ที่ขึ้นจริงในเครื่องทันที.









จัดเต็มแบบ “เขียนให้ Claude Code โค้ดได้ทันที” สำหรับ **ข้อ 3: API Gateway + SSE Bridge (Go/Gin) — TDD-first**
ทุกส่วนผูกกับสิ่งที่ทำไปแล้วในข้อ 1–2 และวางเทสต์/สัญญา/โค้ดสเกลตันครบ เพื่อให้บอท implement ได้ทีละไฟล์โดยไม่เดา

---

# 3.1 เป้า & ขอบเขต

**Outcome ข้อ 3 (ของที่ต้องได้เมื่อจบ):**

* Gateway (Go/Gin) พร้อม **REST** + **SSE** ครบวงจร:
  `POST /v1/runs` • `GET /v1/runs/{id}` • `GET /v1/runs/{id}/events` • `POST /v1/portfolio/assets`
* **JetStream durable SSE-bridge**: ใช้ `Last-Event-ID` resume stream ตาม `seq`
* **Idempotency-Key** (ต่อ client) ป้องกันการกดซ้ำสร้าง run ซ้ำ
* **RLS context**: เซ็ต `app.tenant_id/app.user_id` ก่อนอ่าน/เขียน DB ทุกครั้ง
* **Security**: CORS allowlist, RateLimit, JWT/RBAC, ErrorSanitizer(traceId), RequestID
* **TDD**: unit/integration tests ครอบคลุม REST+SSE+DB+NATS
* **CI**: ยก stack บางส่วน (pg/nats/minio) → รันเทสต์ gateway ให้อัตโนมัติ

**Simple takeaway:** จบข้อ 3 คุณ “เริ่มรันงานจริง” ได้แล้ว: ส่งพรอมป์ → รับ `trace_id` → เปิด SSE → เห็น event ไหล

---

# 3.2 โครงไฟล์/ที่ต้องเพิ่ม (เฉพาะข้อ 3)

```
apps/gateway/
  cmd/server/main.go
  internal/app/config/config.go
  internal/http/router.go
  internal/http/middleware/{cors.go,error.go,ratelimit.go,auth.go,requestid.go,dbctx.go}
  internal/http/handlers/{health.go,runs.go,portfolio.go,sse.go}
  internal/bus/nats.go
  internal/db/{db.go,runs.go,portfolio.go}
  internal/security/jwt.go
  internal/obs/metrics.go

  go.mod / go.sum
  Makefile (เฉพาะ service)

ops/db/init/
  0004_runs_idem_status.sql   # idem_key + status columns + index

tests/gateway/
  rest_health_test.go
  rest_runs_test.go
  sse_events_test.go
  rls_context_test.go

.github/workflows/
  gateway-tests.yml

stories/
  030-gateway-sse.md
```

**Simple takeaway:** ทุกไฟล์มีหน้าที่ชัด—Claude Code เติมตามนี้ได้ตรงเป้า

---

# 3.3 REST API (OpenAPI อิงสัญญาข้อ 1)

### 3.3.1 Endpoints & Semantics

* `POST /v1/runs`

  * Headers: `Idempotency-Key: <uuid>` (แนะนำ)
  * Body: `Requirement` (จาก `packages/contracts`)
  * **ทำงาน**: เซ็ต RLS ctx → insert row `runs(status='QUEUED', phase='PHASE0', idem_key?)` → publish command `heliox.cmd.start` → คืน `{ trace_id }`
* `GET /v1/runs/{trace_id}`

  * คืน: `{ status, phase, created_at, cost_used }` (อ่านจาก DB)
* `GET /v1/runs/{trace_id}/events` (SSE)

  * Header รองรับ: `Last-Event-ID: <seq>` → resume จาก JetStream durable
  * stream JSON: `HelioxEvent` (ตาม contracts)
* `POST /v1/portfolio/assets`

  * Body: `{ name, hsp_uri }` → two-phase commit (validate URI ใน MinIO → insert DB)

**Simple takeaway:** สัญญาเรียบ—เริ่ม run, เช็กสถานะ, ฟัง event, เซฟ HSP

---

# 3.4 DB changes (+RLS): `0004_runs_idem_status.sql`

```sql
ALTER TABLE runs ADD COLUMN IF NOT EXISTS idem_key TEXT;
CREATE UNIQUE INDEX IF NOT EXISTS runs_user_idem_unique
  ON runs(user_id, idem_key) WHERE idem_key IS NOT NULL;

ALTER TABLE runs ADD COLUMN IF NOT EXISTS started_at TIMESTAMPTZ;
ALTER TABLE runs ADD COLUMN IF NOT EXISTS finished_at TIMESTAMPTZ;

-- สถานะหลัก (แนะนำให้ normalize ภายหลัง)
-- QUEUED -> RUNNING -> PACKING -> COMPLETED/FAILED/SUSPENDED
```

**Simple takeaway:** ป้องกัน “กดซ้ำ” และเก็บเวลาชีวิตงานครบ

---

# 3.5 NATS/JetStream subjects

* **Commands** (Gateway → Orchestrator):

  * `heliox.cmd.start`  (payload: `{ trace_id, requirement, tenant_id, user_id }`)
* **Events** (Orchestrator/Engine → Gateway SSE):

  * Stream: **`HELIOX_EVENTS`**
  * Subjects: `heliox.events.*` (เช่น `heliox.events.tr_abcd1234`)

**Durable per trace\_id (SSE):**

* Consumer name: `sse_{trace_id}`
* Start at seq: (1) 0 หาก first connect, (2) `Last-Event-ID + 1` หาก resume

**Simple takeaway:** คำสั่งเข้า “cmd.*”, สตรีมออก “events.*”; มี durable ต่อ run

---

# 3.6 Middleware chain (ความปลอดภัย/สังเกตการณ์)

ลำดับที่ Gateway ใช้กับทุก REST (ยกเว้น `/health`)

1. `RequestID` — gen `X-Request-Id`
2. `ErrorSanitizer` — ครอบ panic/err → `{error, traceId}`
3. `CORSPolicy` — allowlist จาก env
4. `RateLimit` — token bucket
5. `Authz` — JWT → claim `{tenant_id,user_id,role}`
6. `DBCtx` — `set_config('app.tenant_id','app.user_id')`
7. Handler

**Simple takeaway:** ทุกคำขอ “ปลอดภัยและติดตามได้” ตั้งแต่เข้าประตู

---

# 3.7 Request lifecycle (ของจริง)

```
Client POST /v1/runs (Idempotency-Key?)
  └─ Gateway:
      - Parse/validate Requirement (Zod ฝั่ง TS ทำแล้ว; ฝั่ง Go เช็คขั้นต่ำ)
      - Set RLS ctx
      - INSERT runs (trace_id = uuidv7(), status='QUEUED', phase='PHASE0', idem_key)
      - Publish heliox.cmd.start {trace_id, requirement, tenant_id, user_id}
      - Emit seed event? (optional) → หรือให้ orchestrator ส่งเอง
      - Return {trace_id}

Client GET /v1/runs/{id}/events (SSE)
  └─ Gateway:
      - Create/lookup JetStream durable 'sse_{trace_id}'
      - If Last-Event-ID exists → fetch from that seq+1
      - Stream JSON events; heartbeats ทุก N วินาที
      - On network drop → client reconnect + resume
```

**Simple takeaway:** ชีวิตหนึ่ง run = row เดียว + subject เดียว + durable เดียว

---

# 3.8 โค้ดสเกลตัน (Go) — จุดสำคัญ

### 3.8.1 NATS/JetStream client — `internal/bus/nats.go`

```go
package bus

import (
  "context"
  "fmt"
  "os"
  "time"
  "github.com/nats-io/nats.go"
)

type Bus struct{
  nc *nats.Conn
  js nats.JetStreamContext
  subjPrefix string
}

func New() (*Bus, error) {
  url := os.Getenv("BUS_URL")
  nc, err := nats.Connect(url, nats.Name("heliox-gateway")); if err != nil { return nil, err }
  js, err := nc.JetStream()
  if err != nil { return nil, err }
  // ensure stream exists
  _, err = js.AddStream(&nats.StreamConfig{
    Name: "HELIOX_EVENTS",
    Subjects: []string{"heliox.events.*"},
    Storage: nats.MemoryStorage,  // dev; ภายหลัง FileStorage
    MaxMsgsPerSubject: 100000,
  })
  if err != nil && err != nats.ErrStreamNameAlreadyInUse { return nil, err }
  return &Bus{nc:nc,js:js,subjPrefix: os.Getenv("NATS_SUBJECT_PREFIX")}, nil
}

func (b *Bus) PublishCommandStart(payload []byte) error {
  subj := "heliox.cmd.start"
  _, err := b.nc.Publish(subj, payload)
  return err
}

func (b *Bus) SubscribeEventsDurable(ctx context.Context, traceID string, sinceSeq uint64) (nats.JetStream, *nats.Subscription, error) {
  subj := fmt.Sprintf("%s.%s", b.subjPrefix, traceID)
  durable := fmt.Sprintf("sse_%s", traceID)
  // create durable consumer
  cfg := &nats.ConsumerConfig{
    Durable: durable,
    AckPolicy: nats.AckExplicitPolicy,
    FilterSubject: subj,
    DeliverPolicy: func() nats.DeliverPolicy {
      if sinceSeq > 0 { return nats.DeliverByStartSequencePolicy }
      return nats.DeliverAllPolicy
    }(),
    OptStartSeq: sinceSeq + 1,
  }
  _, err := b.js.AddConsumer("HELIOX_EVENTS", cfg)
  if err != nil && err != nats.ErrConsumerNameAlreadyInUse { return nil, nil, err }

  sub, err := b.js.PullSubscribe(subj, durable, nats.BindStream("HELIOX_EVENTS"))
  return b.js, sub, err
}
```

**Simple takeaway:** สร้าง stream/consumer ให้ SSE ใช้ต่อเนื่องและ resume ได้

### 3.8.2 SSE handler — `internal/http/handlers/sse.go`

```go
func SSE(c *gin.Context) {
  traceID := c.Param("id")
  lastEvent := parseLastEventID(c.GetHeader("Last-Event-ID")) // uint64
  js, sub, err := bus.SubscribeEventsDurable(c.Request.Context(), traceID, lastEvent)
  if err != nil { c.Status(500); return }

  w := c.Writer
  c.Header("Content-Type","text/event-stream")
  c.Header("Cache-Control","no-cache")
  c.Header("Connection","keep-alive")

  hb := time.NewTicker(time.Duration(atoiEnv("SSE_HEARTBEAT_SEC",10))*time.Second)
  defer hb.Stop()

  flush := func(){ if f, ok := w.(http.Flusher); ok { f.Flush() } }

  for {
    select {
    case <-c.Request.Context().Done():
      return
    case <-hb.C:
      fmt.Fprintf(w, "event: status\ndata: {\"heartbeat\":true}\n\n")
      flush()
    default:
      msgs, _ := sub.Fetch(16, nats.MaxWait(500*time.Millisecond))
      for _, m := range msgs {
        // assume payload already JSON {type,seq,phase,...}
        var seq uint64 = m.Meta().Sequence.Consumer
        w.Header().Set("Last-Event-ID", fmt.Sprint(seq))
        fmt.Fprintf(w, "id: %d\nevent: message\ndata: %s\n\n", seq, string(m.Data))
        m.Ack()
      }
      flush()
    }
  }
}
```

**Simple takeaway:** รองรับ `Last-Event-ID`, heartbeat, batch fetch, flush

### 3.8.3 Start run — `internal/http/handlers/runs.go`

```go
func StartRun(c *gin.Context) {
  var req contracts.Requirement // หรือ struct ขั้นต่ำ
  if err := c.BindJSON(&req); err != nil { c.JSON(400, gin.H{"error":"invalid_payload"}); return }

  tenant := c.GetString("tenant_id"); user := c.GetString("user_id")
  idem := c.GetHeader("Idempotency-Key")
  trace := uuidv7()

  if idem != "" {
    if existing := db.FindRunByIdem(c, user, idem); existing != nil {
      c.JSON(200, gin.H{"trace_id": existing.TraceID})
      return
    }
  }

  if err := db.InsertRun(c, trace, tenant, user, idem); err != nil { c.Status(500); return }

  payload, _ := json.Marshal(map[string]any{
    "trace_id": trace, "requirement": req, "tenant_id": tenant, "user_id": user,
  })
  _ = bus.PublishCommandStart(payload)

  c.JSON(200, gin.H{"trace_id": trace})
}
```

**Simple takeaway:** สร้าง run แบบ idempotent แล้วส่ง “คำสั่งเริ่ม” ไป orchestrator

---

# 3.9 Tests (Go) — ไฟล์หลัก

## 3.9.1 `rest_health_test.go`

* Spin up router in-memory → GET `/health` → 200 `{status:"ok"}`

## 3.9.2 `rest_runs_test.go`

* Mock DB (หรือใช้ pg ทดสอบ) + mock NATS (ใช้ container หรือ embedded server)
* POST `/v1/runs` → 200 + `trace_id`
* POST ซ้ำพร้อม `Idempotency-Key เดิม` → ได้ `trace_id` เดิม
* GET `/v1/runs/{id}` → คืน status/phase ตรง row

## 3.9.3 `sse_events_test.go`

* Arrange: publish 3 events ไป `heliox.events.tr_X` (seq 1..3)
* Connect SSE (ไม่มี `Last-Event-ID`) → เห็นเริ่มที่ 1
* Disconnect แล้วต่อใหม่พร้อม `Last-Event-ID: 2` → เห็นต่อจาก 3
* Heartbeat ถูกส่งทุก ≤ 12s (ยอมรับ tolerance)

## 3.9.4 `rls_context_test.go`

* เซ็ต header JWT → claims `{tenant_id, user_id}`
* ตรวจว่ามีการเรียก `set_config('app.tenant_id','app.user_id')` ก่อน insert/select

**Simple takeaway:** เทสต์ครอบทุกเส้นสำคัญ—เริ่ม run, idempotent, SSE resume, RLS

---

# 3.10 CI — `.github/workflows/gateway-tests.yml`

```yaml
name: gateway-tests
on: [push, pull_request]
jobs:
  gw:
    runs-on: ubuntu-latest
    services:
      pg:
        image: postgres:16
        env: { POSTGRES_PASSWORD: postgres }
        ports: ['5432:5432']
        options: >-
          --health-cmd="pg_isready -U postgres"
          --health-interval=3s --health-timeout=2s --health-retries=20
      nats:
        image: nats:2.10
        ports: ['4222:4222']
        options: >-
          --health-cmd="nats server check 127.0.0.1:4222 || exit 1"
          --health-interval=3s --health-timeout=2s --health-retries=20
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with: { go-version: '1.22' }
      - name: Migrate DB
        run: psql postgresql://postgres:postgres@localhost:5432/postgres -f ops/db/init/0002_core.sql -f ops/db/init/0004_runs_idem_status.sql
      - name: Go test
        run: cd apps/gateway && go test ./... -v
```

**Simple takeaway:** ทุก PR ยิงเทสต์ gateway บน pg+nats จริง ๆ

---

# 3.11 Observability (Metrics/Logs)

* Middleware เติม `X-Trace-Id` และ log JSON `{ts,level,trace_id,route,latency_ms,code}`
* Metrics (Prometheus-ready):

  * `http_requests_total{route,code}`
  * `sse_clients{trace_id}` gauge
  * `sse_sent_events_total{type}` counter
  * `nats_lag_events{trace_id}` gauge (seq ล่าสุด − consumer seq)

**Simple takeaway:** มองเห็นปริมาณ, latency, และช่องแคบ (lag) ได้ทันที

---

# 3.12 ข้อผิดพลาด & รหัสมาตรฐาน

* `invalid_payload` (400) — body ผิดสคีมา
* `unauthorized` (401) / `forbidden` (403) — JWT/RBAC
* `rls_context_missing` (500) — ไม่พบ `tenant/user`
* `bus_down` (503) — NATS ใช้งานไม่ได้
* `sse_unavailable` (503) — stream/consumer ยังไม่พร้อม
* ทุก error คืน `{error, traceId}`; **ไม่**คืน stack trace

**Simple takeaway:** รหัส error สั้น-ชัด ไล่ปัญหาได้

---

# 3.13 BMAD Story — `stories/030-gateway-sse.md`

* **Background**: ทำเกตเวย์เป็น control-plane ที่ปลอดภัย + SSE bridge durable
* **Plan**: เติมไฟล์ตาม 3.2, เขียนโค้ดสเกลตัน, ทำเทสต์ 3.9
* **DoD**:

  * `go test ./...` ผ่าน 100%
  * SSE resume จาก `Last-Event-ID` ได้
  * Idempotency ป้องกัน duplicate run
  * RLS context ถูกตั้งก่อน DB ops
* **Rollback**: ปิด SSE, ใช้ long-poll ชั่วคราว (ไม่คาดว่าใช้)

**Simple takeaway:** นิยาม Done ชัด—Claude Code ทำตามได้ตรง ๆ

---

# 3.14 การใช้งานจริง (Dev loop)

```bash
# 1) ยก infra (ถ้ายัง)
make dev  # จากข้อ 2

# 2) รันเฉพาะ gateway tests
cd apps/gateway && go test ./... -v

# 3) ลองด้วยมือ
curl -s -X POST http://localhost:8080/v1/runs -H 'Content-Type: application/json' \
  -H 'Idempotency-Key: 11111111-1111-1111-1111-111111111111' \
  -d '{"prompt":"xauusd scalping","risk_tier":"bal"}'

# 4) เปิด SSE (ดู event)
curl -N http://localhost:8080/v1/runs/<trace_id>/events
```

**Simple takeaway:** 4 ขั้นตอน—เซสชันทำงานจริงแล้ว

---

# 3.15 ทางเลือก/จุดปรับแต่ง

* **Command path**: ตอนนี้ Gateway ส่ง `heliox.cmd.start` บน NATS; จะเปลี่ยนเป็นเรียก HTTP orchestrator `/start` ก็ได้ (แต่อย่าลืม retry/backoff)
* **Stream storage**: dev ใช้ MemoryStorage; ถ้าต้องการ resume ข้ามการรีสตาร์ต ใช้ FileStorage
* **SSE fan-out**: หลาย client ต่อ run ได้ โดยใช้ durable เดียว + manual replay (คุมง่ายสุดคือเปิด durable ต่อ client)

**Simple takeaway:** เปลี่ยนท่อส่งคำสั่ง/สตอเรจได้โดยไม่กระทบสัญญา REST/SSE

---

## ปิดข้อ 3

คุณได้ **Gateway + SSE durable** ที่ปลอดภัย ครบเทสต์ และต่อกับ orchestrator ได้ทันทีตามสัญญาข้อ 1–2. เมื่อ PR ของข้อ 3 ผ่าน เราค่อยไป **ข้อ 4: Orchestrator (LangGraph) — architect → synth → T0/T1 → pack + event emission** ซึ่งจะทำให้ SSE แสดงผลจริงแบบเรียลไทม์

**Simple takeaway:** ข้อ 3 คือหัวใจ control-plane—คลิกเริ่มงานได้, เห็นทุกอีเวนต์, ปลอดภัย, และทดสอบได้อัตโนมัติ.






จัดเต็มแบบ “ให้ Claude Code โค้ดได้เลย” สำหรับ **ข้อ 4: Orchestrator (LangGraph) — Architect → Synth → T0/T1 → Pack + Event Emission**
ทุกอย่างยึดตามข้อ 1–3 ที่เราทำไว้แล้ว (Contracts, Containers, Gateway+SSE) และใช้ทั้ง **Anthropic + OpenAI** ผ่าน abstraction เดียว

ด้านล่างคือสเปกที่ **พร้อมลงมือ**: โครงไฟล์, สเตตแมชชีน, โค้ดสเกลตัน,พรอมป์เทมเพลต, งบประมาณโทเค็น/รีไทร, บัดเจ็ตการคำนวณ, ทดสอบ (unit/integration), และ CI.

> หลักการ: **แยก “สมอง” ออกจาก “มอเตอร์”** — Orchestrator ใช้ LangGraph ทำแผนและเรียกเครื่องมือ (LLM/Engine/Storage/Bus) โดยมี **idempotency + resume + budget guard + deterministic seeds** ครบ

---

## 4.1 เป้า & ขอบเขต (Outcome)

* บริการ **orchestrator** (Node + LangGraph) ที่:

  1. รับคำสั่ง `heliox.cmd.start` จาก NATS
  2. รันกราฟ **PHASE0 → T0 → T1 → PACK**
  3. ส่งอีเวนต์ตามสัญญา `HelioxEvent` ไปที่ `heliox.events.{trace_id}` (JetStream) แบบ **seq ต่อเนื่อง**
  4. ฟื้นตัวได้ (resume) เมื่อรีสตาร์ต ด้วย **checkpointer + run state ใน Postgres**
  5. คุมงบ LLM/ซิม ด้วย **Budget Guard** และ **content-hash cache**
  6. สร้าง **HSPLitePack** พร้อม `manifest/blueprint/fast_metrics` และอัปขึ้น MinIO

**Simple takeaway:** จบข้อ 4 แล้วกด “เริ่มรัน” จาก Gateway → เห็นอีเวนต์จริง พร้อม HSP พร้อมใช้

---

## 4.2 โครงไฟล์ (apps/orchestrator)

```
apps/orchestrator/
  package.json
  tsconfig.json
  src/
    server.ts                # /health + bus subscribe wiring
    graph.ts                 # สร้าง LangGraph (PHASE0 → T0 → T1 → PACK)
    state.ts                 # HelioxState (แผน + วิ่งจริง)
    nodes/
      architect.ts           # เรียก LLM ให้ได้ Blueprint (Phase 0)
      synth.ts               # LLM สร้าง Candidates (CEGIS-Light)
      t0.ts                  # Engine: /t0 (เร็ว)
      t1.ts                  # Engine: /t1 (เร็วกว่า t2/t3)
      pack.ts                # รวบรวมเป็น HSPLitePack + upload
      budget.ts              # precheck งบ + post record
    lib/
      llm.ts                 # เลือก Anthropic/OpenAI + JSON safe-parse
      engine.ts              # เรียก HTTP Engine (/t0,/t1,/pack)
      bus.ts                 # publish events (JetStream)
      repo.ts                # Postgres: runs, seq counter, artifacts
      cache.ts               # content-hash cache
      hash.ts                # stable hash ของกลยุทธ์/พารามิเตอร์
      seeds.ts               # deterministic seeds/CRN/antithetic
      schema.ts              # import Zod (contracts) + helpers
      budget_guard.ts        # นโยบายงบ/โควต้า
    prompts/
      architect.md           # system+user prompt
      synth.md               # system+user prompt
  tests/
    architect.node.test.ts
    synth.node.test.ts
    graph.integration.test.ts  # mock engine, assert event order
```

**Simple takeaway:** ไฟล์ถูกจัดตาม “โหนดของกราฟ” + ไลบรารีใช้งานร่วม + เทสต์แยกชั้น

---

## 4.3 สเตตรวม (HelioxState) & เงื่อนไขเดินกราฟ

```ts
// src/state.ts
import type { RequirementT, BlueprintT, CandidateT, FastMetricsT } from "packages/contracts/src";
export type Phase = "PHASE0" | "T0" | "T1" | "PACK";

export interface HelioxState {
  trace_id: string;
  tenant_id: string;
  user_id: string;

  phase: Phase;
  requirement?: RequirementT;
  blueprint?: BlueprintT;
  candidates?: CandidateT[];
  t0?: { metrics: Record<string, FastMetricsT>, selected?: string[] };
  t1?: { metrics: Record<string, FastMetricsT>, selected?: string[] };

  hsp?: { manifest_uri: string; preview?: any };

  budget: { llm_tokens: number; sim_ms: number; exceeded?: boolean };
  seq?: number; // app-level event seq (แยกจาก JetStream seq)
}
```

**กติกาเดินกราฟ (ข้อ 4):**

* เริ่มที่ **PHASE0** → ได้ `blueprint` (ถ้า fail ⇒ error event + stop)
* ไป **T0**: ประเมิน candidates เร็ว (batch) ⇒ เลือก Top-K
* ไป **T1**: ซิมละเอียดขึ้นเล็กน้อย ⇒ เลือก Top-M
* ไป **PACK**: สร้าง HSPLitePack และ emit `final`

> หมายเหตุ: **QC T2/T3** จะมาในเฟสถัดไป (Phase 2); ตอนนี้โหนดเหล่านั้นไม่อยู่ในกราฟ

**Simple takeaway:** กราฟสั้น-ชัด—ลดเวลา dev และสะท้อน event ให้ UI ได้เร็ว

---

## 4.4 กราฟ LangGraph (สเกลตัน)

```ts
// src/graph.ts
import { StateGraph } from "@langchain/langgraph"; // หรือเวอร์ชันที่คุณใช้
import type { HelioxState } from "./state";
import { nodeArchitect } from "./nodes/architect";
import { nodeSynth } from "./nodes/synth";
import { nodeT0 } from "./nodes/t0";
import { nodeT1 } from "./nodes/t1";
import { nodePack } from "./nodes/pack";
import { nodeBudgetPre, nodeBudgetPost } from "./nodes/budget";
import { makeCheckpointer } from "./lib/repo"; // Postgres-based checkpointer

export function buildGraph() {
  const g = new StateGraph<HelioxState>()
    .addNode("budget_pre", nodeBudgetPre)
    .addNode("architect", nodeArchitect)
    .addNode("synth", nodeSynth)
    .addNode("t0", nodeT0)
    .addNode("t1", nodeT1)
    .addNode("pack", nodePack)
    .addNode("budget_post", nodeBudgetPost)
    .addEdge("budget_pre","architect")
    .addEdge("architect","synth")
    .addEdge("synth","t0")
    .addEdge("t0","t1")
    .addEdge("t1","pack")
    .addEdge("pack","budget_post")
    .setCheckpointer(makeCheckpointer()); // resume ได้
  return g.compile();
}
```

**Simple takeaway:** โหนดเรียงตามลำดับ—มี pre/post budget guard และ checkpointer

---

## 4.5 พรอมป์เทมเพลต (เท่าที่ต้องใช้ตอนนี้)

`prompts/architect.md`

* **System**: “คุณคือ Strategy Architect… ผลลัพธ์ต้องเป็น JSON ตรงตามสคีมา Blueprint… ห้าม lookahead… ใส่ invariants/cooldown และ evidence”
* **User**: `Requirement` ที่รับมา + หลักเกณฑ์ Phase 0: MDL, No-Path Score, Invariants

ตัวอย่างข้อกำชับ (ส่วนสำคัญ):

* ตอบ **JSON object เดียว**; ห้าม markdown
* `symbols` = จาก requirement (ถ้าไม่ได้ระบุ ให้เดาอย่างระมัดระวัง เช่น “XAUUSD”)
* `timeframe` ∈ {M1,M5,M15,H1}
* `invariants.no_lookahead = true`, `termination = true`, `cooldown_bars_min >= 1`
* หลักฐาน (`evidence`) ต้องอธิบาย failure modes และ envelope (vol, spread\_bps)

`prompts/synth.md`

* สร้าง **N=24–48 candidates** (ขึ้นกับงบ) โดย:

  * เปลี่ยนพารามิเตอร์ **เฉพาะที่อยู่ใน blueprint**
  * ระบุ `rationale` สั้น ๆ
  * หลีกเลี่ยง config ที่ละเมิด `risk.max_drawdown` และ `sizing`
* ตอบเป็น `Candidate[]` **เท่านั้น**

**Simple takeaway:** พรอมป์บังคับรูปแบบ—LLM ตอบ JSON ที่ parse ได้ทันที

---

## 4.6 LLM abstraction (เลือก Anthropic/OpenAI อัตโนมัติ)

> ใช้ของข้อ 2 ต่อ: `lib/llm.ts` และเพิ่ม **งบประมาณ + รีไทร + ไทม์เอาต์**

ข้อบังคับเพิ่ม:

* `timeout_ms` ต่อ call (เช่น 25–40s)
* `max_retries = 2` (สลับค่ายถ้าค่ายแรกล้ม)
* บันทึก **token\_used** ลง `state.budget.llm_tokens`
* validate ด้วย Zod ก่อนคืนผล

**Simple takeaway:** LLM ถูกครอบด้วย guard—ประหยัด, ทนล่ม, ส่งคืนเฉพาะ JSON ที่ถูกสคีมา

---

## 4.7 Engine client (/t0, /t1, /pack)

```ts
// src/lib/engine.ts
export async function runT0(req:{ trace_id:string, blueprint:any, candidates:any[], seeds:number[] }) {
  // POST http://engine:8088/t0
  // return { metrics: { [bp_id_or_candidateId]: FastMetricsT }, preview?: any }
}
export async function runT1(req:{ trace_id:string, selected:string[], seeds:number[] }) { /* ... */ }
export async function runPack(req:{ trace_id:string, blueprint:any, metrics:any }) {
  // return { hsp_uri, preview }
}
```

* ใช้ **deterministic seeds** (CRN + antithetic) จาก `lib/seeds.ts`
* ใช้ **content-hash** ของ `(blueprint + candidate.params)` เพื่อดักซ้ำงาน (cache)
* จำกัด **batch size** (เช่น 32) และ **early-stop** ถ้าเจอ dominance ชัดเจน

**Simple takeaway:** เรียก Engine แบบควบคุม—เร็ว คุ้ม และทำซ้ำได้

---

## 4.8 Event Emission (Bus)

* สร้างตาราง **`run_events_seq(trace_id text primary key, last_seq bigint)`** เพื่อให้ **payload.seq** ต่อเนื่อง
* ฟังก์ชัน `emit(trace_id, type, phase, payload)`:

  1. `seq = repo.bumpSeq(trace_id)` (atomic)
  2. สร้างอ็อบเจ็กต์ `HelioxEvent` (validate Zod)
  3. `bus.publish("heliox.events."+trace_id, JSON.stringify(event))`

> ฝั่ง Gateway ใช้ **JetStream consumer seq** เป็น SSE `Last-Event-ID`, ส่วน `payload.seq` คือ **app-seq** ที่ UI ใช้เช็กลำดับภายใน (ปลอดภัยหากไม่เท่ากัน)

**Simple takeaway:** มี **สองชั้น seq** เพื่อความทนทาน—resume ได้เสมอ

---

## 4.9 โหนด (Nodes) — สเกลตันที่ “โค้ดได้เลย”

### 4.9.1 Architect (Phase 0)

```ts
// src/nodes/architect.ts
import { llmJSON } from "../lib/llm";
import { Blueprint } from "packages/contracts/src";
import { emit } from "../lib/bus";
import { saveBlueprint, ensureRun } from "../lib/repo";

export async function nodeArchitect(s: HelioxState): Promise<HelioxState> {
  await ensureRun(s.trace_id, s.tenant_id, s.user_id, "PHASE0");
  const prompt = makeArchitectPrompt(s.requirement!); // ใช้ prompts/architect.md
  const blueprint = await llmJSON(prompt, Blueprint); // Zod validate
  await saveBlueprint(s.trace_id, blueprint);

  await emit(s.trace_id, "artifact", "PHASE0", { kind:"blueprint", uri:`db://runs/${s.trace_id}/blueprint` });
  await emit(s.trace_id, "status", "PHASE0", { stage:"architect.done", progress:0.33 });

  return { ...s, phase:"PHASE0", blueprint };
}
```

### 4.9.2 Synth (CEGIS-Light)

```ts
// src/nodes/synth.ts
import { llmJSON } from "../lib/llm";
import { Candidate, CandidateT } from "packages/contracts/src";
import { emit } from "../lib/bus";

export async function nodeSynth(s: HelioxState): Promise<HelioxState> {
  const prompt = makeSynthPrompt(s.blueprint!);
  const candidates = await llmJSON<CandidateT[]>(prompt, Candidate.array().min(8).max(64));
  await emit(s.trace_id, "status", "PHASE0", { stage:"synth.done", progress:0.5 });
  return { ...s, candidates };
}
```

### 4.9.3 T0/T1 (Engine)

```ts
// src/nodes/t0.ts
import { runT0 } from "../lib/engine"; import { emit } from "../lib/bus";
import { seedsFor } from "../lib/seeds";
export async function nodeT0(s: HelioxState): Promise<HelioxState> {
  const seeds = seedsFor(s.trace_id, "t0", 64);
  const res = await runT0({ trace_id:s.trace_id, blueprint:s.blueprint, candidates:s.candidates!, seeds });
  await emit(s.trace_id, "metric", "T0", { name:"t0_done", value:Object.keys(res.metrics).length });
  const top = selectTop(res.metrics, 6); // เลือก K
  return { ...s, phase:"T0", t0:{ metrics:res.metrics, selected:top } };
}
```

```ts
// src/nodes/t1.ts
export async function nodeT1(s: HelioxState): Promise<HelioxState> {
  const seeds = seedsFor(s.trace_id, "t1", 64);
  const res = await runT1({ trace_id:s.trace_id, selected:s.t0!.selected!, seeds });
  const top = selectTop(res.metrics, 3); // เลือก M
  await emit(s.trace_id, "status", "T1", { stage:"t1.done", progress:0.9 });
  return { ...s, phase:"T1", t1:{ metrics:res.metrics, selected:top } };
}
```

### 4.9.4 Pack (HSPLitePack)

```ts
// src/nodes/pack.ts
import { runPack } from "../lib/engine"; import { emit } from "../lib/bus";
export async function nodePack(s: HelioxState): Promise<HelioxState> {
  const best = s.t1!.selected![0];
  const metrics = s.t1!.metrics[best];
  const out = await runPack({ trace_id:s.trace_id, blueprint:s.blueprint, metrics });
  await emit(s.trace_id, "artifact", "PACK", { kind:"hsp", uri: out.hsp_uri });
  await emit(s.trace_id, "final", "PACK", { hsp_uri: out.hsp_uri });
  return { ...s, phase:"PACK", hsp:{ manifest_uri: out.hsp_uri, preview: out.preview } };
}
```

### 4.9.5 Budget Guard

* `nodeBudgetPre`: ตรวจ `budget.llm_tokens + sim_ms` ยังไม่เกิน **เพดานต่อ run**
* `nodeBudgetPost`: บันทึกการใช้จริงกลับ DB; ถ้าเกินให้ **emit error** และหยุดกราฟ

**Simple takeaway:** โค้ดโหนดตรงๆ—Claude Code เติมเนื้อในได้ทันทีตามสัญญา

---

## 4.10 Checkpointer/Repo (Postgres)

เพิ่มตาราง (ถ้ายังไม่มี):
`ops/db/init/0005_orchestrator.sql`

```sql
CREATE TABLE IF NOT EXISTS run_state (
  trace_id TEXT PRIMARY KEY,
  state JSONB NOT NULL,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS run_events_seq (
  trace_id TEXT PRIMARY KEY,
  last_seq BIGINT NOT NULL DEFAULT 0
);
```

เมธอดหลักใน `lib/repo.ts`:

* `ensureRun(trace_id, tenant_id, user_id, phase)` — upsert `runs`
* `saveState(trace_id, state)` — สำหรับ checkpointer
* `loadState(trace_id)` — resume
* `bumpSeq(trace_id)` — `UPDATE ... SET last_seq=last_seq+1 RETURNING last_seq`
* `saveBlueprint(...)`, `saveHspManifest(...)` — จัดเก็บ URI/เมทาดาต้า

**Simple takeaway:** มีที่เก็บ state/seq อย่างชัดเจน—รีสตาร์ตก็ไปต่อได้

---

## 4.11 Server & Bus wiring

`src/server.ts`

* `/health` → 200
* on start:

  * เชื่อม **NATS** และ **Postgres**
  * สร้างกราฟ: `const app = buildGraph()`
  * subscribe `heliox.cmd.start` → สำหรับแต่ละข้อความ:

    * สร้าง state เริ่ม (`phase:"PHASE0"`, load requirement)
    * `await app.invoke(state)` (หรือ `streamEvents` ถ้าต้องการ granular)
    * โหนดภายในจะ `emit(...)` เอง

**Simple takeaway:** Orchestrator “รอรับคำสั่ง” แล้วจัดการทั้งกราฟเอง

---

## 4.12 Tests (สำคัญ)

### 4.12.1 Node tests (unit)

* `architect.node.test.ts`

  * mock `llmJSON` คืน Blueprint ตัวอย่าง → assert Zod ผ่าน, emit artifact/status 2 ครั้ง
* `synth.node.test.ts`

  * mock `llmJSON` คืน Candidate\[] → assert min 8, max 64, ไม่มี param นอก spec

### 4.12.2 Graph integration test

* mock `engine.runT0/T1/Pack` คืน metrics/uri คงที่
* mock `bus.emit` จับลำดับเรียก → assert **phase order**: PHASE0 → T0 → T1 → PACK
* assert ว่ามี `final` และ `artifact(kind=hsp)`
* inject error ใน `t0` แล้ว assert ว่ามี **event type=error** และกราฟหยุด

### 4.12.3 Resume test

* run จนถึง T0 → **saveState** → สร้างอินสแตนซ์ใหม่ → `loadState` → ต่อ T1/Pack สำเร็จ

**Simple takeaway:** เทสต์ครอบเรื่อง “ออกของ, ลำดับ, error, resume” ทั้งหมด

---

## 4.13 CI (orchestrator-tests.yml)

* รัน `npm ci` ใน `apps/orchestrator`
* รัน `vitest` สำหรับ unit/integration (mock engine/bus)
* (ทางเลือก) spin **nats** ในบริการเสริม + ทดสอบ publish จริง 1 ข้อ

**Simple takeaway:** ทุก PR มีสัญญาวัด—กราฟต้องเดินครบและส่งอีเวนต์ถูก

---

## 4.14 Budget & Performance Knobs (ปรับได้)

* `ARCHITECT_MAX_TOKENS` (เช่น 2k) • `SYNTH_MAX_TOKENS` (2k)
* `CANDIDATE_COUNT` (8–64) • `T0_BATCH=32` • `T1_BATCH=16`
* `ENGINE_TIMEOUT_MS` (t0/t1: 5000–15000) • `LLM_TIMEOUT_MS` (25000–40000)
* `BUDGET_MAX_TOKENS_PER_RUN` • `BUDGET_MAX_SIM_MS_PER_RUN`
* Fallback order LLM: `anthropic,openai` หรือสลับตามเวลา/โควต้า

**Simple takeaway:** ปรับแค่ไม่กี่ปุ่ม—คุมทั้งความเร็วและค่าใช้จ่าย

---

## 4.15 ข้อผิดพลาดที่คาด & การ์ด

* **LLM ตอบไม่ตรงสคีมา** → รีไทร 1 ครั้งพร้อม *repair prompt*; ถ้ายังตก → emit `error` แล้ว stop
* **Engine ช้า/ล่ม** → timeout + backoff + **early finalize** ด้วยผลที่มี (option)
* **NATS หลุด** → queue local (in-memory) + retry publish; ถ้าล้มยกเลิก run ด้วย `FAILED`
* **Seq สองระบบ** (payload vs consumer) → UI ใช้ **SSE id** สำหรับ resume, ใช้ **payload.seq** ตรวจ order ภายใน

**Simple takeaway:** ทุกหลุมมีบันได—ระบบไม่เงียบตาย แต่บอกผู้ใช้และปิดงานอย่างสุภาพ

---

## 4.16 วิธีรัน & ดีบัก (Dev Loop)

```bash
# 1) ยกสแต็กจากข้อ 2
make dev

# 2) รัน orchestrator tests
cd apps/orchestrator && npm i && npx vitest run

# 3) ลอง end-to-end:
curl -s -X POST http://localhost:8080/v1/runs \
  -H 'Content-Type: application/json' \
  -d '{"prompt":"xauusd scalping","risk_tier":"bal"}'
# => { "trace_id": "tr_..." }

# 4) ดู event
curl -N http://localhost:8080/v1/runs/tr_.../events
```

**Simple takeaway:** ลูป dev สั้น—เทสต์ก่อน แล้วค่อยยิง end-to-end ให้เห็นอีเวนต์จริง

---

### สรุปข้อ 4

* คุณได้ **Orchestrator ที่เป็นกราฟ** ใช้ LangGraph, มี **budget guard, resume, caching, deterministic seeds**
* เดิน **PHASE0 → T0 → T1 → PACK** และส่งอีเวนต์มาตรฐานไป **NATS → Gateway → SSE**
* มี **พรอมป์เทมเพลต** + **สเกลตันโหนด** + **เทสต์/CI** ครบ เพื่อให้ Claude Code “ลงมือทำ” โดยไม่ต้องเดา

**Simple takeaway:** ข้อ 4 เปลี่ยนระบบจาก “ท่อว่าง” เป็น “เครื่องจักรคิด-ทดสอบ-แพ็ก” ที่วิ่งจริงได้ทันที—พร้อมต่อยอดไป QC (T2/T3) และ Formal ในเฟสถัดไป.






จัดเต็ม “ข้อ 5: **Engine (Rust) — Fast Sim T0/T1 + HSP Pack**” ให้ Claude Code แค่อิมพลีเมนต์ตามสเปกและเทสต์—ไม่ต้องเดาเอง
โฟกัส: **เร็ว, แม่น, ทำซ้ำได้, คุมงบ, ไม่มองอนาคต**, และ **เข้ากับข้อ 1–4 แบบเสียบปลั๊ก**

---

# 5.1 เป้า & ขอบเขต (Outcome)

**เมื่อจบข้อ 5 คุณจะได้:**

* บริการ **engine** (Rust + Axum) มี 3 endpoint:

  1. `POST /t0` — **FastSim** (latency ต่ำ, model เบา) → ให้ metrics คร่าว ๆ เร็วมาก
  2. `POST /t1` — **RealisticSim-lite** (เพิ่ม microstructure: spread/slippage/latency/partial fill)
  3. `POST /pack` — สร้าง **HSPLitePack (.hspz)**: `manifest.json + blueprint.json + fast_metrics.json` แล้วอัป MinIO
* **IR สัญญาณ** ที่คอมไพล์จาก Blueprint → ตัวรันที่ “ไม่มองอนาคต”
* **Deterministic seeds** (CRN + antithetic) + **content-hash cache** (หลีกเลี่ยงซิมซ้ำ)
* **Metrics** มาตรฐาน (Sharpe, CVaR proxy, Turnover, CI95) + สรุป Top-K/Top-M ตามข้อ 4
* **Unit/Property/Golden tests** + **CI** ที่บิลด์/เทสต์อัตโนมัติ
* Guaranteed **idempotent** และ **reproducible** (เวอร์ชัน/seed/hash ฝังในผลลัพธ์)

**Simple takeaway:** Engine ของคุณ “ยิงแล้วรู้เรื่อง” — เร็ว, คุมงบ, ทำซ้ำได้, คืนผลเป็นสัญญาเดียวกับ orchestrator

---

# 5.2 ภาพรวมสถาปัตยกรรม Engine

```
       Orchestrator (LangGraph)
               │  HTTP
               ▼
      ┌─────────────────────── Engine (Rust, Axum) ────────────────────────┐
      │  Router: /health /t0 /t1 /pack                                      │
      │    ├─ Adapters: serde_json <-> Zod Contracts (Blueprint/Candidate)  │
      │    ├─ Compiler: Blueprint → IR (No-Lookahead, Invariants-checked)   │
      │    ├─ Sim Core:                                                     │
      │    │    • T0: Bars GBM-lite + rules (vectorized, SIMD, rayon)       │
      │    │    • T1: T0 + microstructure (spread, slippage, latency, PF)   │
      │    ├─ Metrics: sharpe / cvar5 / turnover / CI                       │
      │    ├─ Caching: content-hash(key) -> parquet/json in MinIO           │
      │    └─ Pack: build HSPLitePack (.hspz) → MinIO URI                   │
      └──────────────────────────────────────────────────────────────────────┘

Legend: PF = Partial Fill
```

**Simple takeaway:** แยกชั้นชัด—รับ JSON → คอมไพล์ IR → ซิม → เมตริก → แคช/แพ็ก

---

# 5.3 สัญญา API ของ Engine

## 5.3.1 `POST /t0`

**Request**

```json
{
  "trace_id":"tr_abc",
  "blueprint": { ... },          // Zod Blueprint (ข้อ 1)
  "candidates": [{...}],         // Candidate[]
  "seeds": [42, 43, 44, ...],    // CRN (จำนวน 32–64 แนะนำ)
  "bars": { "n": 4096, "dt_sec": 60 }   // ถ้าไม่ส่ง ใช้ดีฟอลต์ timeframe->N
}
```

**Response**

```json
{
  "engine_version": "t0.1.0",
  "key": "hash(blueprint,candidates,bars,engine_version)",
  "metrics": {
    "cand_001": { "sharpe":1.08, "cvar_proxy":-0.11, "turnover":0.7, "ci95":[0.04,0.09] },
    "cand_002": { ... }
  },
  "preview": { "n_cand": 24, "n_paths": 64, "wall_ms": 820 }
}
```

## 5.3.2 `POST /t1`

**Request**

```json
{
  "trace_id":"tr_abc",
  "blueprint": { ... },
  "selected": ["cand_002","cand_005","cand_007"],
  "seeds": [99, 100, 101, ...],
  "micro": { "spread_bps_mu":12, "spread_bps_sigma":4, "latency_ms":80, "slip_model":"mixture" }
}
```

**Response**

```json
{
  "engine_version": "t1.1.0",
  "metrics": { "cand_005": { ... }, "cand_007": { ... } },
  "preview": { "fills": { "avg_fill_ratio": 0.93 }, "wall_ms": 1670 }
}
```

## 5.3.3 `POST /pack`

**Request**

```json
{
  "trace_id":"tr_abc",
  "blueprint": { ... },
  "best_id": "cand_007",
  "metrics": { "sharpe":1.21,"cvar_proxy":-0.09,"turnover":0.61,"ci95":[0.03,0.1] }
}
```

**Response**

```json
{ "hsp_uri": "s3://minio/heliox/hsp/tr_abc/hsp_v1.hspz", "preview": { "files": 3 } }
```

**Simple takeaway:** 3 endpoint พอครบวงจร: เร็ว (T0) → เหมือนจริงขึ้น (T1) → แพ็กใช้งาน (Pack)

---

# 5.4 Data Types (Rust) ให้แมปกับ Zod เดิม

```rust
// apps/engine/src/types.rs
use serde::{Deserialize, Serialize};

#[derive(Deserialize, Serialize)]
pub struct Requirement { pub prompt:String, pub risk_tier:String, pub scenario_set_id:Option<String> }

#[derive(Deserialize, Serialize, Clone)]
pub struct Signal { pub r#type:String, pub params:serde_json::Value }

#[derive(Deserialize, Serialize, Clone)]
pub struct Risk { pub max_drawdown:f64, pub max_concurrent:i32, pub stop_loss_bps:Option<f64>, pub take_profit_bps:Option<f64> }

#[derive(Deserialize, Serialize, Clone)]
pub struct Blueprint {
  pub name:String, pub symbols:Vec<String>, pub timeframe:String,
  pub entry:Vec<Signal>, pub exit:Vec<Signal>, pub filters:Vec<Signal>,
  pub sizing:serde_json::Value, pub risk:Risk,
  pub invariants:serde_json::Value, pub evidence:serde_json::Value
}

#[derive(Deserialize, Serialize, Clone)]
pub struct Candidate { pub bp_id:String, pub params:serde_json::Value, pub rationale:String }

#[derive(Deserialize, Serialize, Clone)]
pub struct FastMetrics { pub sharpe:f64, pub cvar_proxy:f64, pub turnover:f64, pub ci95:(f64,f64) }
```

**Simple takeaway:** ชื่อ field ตรง—แปลงได้สองทาง FE/BE โดยไม่เพี้ยน

---

# 5.5 Compiler: Blueprint → IR (No-Lookahead)

แนวคิด: แปลง `entry/exit/filters` ให้เป็น **กราฟสัญญาณ** ที่คำนวณทีละบาร์โดย **ใช้อินพุตถึงบาร์ t-1 เท่านั้น**
สัญญาณต้นแบบที่รองรับใน Phase 1–2:

* `ma_cross(fast,slow)` — ครอสขึ้น/ลง (EMA/SMA เลือกได้ผ่าน params)
* `breakout(lookback)` — เบรก high/low n บาร์
* `vol_kalman(window,q,r)` — สัญญาณจากค่าเบี่ยงเบนความผันผวนแบบคัลมานอย่างคร่าว
* `ict_smc` — ให้เป็น **flag/filter** แทน entry หลักในเฟสนี้ (ลดสเปก)
* `grid(step_bps,max_levels)` — ปรับเป็น **sizing overlay** ไม่ใช่สัญญาณหลัก เพื่อคุมความเสี่ยง

IR (สรุป):

```rust
enum Node {
  MaCross { fast:u32, slow:u32, ema:bool },
  Breakout { lb:u32, dir:i8 },            // dir: +1 long, -1 short, 0 both
  VolKalman { w:u32, q:f64, r:f64 },
  FilterFlag { kind:String, params:serde_json::Value }
}
struct IR { nodes: Vec<Node>, sizing: Sizing, risk: Risk, cooldown:u32 }
```

**การ์ดไม่มองอนาคต:** ในแกนเวลาที่ t ให้สัญญาณใช้ `price[0..t-1]` เท่านั้น และเช็กในเทสต์ด้วย

**Simple takeaway:** แปลงมนุษย์อ่าน (Blueprint) → เครื่องอ่าน (IR) ที่ “ไม่โกงเวลา”

---

# 5.6 แบบจำลองราคาใน Engine (T0/T1)

> Phase 1–2 ยังไม่ผูกกับ Scenario Factory เต็ม (นั่นจะมาข้อถัดไป)
> ที่นี่เรามี **WorldBuilder แบบเบา** เพื่อประเมินอย่างรวดเร็ว

### T0 World (เบา-เร็ว)

* Returns `r_t = μΔt + σ√Δt * ε_t`, ε \~ N(0,1), เพิ่ม **jump** เล็กน้อย P(j)=p\_j, size \~ Laplace(0,b)
* กระจาย **vol regime**: เลือก `(μ, σ, p_j, b)` ตาม seed (CRN) เพื่อกระจายกรณี
* ไม่มี spread/latency/slippage (ถือว่า mid)

### T1 World (เพิ่ม microstructure เฉพาะจำเป็น)

* เพิ่ม `bid/ask` โดย `spread_bps ~ LogNormal(μ_s, σ_s)` ต่อบาร์
* **Slippage** แบบ mixture: `0` กับ `|N(0, s_slip)|` ตามสัดส่วน p
* **Latency** คงที่ `L ms` → สัญญาณ t ส่งออเดอร์ที่ `t + L/dt`
* **Partial fill**: หาก range ของบาร์สั้น → ความน่าจะเป็น fill ต่ำลงตาม logistic

**พารามิเตอร์ทั้งหมดกำหนดจาก**:

* `blueprint.evidence.envelope` (เช่น `spread_bps:12`)
* ค่าเริ่มต้นจาก `micro` ใน request `/t1`
* seeds เดียวกันทุก candidate (CRN) → เทียบยุติธรรม

**Simple takeaway:** T0 เร็วมากเพื่อคัดกรอง, T1 ใส่ความจริงขั้นต่ำให้เมตริกเสถียรขึ้น

---

# 5.7 กลไกออกออเดอร์ & การจัดการสถานะ

* **Sizing**

  * `fixed(notional)` หรือ `vol_risk(risk_per_trade)` โดย vol ใช้ `σ_w` จากหน้าต่างล่าสุด
* **Risk guard**

  * `max_drawdown` เชกตาม equity curve; `stop_loss_bps` / `take_profit_bps` ใช้กับ entry ล่าสุด
  * `max_concurrent` จำกัดจำนวนโพซิชันคงค้าง
* **Cooldown**

  * `cooldown_bars_min` หลังปิดโพซิชัน ห้ามเข้าใหม่จนกว่าจะครบ
* **FIFO fills** (ง่ายและชัด)
* **P\&L**

  * ใช้ mid / bid-ask ตามโหมด T0/T1; คิดค่าธรรมเนียมถ้ามีใน params

**Simple takeaway:** กฎเทรดมาตรฐาน ไม่มองอนาคต, คุมความเสี่ยง, นับถูกทุกบาร์

---

# 5.8 เมตริก & การรวมผล (per candidate)

* **Bar returns**: `ret_t = ΔEquity_t / Equity_{t-1}`
* **Sharpe**: `mean(ret) / std(ret) * sqrt(annualize)`; สำหรับ M1 ใช้ factor ≈ `sqrt(252*24*60)`
* **CVaR5 proxy**: ค่าเฉลี่ยของหางซ้ายที่ 5% ของ distribution ของ bar returns หรือของ daily agg (เร็วใช้ bar)
* **Turnover**: `sum(|ΔPosition|)/sum(|Position|)` (ประมาณการ)
* **CI95**: bootstrap 500x บนซีดชุดเดิม (รวดเร็วด้วยการสุ่มซ้ำดัชนี)

**การรวมหลาย seed:**

* ใช้ **CRN** เดียวกันทุก candidate → เฉลี่ยเมตริกในมิติ seed → **median-of-means** เพื่อความทน outlier

**Simple takeaway:** เมตริกเป็นมาตรฐาน ตรวจซ้ำได้ และยุติธรรมระหว่าง candidates

---

# 5.9 คอนคาเรนซี, แคช, ดีเทอร์มินิสม์

* **rayon** ขนานตาม candidates และ/หรือ seeds
* **PRNG**: ChaCha20, seed = `hash(trace_id, stage, global_seed, idx)`; antithetic: ใช้ `±ε` คู่กัน
* **Content-hash cache key**:

  ```
  key = blake3(
    canonical_json(blueprint) + canonical_json(candidate.params) +
    bars.n + dt + micro + engine_version
  )
  ```

  * ถ้ามีใน MinIO: `s3://…/cache/t0/{key}.json` → โหลดคืนทันที
  * ผลซิมใหม่ถูกบันทึกกลับเสมอ (write-through)

**Simple takeaway:** รันครั้งเดียวใช้ซ้ำได้ทั้งโปรเจกต์ ปักหมุดด้วย hash+seed+version

---

# 5.10 โค้ดสเกลตัน (Axum) — ให้ Claude Code เติมเนื้อ

**Router**

```rust
// apps/engine/src/main.rs
use axum::{routing::get, routing::post, Router};
#[tokio::main]
async fn main() {
  let app = Router::new()
    .route("/health", get(|| async { axum::Json(serde_json::json!({"status":"ok"})) }))
    .route("/t0", post(t0_handler))
    .route("/t1", post(t1_handler))
    .route("/pack", post(pack_handler));
  let port = std::env::var("PORT").unwrap_or("8088".into());
  let addr = format!("0.0.0.0:{port}");
  axum::Server::bind(&addr.parse().unwrap()).serve(app.into_make_service()).await.unwrap();
}
```

**Handlers (สรุปโครง)**

```rust
async fn t0_handler(Json(req): Json<T0Req>) -> impl IntoResponse {
  // 1) canonicalize & hash key
  // 2) if cache hit -> return
  // 3) compile blueprint -> IR
  // 4) generate worlds by seeds -> simulate with rayon
  // 5) aggregate metrics -> preview
  // 6) write cache & return
}

async fn t1_handler(Json(req): Json<T1Req>) -> impl IntoResponse { /* คล้าย t0 แต่เพิ่ม micro */ }

async fn pack_handler(Json(req): Json<PackReq>) -> impl IntoResponse {
  // ทำไฟล์:
  //  manifest.json / blueprint.json / fast_metrics.json
  // ใส่ .tar.zst หรือ .zip แล้วอัป MinIO
  // คืน hsp_uri
}
```

**Modules**: `sim/mod.rs`, `sim/t0.rs`, `sim/t1.rs`, `ir.rs`, `metrics.rs`, `micro.rs`, `cache.rs`, `hash.rs`, `minio.rs`

**Simple takeaway:** Skeleton ครบ—ทีมเติมเฉพาะ “เนื้อสมอง” ตามโมดูล

---

# 5.11 เทสต์ (Rust)

## 5.11.1 Unit tests

* `ir_no_lookahead_ok`: ป้อนบาร์ที่ราคา jump ท้ายบาร์ → สัญญาณที่ t **ไม่**เห็นค่า t
* `ma_cross_correct`: สร้างสัญญาณครอสในชุดข้อมูลทำมือ → ทริกเกอร์ตรงตำแหน่งที่คาด
* `slippage_mixture_bounds`: ค่าเฉลี่ย/ส่วนเบี่ยงเบนไม่เกินพารามิเตอร์

## 5.11.2 Property tests (proptest)

* **Termination**: สร้าง blueprint สุ่มที่มี cooldown ≥ 1 → ซิม 1e5 บาร์ **ต้อง**จบทุกออเดอร์
* **Risk guard**: `max_concurrent=1` → ณ ใด ๆ `open_positions.len() ≤ 1`

## 5.11.3 Golden tests

* blueprint+candidate+seed คงที่ → ออกเมตริก **เท่าเดิม** ข้ามเวอร์ชัน patch (ยกเว้นเปลี่ยน engine\_version)

**Simple takeaway:** เทสต์ครอบ “ไม่โกงเวลา, กฎความเสี่ยง, ทำซ้ำได้” แบบเครื่องพิสูจน์

---

# 5.12 ประสิทธิภาพ & งบ (Targets)

* `/t0` 24 candidates × 64 seeds × 4096 bars: **< 1.5s** บน M2/Zen3 (rayon on)
* `/t1` 6 candidates × 64 seeds × micro on: **< 3–5s**
* หน่วยความจำ: **< 300MB**
* CPU-bound; IO (MinIO) amortized; cache hit rate > 60% เมื่อใช้งานจริง

**Simple takeaway:** เร็วพอที่จะ “ลอง–คัด–วน” หลายครั้งโดยงบจำกัด

---

# 5.13 CI (engine-tests.yml)

* บิลด์ Release
* รัน `cargo test --all`
* แคช Cargo
* อัปโหลด coverage (ถ้าเปิด)
* ฟังค์ชันป้องกัน: หาก golden แตกโดยไม่ได้ bump `engine_version` → fail

**Simple takeaway:** PR ไหนทำให้ผลไม่เสถียร—CI จับได้

---

# 5.14 ความเสี่ยง & การ์ด

* **Overfit T0/T1** → ใช้ CRN เดียวกันทุก candidate + median-of-means + antithetic
* **แคชผิด** → key ใช้ canonical JSON + engine\_version; คืนค่าเมื่อสคีมาเปลี่ยน
* **เดดล็อก/หน่วง** → จำกัด batch; ใส่ timeout ฝั่ง orchestrator; ระบุ `ENGINE_TIMEOUT_MS`
* **ไม่ deterministic** → PRNG เดียว, block time-based randomness ทั้งหมด

**Simple takeaway:** ปิดช่องพังสำคัญตั้งแต่วันแรก

---

# 5.15 BMAD Story (ส่งให้ Claude Code)

`stories/040-engine-fast-sim.md`

* **Background**: ต้องมี T0/T1 + pack เพื่อให้ Orchestrator ใช้งานได้จริง
* **Input Contract**: ตาม 5.3; ชี้ไปยัง Zod (ข้อ 1)
* **Plan**:

  1. Scaffold Axum + types + handlers
  2. IR compiler + unit tests (no-lookahead)
  3. T0 sim + metrics + cache + tests
  4. T1 micro + tests
  5. MinIO pack + tests
* **DoD**:

  * `/health` 200; `/t0` & `/t1` คืน metrics ถูกสคีมา
  * property tests ผ่าน; golden stable
  * cache hit/deterministic assert ผ่าน
  * CI ผ่าน 100%
* **Rollback**: ปิด T1 ชั่วคราว (ใช้ T0 + conservative micro factors) หากเจอ latency สูง

**Simple takeaway:** สตอรี่ละเอียด—Claude Code ทำงานทีละไฟล์จนเทสต์ผ่าน ไม่ต้องเดา

---

# วิธีรัน (Dev loop)

```bash
# บิลด์/เทสต์ Engine
cd apps/engine
cargo test
cargo run --release

# ยิงด้วยมือ
curl -s http://localhost:8088/health
curl -s -X POST http://localhost:8088/t0 -H 'Content-Type: application/json' -d @fixtures/t0.req.json | jq .
curl -s -X POST http://localhost:8088/t1 -H 'Content-Type: application/json' -d @fixtures/t1.req.json | jq .
curl -s -X POST http://localhost:8088/pack -H 'Content-Type: application/json' -d @fixtures/pack.req.json | jq .
```

**Simple takeaway:** Engine พร้อมใช้งานเดี่ยว ๆ และเสียบเข้ากับข้อ 4 ได้ทันที

---

## ปิดข้อ 5

Engine ตัวนี้คือ “มอเตอร์” ของ ATLAS: มาตรฐาน—เร็ว—ซื่อสัตย์—ทำซ้ำได้ และบันทึกทุกบริบทเพื่ออธิบายภายหลัง คุณพร้อมต่อ **ข้อ 6 (QC T2/T3 + Scenario Factory hookup)** ได้เลย โดยไม่ต้องแก้สัญญาหลัก และถ้าจะปรับลึก—เพิ่มสัญญาณหรือไมโครสตรัคเชอร์—ก็แค่เพิ่ม Node/Module และเทสต์ตามกรอบเดิม

**Simple takeaway:** ข้อ 5 ทำให้ระบบคุณ “ขับเคลื่อนจริง” เรียบร้อย—เหลือเติมสนามทดสอบเข้ม (T2/T3) และ formal ในเฟสต่อไป.





มาแล้ว “ข้อ 6: **Scenario Factory + QC (T2/T3) hookup**” แบบจัดเต็ม ให้ Claude Code โค้ดได้ทันทีตามสเปก—ไม่มีเดา
โฟกัส: โรงงาน A สร้าง “ตลาดสังเคราะห์” คุณภาพสูง + QC เข้ม, โรงงาน B (Engine/Orchestrator) เรียกใช้ **T2/T3** บนชุดนั้นอย่างมีสัญญาเดียวกัน

---

# 6.1 เป้า & ขอบเขต (Outcome)

* บริการ **scenario** (Rust + Axum) สำหรับ “สังเคราะห์ตลาด” + “QC” + “แพ็ก & ลงทะเบียน”
* สัญญา **ScenarioSpec → ScenarioSet (paths + qc\_report + manifest)** เก็บใน MinIO + Postgres
* เพิ่ม **Engine endpoints**: `/t2` (sim บน paths สังเคราะห์พร้อม microstructure) และ `/t3` (เวอร์ชัน realistic/หนักขึ้น)
* เพิ่ม **Orchestrator nodes**: `t2`, `t3`, `qc_gate` เลือกใช้ชุดที่ผ่าน QC เท่านั้น
* เทสต์ครบ: reproducibility (seed), stylized-facts targets, coverage, performance budgets
* CI ยกชุดเล็ก (n\_paths เล็ก ๆ) รันทดสอบ end-to-end

**Simple takeaway:** จบข้อ 6 → คุณมี “สนามทดสอบจริงจัง” พร้อมสายพานส่งถึง Orchestrator/Engine แบบปราศจาก lookahead

---

# 6.2 ภาพรวมสถาปัตยกรรม & ไดอะแกรม

```
┌──────────── UI/API ────────────┐
│  create spec  │  select set    │
└──────┬────────┴────────┬───────┘
       │                 │
       ▼                 ▼
   Scenario Service    Orchestrator (LangGraph)
 (Axum, Rust, SIMD)         │
   ┌───────────────┐        │  uses scenario_set_id
   │ Sampler       │        ▼
   │ Path Gen      │───► Engine (/t2, /t3) ──► Metrics/Select ─► Pack HSP
   │ Micro-Augment │
   │ Stylized QC   │───► qc_report.json
   └──────┬────────┘
          ▼
   Registry (Postgres) + MinIO (Parquet/Zarr)
```

**Simple takeaway:** โรงงาน A ผลิต “ชุดตลาด” แล้วโรงงาน B หยิบมาใช้ใน T2/T3 ผ่าน id เดียว

---

# 6.3 โครงไฟล์ใหม่ (repo additions)

```
apps/scenario/                          # NEW service
  Cargo.toml
  src/main.rs
  src/routes/{health.rs,sets.rs,qc.rs}
  src/spec/{schema.rs,sampler.rs,gen.rs,micro.rs}
  src/qc/{stylized.rs,coverage.rs,report.rs}
  src/io/{parquet.rs,s3.rs,manifest.rs}
  src/util/{hash.rs,seed.rs,timer.rs}

apps/engine/src/handlers/t2.rs          # NEW
apps/engine/src/handlers/t3.rs          # NEW
apps/engine/src/io/s3.rs                # Reuse s3 client

apps/orchestrator/src/nodes/t2.ts       # NEW
apps/orchestrator/src/nodes/t3.ts       # NEW
apps/orchestrator/src/nodes/qc_gate.ts  # NEW

ops/db/init/0006_scenario_registry.sql  # NEW tables
stories/050-scenario-factory.md
stories/060-engine-t2-t3.md
tests/scenario/{qc_targets.test.rs, reproducible.test.rs}
tests/e2e/t2_t3_smallset.test.ts
```

**Simple takeaway:** เพิ่ม service “scenario” + hook-ins ให้ Engine/Orchestrator + schema DB

---

# 6.4 สัญญา & Data Contracts

## 6.4.1 `ScenarioSpec` (JSON/YAML)

```json
{
  "asset": "XAUUSD",
  "timeframe": "M1",
  "horizon_bars": 4096,
  "n_paths": 512,
  "targets": {
    "kurtosis": [4.5, 8.0],
    "skew": [-0.6, 0.2],
    "absret_acf_lag1": [0.15, 0.35],
    "hurst": [0.52, 0.60],
    "leverage_corr": [-0.3, -0.05],
    "spread_bps": [8, 20]
  },
  "generators": [
    { "name":"regime_gbm", "weight":0.4,
      "params": { "mu":[-0.05,0.05], "sigma":[0.06,0.25], "switch_p":[0.002,0.01], "jump_p":[0.002,0.008], "jump_b":[0.003,0.02] } },
    { "name":"garch_11", "weight":0.3,
      "params": { "omega":[1e-6, 1e-5], "alpha":[0.05,0.15], "beta":[0.80,0.94] } },
    { "name":"sv_leverage", "weight":0.3,
      "params": { "rho":[-0.6,-0.1], "vol_mean":[0.06,0.20], "vol_kappa":[0.05,0.20] } }
  ],
  "micro": {
    "spread_lognorm_mu": 2.2,
    "spread_lognorm_sigma": 0.45,
    "latency_ms": [40,120],
    "slippage": { "p0":0.7, "sigma": 0.4 }
  },
  "sampling": { "method":"lhs", "seed": 20250824 }
}
```

## 6.4.2 Registry Tables (Postgres)

* `scenario_sets(id, version, asset, timeframe, n_paths, horizon_bars, spec_json, qc_summary, obj_uri, checksum, created_at)`
* `scenario_paths(set_id, seed, uri, stats, checksum)`
* `scenario_qc_reports(set_id, report_json, pass, created_at)`

**Simple takeaway:** Spec สั้น ๆ → set หนึ่งอ้าง path หลายไฟล์ + qc\_report หนึ่งชุด

---

# 6.5 Sampling & Seeds

* ใช้ **LHS (Latin Hypercube Sampling)** หรือ **Orthogonal sampling** จากพิสัยใน spec
* สร้าง `n_paths` ชุดพารามิเตอร์ โดย **stratify** ตาม generator weight
* seeds: `seed_i = blake3(spec.seed, i)`; บันทึกใน manifest เพื่อ reproducibility
* CRN (Common Random Numbers) เพื่อเทียบยุทธศาสตร์อย่างยุติธรรมใน T2/T3

**Simple takeaway:** path แต่ละอัน deterministic จาก spec+index—รันซ้ำได้ 100%

---

# 6.6 Path Generation Models (กลาง–หนัก)

### 6.6.1 Regime-Switch GBM + Jumps

* สถานะ `S_t ∈ {calm, volatile}` สลับด้วย `switch_p`
* ผลตอบแทน `r_t = μ_s Δt + σ_s √Δt ε_t + J_t`, `J_t` เป็น Laplace jump ด้วยความน่าจะเป็น `jump_p`
* ใช้ **antithetic**: run ε, −ε ในคู่เดียว เพิ่มเสถียรภาพ

### 6.6.2 GARCH(1,1)

* `σ_t^2 = ω + α r_{t-1}^2 + β σ_{t-1}^2` + innovations Student-t เพื่อหางหนา
* ติดตั้งค่าพารามิเตอร์จาก sampling; enforce `α+β < 1` เพื่อความคงที่

### 6.6.3 Stochastic Vol with Leverage (SV)

* `log σ_t = φ log σ_{t-1} + η_t`, `corr(η_t, ε_t) = ρ < 0` (leverage)
* ใช้ Euler discretization ในความเร็วสูง

### 6.6.4 Microstructure (ต่อท้ายตอนเขียนไฟล์)

* สร้าง **bid/ask**: `spread_bps ~ LogN(μ,σ)` ต่อบาร์; bid=mid−s/2, ask=mid+s/2
* **Latency**: shift execution index = `ceil(latency_ms / dt_ms)`
* **Slippage** mixture: fill price offset \~ mixture(0, |N(0,σ\_slip)|)

**Simple takeaway:** ผสม 3 โมเดลแกนกลาง + micro จริงพอ (ไม่ต้องถึง LOB) ครอบคลุม stylized หลัก

---

# 6.7 QC Engine & Targets

### 6.7.1 สถิติสรุปหลัก

* **Fat tails**: kurtosis, fit Student-t ν, Hill tail index
* **Skew**: return skewness
* **Vol clustering**: ACF(|r|) lag1..10 (เฉพาะ lag1 เป็น target; lagอื่นใช้ reporting)
* **Long memory**: Hurst exponent (DFA ย่อ)
* **Leverage effect**: corr(r\_t, σ\_{t+1}) < 0
* **Gain/Loss asymmetry**: P(r>0) vs P(r<0), tail prob ratio
* **Micro**: mean/var ของ `spread_bps`, fill\_ratio, slippage mean/var

### 6.7.2 ตัวชี้วัดคุณภาพชุด (set-level)

* **SMM/ABC score**: sum of normalized distancesของสถิติเป้าหมาย (0..1 ต่อมิติ)
* **Wasserstein distance** (1-D) ของ empirical distribution ของ |r| กับ target
* **Coverage**: ความกว้างของ distribution ของ 5 สถิติหลักครอบช่วง target กี่เปอร์เซ็นต์

### 6.7.3 เกณฑ์ผ่าน

* `SMM_score ≤ 0.25`, `coverage ≥ 0.9`, `mean(spread_bps) ∈ [μ_s±15%]`
* รายงาน: `qc_report.json` ระบุ fail-reasons และฮิสโตรแกรมย่อ

**Simple takeaway:** QC ไม่ใช่แค่กดผ่าน—วัดหลายมิติ + รายงานละเอียด + ชี้ว่า “คลาดจากจริงตรงไหน”

---

# 6.8 รูปแบบจัดเก็บ (S3/MinIO)

* **Parquet** (ZSTD) ต่อ path: คอลัมน์ `ts,i,mid,open,high,low,close,bid,ask,spread_bps,flags`
* โฟลเดอร์: `s3://minio/heliox/scenarios/{set_id}/path_{i}.parquet`
* `manifest.json` (set-level): metadata, seeds\[], generator params\[], checksums
* `qc_report.json` (set-level) + `provenance.json` (เครื่องมือ/เวอร์ชัน/เวลา)

**Simple takeaway:** ขยะน้อย เปิดอ่านเร็ว ทำงานได้กับ Polars/Rust/Arrow ทุกฝั่ง

---

# 6.9 REST ของ Scenario Service

* `POST /v1/scenario-sets` → รับ `ScenarioSpec` → สร้าง set ใหม่ (async) → คืน `{set_id}`
* `GET /v1/scenario-sets/{id}` → คืน metadata + qc\_summary
* `GET /v1/scenario-sets/{id}/paths` → คืนรายการไฟล์ (URI + seed + checksum)
* `POST /v1/scenario-sets/{id}/qc` → trigger QC (ถ้าอยาก re-QC)
* `GET /v1/scenario-sets/{id}/qc` → คืนรายงานเต็ม

**Simple takeaway:** สี่ endpoint ก็ครบลูป “สร้าง–ตรวจ–ใช้”

---

# 6.10 Engine: `/t2` และ `/t3`

## `/t2` (ใช้ bars + micro จาก Parquet; realistic เบา)

**Request**

```json
{
  "trace_id":"tr_...",
  "blueprint": {...},
  "selected": ["cand_005","cand_007"],
  "scenario_set_id":"scn_2025_08_24",
  "path_uris": ["s3://.../path_0.parquet","s3://.../path_1.parquet", "..."],
  "limits": { "max_paths": 128 }  // เพื่อควบคุมโหลด
}
```

**Response**

```json
{
  "engine_version":"t2.1.0",
  "metrics": { "cand_005": {...}, "cand_007": {...} },
  "preview": { "used_paths": 128, "wall_ms": 4200 }
}
```

## `/t3` (หนักขึ้น: เพิ่ม event-driven fills/latency variability/fees)

* เพิ่ม **latency distribution**, **slippage skew**, **partial fill model** = logistic-by-range
* อาจใช้ subset paths เฉพาะโหมดสุดทาง (importance sampling) จาก qc tags

**Simple takeaway:** T2/T3 = “ซิมบนตลาดสังเคราะห์” จริงจังกว่า T1—และคุมงบด้วย limits

---

# 6.11 Orchestrator nodes เพิ่มเติม

* `nodeT2`: โหลด path list จาก Scenario Service หรือ DB, เลือก `max_paths` ตามงบ, เรียก Engine `/t2`, emit `metric` & `status`
* `nodeT3`: เฉพาะ top-M จาก T2 → `/t3` → คัด `best`
* `nodeQcGate`: อ่าน `scenario_qc_reports.pass==true` เท่านั้น (ไม่ผ่าน → emit error และหยุด)

**Simple takeaway:** กราฟเพิ่ม 3 โหนด—แต่สัญญาเหมือนเดิม จึงเสียบได้ง่าย

---

# 6.12 ประสิทธิภาพเป้าหมาย (Dev laptop)

* Gen 512 paths × 4096 bars: **< 20s** (SIMD + rayon)
* QC (stats+ABC): **< 6s**
* `/t2` 2 candidates × 128 paths: **< 5s**
* `/t3` 1–2 candidates × 64 paths with heavy micro: **< 8–12s**

**Simple takeaway:** วน loop ดีไซน์-คัด-ยืนยัน ได้ในนาทีเดียว

---

# 6.13 เทสต์ (สำคัญ)

## Scenario service (Rust)

* **reproducible.test**: สร้าง set เดิม seed เดิม → checksum manifest/path เหมือนเดิม
* **stylized\_targets.test**: ชุดเล็ก n=64 ตรวจว่า metrics อยู่ในพิสัย
* **coverage.test**: distribution ของ kurtosis/hurst ครอบ target ≥90%
* **parquet\_io.test**: เขียน/อ่านกลับแล้วเท่ากัน

## Engine

* **t2\_smoke**: อ่าน 8 paths จาก set เล็ก → คืน metrics ถูกสคีมา
* **t3\_micro\_bounds**: เมตริกไม่ออกนอกกรอบเมื่อเพิ่ม latency/slippage

## E2E (Node)

* orchestrator: กราฟ `PHASE0→T0→T1→T2→T3→PACK` กับ set เล็ก → เห็น `final` event + HSP ออกมา
* **qc\_gate\_fail**: ใช้ set ที่เจตนา fail target → กราฟหยุดและส่ง error ชัดเจน

**Simple takeaway:** เทสต์ครอบ “ทำซ้ำได้–ตรงเป้า–ต่อท่อครบ–หยุดเมื่อสนามไม่ผ่าน”

---

# 6.14 CI

* Workflow `scenario-tests.yml`

  * build + `cargo test` ใน `apps/scenario`
  * รัน “mini set” (n\_paths=16) → `qc` → ตรวจว่า pass
* Workflow `engine-t2t3.yml`

  * spin MinIO service, อัป mini set
  * build engine → รัน `cargo test --features t2t3`
* Workflow e2e (optional)

  * spin pg+nats+minio → mock llm → orchestrator runs → assert final event

**Simple takeaway:** ทุก PR จะทดสอบตั้งแต่สังเคราะห์ยันวิ่ง T3 ได้ใน scale เล็ก

---

# 6.15 งบประมาณ & Knobs

* `SCN_N_PATHS_MAX` (เช่น 1024 dev, 4096 prod)
* `QC_SMM_MAX = 0.25`, `QC_COVERAGE_MIN=0.9`
* Engine: `T2_MAX_PATHS=128`, `T3_MAX_PATHS=64`, timeouts ชัดเจน
* Orchestrator: ตัดสินใจ **early stop** หาก dominance ชัดเจนใน T2
* Storage: ZSTD level 3–6 สมดุล speed/size

**Simple takeaway:** ปรับไม่กี่ปุ่ม ครอบทั้งต้นทุนและคุณภาพ

---

# 6.16 ความเสี่ยง & การ์ด

* **สเปกหลวม → ชุดไม่เสถียร**: ล็อก `targets` จาก empirical จริง (จะเติมใน phase data-calibration)
* **QC ผ่านยาก/ง่ายเกิน**: ใช้ ABC tuning บน threshold, เก็บค่าไว้ใน `provenance.json`
* **IO choke**: stream อ่าน Parquet เป็น batch; พารัลเลลเป็น path-shard
* **ไม่ deterministic**: seed ทุกชั้น (sampler, gen, micro); ใส่ seed ใน manifest
* **overfitting ต่อสนามสังเคราะห์**: randomize family-mix ต่อ run + CRN + antithetic + median-of-means

**Simple takeaway:** ตั้งการ์ดปัญหาหลักไว้ล่วงหน้า—สนามซื่อสัตย์และเสถียร

---

# 6.17 วิธีรัน (Dev loop)

```bash
# 1) สร้างชุดเล็ก
curl -X POST http://localhost:8092/v1/scenario-sets \
  -H 'Content-Type: application/json' -d @specs/xauusd_small.json
# -> { "set_id": "scn_2025_08_24_01" }

# 2) ดูสถานะ & QC
curl http://localhost:8092/v1/scenario-sets/scn_2025_08_24_01
curl http://localhost:8092/v1/scenario-sets/scn_2025_08_24_01/qc

# 3) ยิง orchestrator run โดยระบุ scenario_set_id
curl -X POST http://localhost:8080/v1/runs \
  -H 'Content-Type: application/json' \
  -d '{"prompt":"xauusd scalping","scenario_set_id":"scn_2025_08_24_01"}'

# 4) เปิด SSE ดูอีเวนต์จนจบ
curl -N http://localhost:8080/v1/runs/tr_.../events
```

**Simple takeaway:** 4 ขั้นตอน—สนามพร้อม, QC ผ่าน, กดรันจนได้ HSP

---

# 6.18 BMAD Stories (ส่งให้ Claude Code)

## `stories/050-scenario-factory.md`

* **Background**: ต้องสร้างทางเลือกตลาดสังเคราะห์ให้ซื่อสัตย์และเร็ว
* **Plan**: sampler → gen → micro → parquet → qc → registry
* **DoD**: reproducible, qc pass, coverage ≥0.9, API วิ่ง, tests/CI ผ่าน

## `stories/060-engine-t2-t3.md`

* **Background**: ต้องซิมบนตลาดสังเคราะห์แท้จริง
* **Plan**: handlers `/t2` `/t3` + reader + metrics
* **DoD**: sim บน 128 paths <5s, deterministic, metrics ตรง schema

**Simple takeaway:** แตกงานเป็นสตอรี่เล็ก ๆ พร้อม DoD—Claude Code เขียนจบเป็นส่วน ๆ

---

# 6.19 Prompt Templates (QC Agent — optional)

* **qc\_gate.md (system)**: “ผ่านเฉพาะ set ที่ qc.pass=true & SMM≤0.25 & coverage≥0.9; เหตุผลต้องอ้างตัวเลขจริง”
* **qc\_gate.md (user)**: ใส่ `qc_report.json` + thresholds → ให้ LLM เขียน “explainability” ฝั่งเอกสาร (ไม่ใช่ผู้ตัดสิน)

**Simple takeaway:** การตัดสินเป็น machine-checkable; LLM ช่วยอธิบาย ไม่ใช่กดปุ่มผ่าน

---

## ปิดข้อ 6

คุณได้ **Scenario Factory** ที่สังเคราะห์ตลาด “เหมือนจริงกว่า backtest” พร้อม QC เข้ม และท่อส่งถึง Engine/Orchestrator ใน T2/T3. ทุกอย่าง reproducible, เร็ว, ประหยัด, ตรวจสอบได้ และถูกขังด้วยสัญญาเดียวกันทั้งระบบ

**Simple takeaway:** ตั้งแต่วันนี้ กลยุทธ์ของคุณถูกพิสูจน์บน “จักรวาลตลาดที่ซื่อสัตย์”—พร้อมเข้าขั้นตอน Formal/Release ในข้อถัดไปโดยไม่เปลืองคอมพิวต์.





ต่อยอดให้สุดสำหรับ **ข้อ 6: Scenario Factory + QC (T2/T3) hookup (Local-first, Cloud-ready)**
เป้าหมาย: ให้ Claude Code “ลงมือโค้ดได้เลย” แบบไม่ต้องเดา พร้อมเทสต์/CI/สัญญา/ไดอะแกรมครบถ้วน

---

# 6.0 ภาพรวม (One-pager)

**โรงงาน A (Scenario Factory)** สร้าง “ตลาดสังเคราะห์” ที่ซื่อสัตย์ต่อ stylized facts → QC เข้ม → เก็บลง Registry/MinIO (local ได้)
**โรงงาน B (Engine/Orchestrator)** ดึงชุดเดียวกันไปรัน **T2/T3** (ซิมบน paths จริง), คัดเลือก, แล้วส่งต่อไปแพ็ก HSP

```
UI/API ──▶ Scenario Service (create set, QC, list) ─┐
                                                    ├─▶ Registry (Postgres)
Orchestrator (Phase0→T0→T1→T2→T3→Pack) ────────────┘
        │        │       │   │   │
        │        │       │   └───┴─▶ Engine (/t2,/t3) — อ่าน Parquet จาก MinIO (local หรือ S3)
        ▼        ▼       ▼
      Events   Metrics  HSP
```

Simple takeaway: มี “โรงงานตลาด” กับ “โรงงานกลยุทธ์” เชื่อมกันด้วย `scenario_set_id` เดียว—รันบนเครื่องคุณก่อน ย้ายขึ้นคลาวด์ทีหลังได้ทันที

---

# 6.1 ผลลัพธ์ที่ต้องได้ (Outcome)

1. บริการ **apps/scenario (Rust + Axum)**: สร้างชุดสภาวะตลาด → QC → ลงทะเบียน
2. Engine เพิ่ม **/t2 /t3** (sim บน paths สังเคราะห์ + microstructure จริงพอ)
3. Orchestrator เพิ่ม **nodes: t2, t3, qc\_gate** + event emission มาตรฐาน
4. เก็บข้อมูลแบบ **local-first**: MinIO + Postgres (docker-compose), ย้ายขึ้น S3 ได้ด้วยการเปลี่ยน ENV
5. Tests & CI ครบ: reproducibility, QC targets, E2E ขนาดเล็ก

Simple takeaway: เมื่อจบข้อ 6 คุณจะ “สตาร์ทรัน” ได้ตั้งแต่สร้างสนาม→ตรวจสนาม→ทดสอบกลยุทธ์ขั้นจริง→ปล่อย HSP

---

# 6.2 ไดอะแกรม 3 ระดับ

## Macro (บริการหลัก)

```
┌────────── UI/API ──────────┐
│ create spec │ choose set   │
└──────┬──────┴───────┬──────┘
       │              │
       ▼              ▼
  Scenario Service  Orchestrator (LangGraph)
    (Axum)              │ uses scenario_set_id
    │                   ▼
    ├─ Sampler → Gen → Micro → QC → Register
    │                      ▲
    └────── Manifest/Parquet (MinIO) ───┘
```

Simple takeaway: การสร้างและใช้ชุดสภาวะตลาดแยกกันชัดเจนแต่เรียกหาได้ด้วย id เดียว

## Meso (Scenario Factory pipeline)

```
Spec → Sampler (LHS/Orthogonal) → PathGen (GBM±Regime / GARCH / SV+Leverage)
    → Microstructure (spread/slip/latency/partial fill)
    → Parquet writer (columnar)
    → Stylized QC (SMM/ABC + coverage)
    → Manifest + qc_report + provenance
    → Registry rows + URIs
```

Simple takeaway: ขั้นตอนทุกอย่าง deterministic และตรวจย้อนกลับได้

## Micro (QC metrics & thresholds)

* fat tails: kurtosis, ν (Student-t)
* vol clustering: ACF(|r|) lag1..10
* long memory: Hurst (DFA)
* leverage: corr(r\_t, σ\_{t+1}) < 0
* micro: mean/var spread\_bps, slippage, fill\_ratio
* set-level: SMM score ≤ 0.25, coverage ≥ 0.9

Simple takeaway: สนาม “เหมือนจริง” วัดได้หลายมิติ ไม่ใช่แค่ดู distribution เดียว

---

# 6.3 โครงสร้างโค้ดที่ต้องเพิ่ม

```
apps/scenario/
  Cargo.toml
  src/main.rs
  src/routes/{health.rs,sets.rs,qc.rs}
  src/spec/{schema.rs,sampler.rs,gen.rs,micro.rs}
  src/qc/{stylized.rs,coverage.rs,report.rs}
  src/io/{parquet.rs,s3.rs,manifest.rs}
  src/util/{hash.rs,seed.rs,timer.rs}
apps/engine/src/handlers/{t2.rs,t3.rs}
apps/orchestrator/src/nodes/{t2.ts,t3.ts,qc_gate.ts}
ops/db/init/0006_scenario_registry.sql
stories/{050-scenario-factory.md,060-engine-t2-t3.md}
tests/scenario/{qc_targets.test.rs,reproducible.test.rs}
tests/e2e/t2_t3_smallset.test.ts
```

Simple takeaway: แยกโมดูลตามหน้าที่—Claude Code เติมเนื้อได้ทีละไฟล์

---

# 6.4 Data Contracts (สคีมา)

## 6.4.1 ScenarioSpec (JSON/YAML)

```json
{
  "asset": "XAUUSD",
  "timeframe": "M1",
  "horizon_bars": 4096,
  "n_paths": 512,
  "targets": {
    "kurtosis": [4.5, 8.0],
    "skew": [-0.6, 0.2],
    "absret_acf_lag1": [0.15, 0.35],
    "hurst": [0.52, 0.60],
    "leverage_corr": [-0.30, -0.05],
    "spread_bps": [8, 20]
  },
  "generators": [
    {"name":"regime_gbm","weight":0.4,
     "params":{"mu":[-0.05,0.05],"sigma":[0.06,0.25],"switch_p":[0.002,0.01],
               "jump_p":[0.002,0.008],"jump_b":[0.003,0.02]}},
    {"name":"garch_11","weight":0.3,
     "params":{"omega":[1e-6,1e-5],"alpha":[0.05,0.15],"beta":[0.80,0.94]}},
    {"name":"sv_leverage","weight":0.3,
     "params":{"rho":[-0.6,-0.1],"vol_mean":[0.06,0.20],"vol_kappa":[0.05,0.20]}}
  ],
  "micro": {
    "spread_lognorm_mu": 2.2,
    "spread_lognorm_sigma": 0.45,
    "latency_ms": [40,120],
    "slippage": {"p0":0.7, "sigma":0.4}
  },
  "sampling": {"method":"lhs","seed": 20250824}
}
```

## 6.4.2 Parquet schema (per-path)

* columns: `ts: i64 (ns)`, `mid,f64`, `open,high,low,close: f64`, `bid,ask: f64`, `spread_bps: f32`, `flags: u32`
* partition: `scenarios/{set_id}/path_{i}.parquet`
* compression: ZSTD level 3–6

## 6.4.3 Manifest & QC Report

```json
// manifest.json
{ "set_id":"scn_2025_08_24_01", "asset":"XAUUSD", "timeframe":"M1",
  "horizon_bars":4096, "n_paths":512, "seeds":[...],
  "generators":[{"name":"regime_gbm","count":210},{"name":"garch_11","count":150},{"name":"sv_leverage","count":152}],
  "micro":{"spread_lognorm_mu":2.2,"spread_lognorm_sigma":0.45,"latency_ms":[40,120],"slippage":{"p0":0.7,"sigma":0.4}},
  "obj_prefix":"s3://minio/heliox/scenarios/scn_2025_08_24_01",
  "checksum":"b3:...","provenance":{"scenario_version":"0.2.0","toolchain":"rust-1.80","commit":"abc123"}
}
```

```json
// qc_report.json
{ "pass": true, "smm_score": 0.19, "coverage": 0.93,
  "stats": { "kurtosis":{"mean":5.8,"p10":4.7,"p90":7.6},
             "skew":{"mean":-0.22}, "absret_acf_lag1":{"mean":0.23},
             "hurst":{"mean":0.56}, "leverage_corr":{"mean":-0.18},
             "spread_bps":{"mean":13.1} },
  "fail_reasons": [], "notes":"targets met within tolerance"
}
```

Simple takeaway: สัญญาเก็บไฟล์/เมตาดาต้าแน่น—Engine/Orchestrator อ่านได้ตรง ๆ

---

# 6.5 Sampling & Determinism

* LHS/Orthogonal: กระจาย parameter space ตาม `generators[].weight`
* Seed derivation: `seed_i = blake3(spec.seed || 0, i)`
* CRN: ทุก candidate ใช้ **ชุด seeds เดียวกัน** ใน T2/T3 → เทียบยุติธรรม
* content-hash: `blake3(canonical_json(spec) + engine_version + scenario_version)`

Simple takeaway: รันซ้ำได้ 100%—เปลี่ยนผลลัพธ์เฉพาะตอนคุณแก้สเปกจริง ๆ

---

# 6.6 ตัวสร้างเส้นทางราคา (PathGen)

## 6.6.1 Regime-switch GBM + jumps

* states: `calm`/`volatile`, transition prob `p_switch`
* return: `r_t = μ_s Δt + σ_s √Δt ε_t + J_t`
* `J_t ~ Laplace(0, b)` with prob `p_jump`
* antithetic: ใช้ (ε, −ε) เป็นคู่

## 6.6.2 GARCH(1,1)

* `σ_t^2 = ω + α r_{t-1}^2 + β σ_{t-1}^2` with Student-t innovation
* constrain `α+β < 1` เพื่อความคงที่

## 6.6.3 SV + leverage

* `log σ_t = φ log σ_{t-1} + η_t`, `corr(η_t, ε_t) = ρ < 0`
* ใช้ Euler discretization, จำกัด `|ρ| ≤ 0.7`

Simple takeaway: ใช้สามครอบครัวครอบพฤติกรรมหลักของตลาด (regime, clustering, leverage, jumps)

---

# 6.7 Microstructure Augmenter

* spread: `spread_bps ~ LogN(μ,σ)` ต่อบาร์ → `bid=mid−s/2`, `ask=mid+s/2`
* latency: `latency_ms` map เป็นจำนวนบาร์ `L = ceil(latency_ms / dt_ms)` (ส่งคำสั่งที่ t, fill ที่ t+L)
* slippage: mixture `with prob p0 → 0`, else `|N(0, σ_slip)|`
* partial fill: `p_fill = σ(κ · range_bps − θ)` (โลจิสติก), กำหนดจาก `micro` หรือ evidence

Simple takeaway: เติมสิ่งที่มีผลกับ PnL จริง โดยไม่ต้องจำลอง LOB เต็ม

---

# 6.8 QC: คณิต & ขั้นตอน

## 6.8.1 สถิติเส้นทาง (ต่อ path)

* `kurtosis(r)`, `skew(r)`
* `acf(|r|, lag=1..10)` โดยเน้น lag1
* Hurst (DFA): slope ใน log-log window
* leverage: corr(r\_t, σ\_{t+1}), σ ประมาณจาก rolling stdev
* micro: mean/var spread\_bps, fill\_ratio, slippage

## 6.8.2 การรวมเป็นคะแนนชุด (set-level)

* Normalize target per metric: `z = (stat − target_mid)/target_half_range`, clip |z|≤1
* **SMM score = mean(|z\_i|)** (ยิ่งต่ำยิ่งดี)
* **Coverage**: สัดส่วนของ percentile band ของสถิติที่ครอบช่วงเป้าหมาย (≥90%)

## 6.8.3 ABC tuning (เชิงเลือก)

* ถ้า SMM > threshold: ปรับ weight generators และ resample เฉพาะส่วนที่เบี่ยง
* บันทึกการ tuning ใน `provenance.json`

Simple takeaway: QC เวิร์คโฟลว์วัดหลายมิติ + ปรับน้ำหนักโดยวิธี ABC หากคลาดจากเป้าหมาย

---

# 6.9 Storage Adapter (local-first)

**ENV**

```
STORAGE_PROVIDER=local|s3
LOCAL_ROOT=~/heliox_data
S3_ENDPOINT=http://localhost:9000         # MinIO
S3_BUCKET=heliox
S3_ACCESS_KEY=heliox
S3_SECRET_KEY=heliox123
S3_REGION=us-east-1
S3_SSE=none|AES256
```

**layout**

```
{root}/scenarios/{set_id}/path_{i}.parquet
{root}/scenarios/{set_id}/manifest.json
{root}/scenarios/{set_id}/qc_report.json
```

Simple takeaway: เริ่ม local ได้ทันที (MinIO) และย้าย S3 โดยไม่แก้โค้ด—แค่สลับ ENV

---

# 6.10 Scenario Service API (Rust/Axum)

* `POST /v1/scenario-sets` → รับ `ScenarioSpec`, คืน `{set_id}` (งาน async)
* `GET /v1/scenario-sets/{id}` → metadata + qc\_summary
* `GET /v1/scenario-sets/{id}/paths?limit=&offset=` → URIs + seeds
* `POST /v1/scenario-sets/{id}/qc` → re-QC (optional)
* `GET /v1/scenario-sets/{id}/qc` → `qc_report.json`

**Idempotency**: `idem_key` จาก hash(spec) ป้องกันสร้างซ้ำ
Simple takeaway: ชุด endpoint เรียบง่าย ครอบวงจร “ประกาศ-สร้าง-ตรวจ-ใช้”

---

# 6.11 Engine: `/t2` และ `/t3` (ต่อจากข้อ 5)

## `/t2` (อ่าน Parquet)

**Req**

```json
{ "trace_id":"tr_...", "blueprint":{...}, "selected":["cand_007","cand_009"],
  "scenario_set_id":"scn_...", "limits":{"max_paths":128} }
```

**Resp**

```json
{ "engine_version":"t2.1.0", "metrics": { "cand_007": {...}, "cand_009": {...} },
  "preview": { "used_paths": 128, "wall_ms": 4200 } }
```

## `/t3` (หนักขึ้น)

* เพิ่ม latency distribution (เช่น lognormal), slippage skew, partial fill ที่ขึ้นกับ range/vol
* ใช้ subset “extremes” จาก **importance sampling** ที่ QC แปะ tag ให้

Simple takeaway: T2/T3 คือ “เอาไปวิ่งจริงบนสนามสังเคราะห์” — เสถียรกว่า T0/T1

---

# 6.12 Orchestrator nodes

* `nodeQcGate`: ตรวจ `qc.pass == true && coverage≥0.9 && smm_score≤0.25`; ไม่ผ่าน → emit `error` แล้วหยุด
* `nodeT2`: fetch path list (respect `max_paths`), call `/t2`, emit metrics/status
* `nodeT3`: คัด top-M จาก T2 → call `/t3`, emit metrics/status → ผลักไป `pack`

Simple takeaway: เพิ่ม 3 โหนดเข้ากราฟเดิมโดยไม่แตะสัญญาอื่น—ต่อได้ทันที

---

# 6.13 ประสิทธิภาพเป้าหมาย (บนแล็ปท็อป dev)

* สร้าง 512 paths × 4096 bars: < 20s
* QC SMM/coverage: < 6s
* `/t2` (2 candidates × 128 paths): < 5s
* `/t3` (1–2 candidates × 64 paths microหนัก): 8–12s

Simple takeaway: วนคิด-คัด-ยืนยันได้ภายใน 1–2 นาทีต่อรอบ

---

# 6.14 เทสต์ (สำคัญ)

## Scenario (Rust)

* `reproducible.test`: spec เดิม→set เดิม→checksum/manifest/path เท่าเดิม
* `stylized_targets.test`: ชุดเล็ก n=64 → สถิติอยู่ในพิสัย
* `coverage.test`: coverage ≥ 0.9
* `parquet_io.test`: round-trip เท่ากัน

## Engine

* `t2_smoke`: 8 paths → metrics schema ถูกต้อง
* `t3_micro_bounds`: เมตริกไม่หลุดกรอบเมื่อเพิ่ม latency/slippage

## E2E (Node)

* กราฟ `PHASE0→T0→T1→QC_GATE→T2→T3→PACK` (mini set) → มี `final` event + HSP
* `qc_gate_fail`: ใช้ set ที่เจตนา fail → กราฟหยุด, ส่ง `error` ชัดเจน

Simple takeaway: ครอบทั้ง reproducibility, คุณภาพสนาม, การต่อท่อ และ failure path

---

# 6.15 CI

`scenario-tests.yml`

```yaml
name: scenario-tests
on: [push, pull_request]
jobs:
  scn:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - run: cd apps/scenario && cargo test --all --locked
```

`engine-t2t3.yml` (มี MinIO service)

```yaml
services:
  minio:
    image: minio/minio
    env: { MINIO_ROOT_USER: heliox, MINIO_ROOT_PASSWORD: heliox123 }
    ports: ["9000:9000","9001:9001"]
    options: --health-cmd "curl -f http://localhost:9000/minio/health/ready || exit 1"
steps:
  - run: cd apps/engine && cargo test --features t2t3 --all
```

`e2e-small.yml` (เลือกเปิดทีหลัง เพราะช้า)

* spin pg+nats+minio → run orchestrator with mock LLM → assert final event

Simple takeaway: ทุก PR วิ่งเทสต์แยกชั้น—เร็วและเชื่อถือได้

---

# 6.16 ความปลอดภัย & Provenance

* Postgres **RLS**: ตาราง `scenario_sets`, `scenario_paths`, `qc_reports` ผูก `tenant_id`
* MinIO/S3: **SSE-S3** ได้ (ถ้าต้องการ), pre-signed URL เมื่อแชร์
* provenance: `{scenario_version, commit, rustc, build_time}` ฝังใน `manifest.json`

Simple takeaway: สนามและรายงานเป็นทรัพย์สิน มีเจ้าของ/ที่มา ตรวจสอบย้อนหลังได้

---

# 6.17 Failure Modes & Guards

* **QC ผ่านยาก**: เปิด ABC tuning (ลด SMM), log เหตุผลลง `fail_reasons`
* **IO choke**: อ่าน Parquet แบบ chunk (arrow/Polars), ขนานเป็น path-shard
* **ไม่ deterministic**: ทุกชั้นอิง seed เดียว, ห้าม RNG แบบ time-based
* **overfit สนามสังเคราะห์**: randomize family mix ต่อ run, CRN + antithetic + median-of-means, importance sampling สำหรับ extremes

Simple takeaway: รู้จุดพังและมีสวิตช์บรรเทา—ระบบจะไม่ “ล้มเงียบ”

---

# 6.18 Dev Runbook (Local-first)

```bash
# 1) ยกบริการฐาน (docker compose ของโปรเจกต์)
make dev  # pg + gateway + frontend + (optional) minio/nats

# 2) รัน scenario service
cd apps/scenario && cargo run

# 3) สร้างชุดเล็ก
curl -X POST :8092/v1/scenario-sets -H 'Content-Type: application/json' \
  -d @specs/xauusd_small.json

# 4) ตรวจ QC
curl :8092/v1/scenario-sets/<set_id>/qc

# 5) เริ่ม run กลยุทธ์ (ผ่าน gateway)
curl -X POST :8080/v1/runs -H 'Content-Type: application/json' \
  -d '{"prompt":"xauusd scalping","scenario_set_id":"<set_id>"}'

# 6) ตามดูอีเวนต์แบบ SSE
curl -N :8080/v1/runs/<trace_id>/events
```

Simple takeaway: ทั้งหมดวิ่งบนเครื่องคุณ—ได้ HSP โดยไม่ต้องแตะ AWS

---

# 6.19 BMAD Stories (ส่งให้ Claude Code)

## `stories/050-scenario-factory.md`

**Background:** ต้องมีสนามสังเคราะห์ที่ซื่อสัตย์และเร็ว
**Plan:** schema → sampler → gen → micro → parquet → qc → registry → REST
**DoD:** reproducible, qc pass (SMM≤0.25 & coverage≥0.9), API OK, tests/CI ผ่าน

## `stories/060-engine-t2-t3.md`

**Background:** ทดสอบบนสนามจริง (paths)
**Plan:** handlers `/t2` `/t3`, reader, metrics, limits, tests
**DoD:** `/t2` ≤5s (128 paths×2 cand), deterministic, metrics schema ถูกต้อง

Simple takeaway: แยกเป็นเรื่องเล็ก ๆ พร้อม DoD—Claude Code ทำงานทีละชิ้นจนสำเร็จ

---

# 6.20 ตัวอย่าง Spec ไฟล์เล็ก (xauusd\_small.json)

```json
{
  "asset":"XAUUSD","timeframe":"M1","horizon_bars":2048,"n_paths":128,
  "targets":{"kurtosis":[4.2,8.0],"skew":[-0.6,0.3],"absret_acf_lag1":[0.1,0.35],
             "hurst":[0.52,0.60],"leverage_corr":[-0.35,-0.05],"spread_bps":[8,20]},
  "generators":[
    {"name":"regime_gbm","weight":0.5,"params":{"mu":[-0.05,0.05],"sigma":[0.06,0.25],
      "switch_p":[0.003,0.01],"jump_p":[0.002,0.008],"jump_b":[0.003,0.02]}},
    {"name":"garch_11","weight":0.25,"params":{"omega":[1e-6,1e-5],"alpha":[0.05,0.15],"beta":[0.8,0.94]}},
    {"name":"sv_leverage","weight":0.25,"params":{"rho":[-0.6,-0.15],"vol_mean":[0.06,0.2],"vol_kappa":[0.05,0.2]}}
  ],
  "micro":{"spread_lognorm_mu":2.1,"spread_lognorm_sigma":0.5,"latency_ms":[50,120],
           "slippage":{"p0":0.75,"sigma":0.35}},
  "sampling":{"method":"lhs","seed":20250824}
}
```

Simple takeaway: ไฟล์เดียว สร้างสนาม dev-scale พร้อม QC ได้ทันที

---

## ปิดข้อ 6

คุณได้สเปก **Scenario Factory + QC (T2/T3 hookup)** ที่ **local-first** และ **cloud-ready**: deterministic, เร็ว, ประหยัด, ตรวจย้อนกลับได้ และเชื่อมเข้ากับ Orchestrator/Engine แบบเนียน ด้วย contracts เดียวกันทั้งระบบ

Simple takeaway: ข้อ 6 ทำให้ “สนามทดสอบของคุณ” แข็งแรงจริง—จากนี้ไปการคัด/ยืนยันกลยุทธ์จะน่าเชื่อถือและอธิบายได้ทุกบรรทัด.



มาถึง **ข้อ 7: Formal Verification + Release Gatekeeper (Safety & Evidence)** แบบ “ลงมือโค้ดได้ทันที”
โฟกัส: พิสูจน์ **no-lookahead / bounded risk / termination / leverage caps** แบบ machine-checkable, รวมผลกับ QC/T2-T3/งบ แล้วตัดสิน **PASS/FAIL/CONDITIONAL** ก่อนแพ็ก **HSP v1** และ (ถ้าตั้งค่าไว้) auto-deploy → Paper

---

# 7.1 เป้าหมาย & ขอบเขต

* บริการ **Formal** (แยก service) รับ **IR/Blueprint** → สร้าง **SMT model** (Z3) + static checks → ส่งคืน `VerificationReport`
* เพิ่มโหนดใน Orchestrator: `formal` และ `gate`
* ขีดเส้น **เกณฑ์ตัดสิน** จากข้อมูลจริงในฐาน (QC, T2/T3 metrics, งบ, Formal) → `ReleaseDecision`
* อัปเกรดแพ็ก **HSP จาก Lite → v1** (manifest+blueprint+metrics+formal\_report+tests)
* ทั้งหมด **local-first** (Docker) พร้อมสลับ cloud ทีหลัง

**Simple takeaway:** ข้อ 7 ทำให้ “มั่นใจและอธิบายได้” ว่ากลยุทธ์ไม่โกงเวลา, เสี่ยงอยู่ในกรอบ, จบแน่ และผ่านเกณฑ์เผยแพร่

---

# 7.2 ไดอะแกรมสถาปัตยกรรม (Macro → Meso → Micro)

## Macro

```
Orchestrator (LangGraph)
   ├─ t2 → t3    (Engine)
   ├─ formal     (Formal Service: static+SMT)
   └─ gate       (Release Gatekeeper)
         │
         └─ HSP v1 → Portfolio → (optional auto) Deploy: Paper
```

**Simple takeaway:** Formal อยู่ “หลัง” T2/T3 เพื่อประเมินบนตัวที่มีแววจริง และ “ก่อน” Gatekeeper เพื่อเป็นข้อบังคับ

## Meso – Formal Pipeline

```
Blueprint/IR → Static Analyzer → SMT Encoder (k-induction / bounded model) → Z3 → Report
     │               │
     │               └─ No-lookahead / Termination / Bounded leverage & DD
     └─ Type/Time checks, Read-set ≤ t-1, Cooldown ≥ 1, Risk caps present
```

**Simple takeaway:** ตรวจแบบถูกหลักสองชั้น: “เร็ว” (static) + “เข้ม” (SMT)

## Micro – Release Gate

```
Inputs: QC_report + T2/T3 metrics + Formal_report + Budget_ledger + Provenance
  └─ Rules: CVaR95, MaxDD, Stability, Reproducibility, Formal=PASS, QC thresholds
       └─ Decision: PASS / FAIL / CONDITIONAL(with actions)
            └─ Pack HSP v1 (+ tests/golden) → Publish → (maybe) Auto-Paper
```

**Simple takeaway:** ตัดสินบน “ข้อมูลจริงจากฐาน” เท่านั้น ไม่เชื่อ payload ลอย ๆ

---

# 7.3 โครงไฟล์ (เพิ่มบริการ + โหนด + schema)

```
apps/formal/                      # NEW: Formal Verification Service (Python + z3-solver)
  pyproject.toml
  formal/app.py                   # FastAPI: /health /verify
  formal/static_check.py          # DSL/IR static checks (no-lookahead, types, etc.)
  formal/smt_encoder.py           # IR → SMT (z3) + k-induction
  formal/counterexample.py        # Build CE trace when UNSAT fails
  formal/schemas.py               # pydantic: VerificationRequest/Response
  tests/{static_test.py, smt_test.py}

apps/orchestrator/src/nodes/formal.ts    # NEW
apps/orchestrator/src/nodes/gate.ts      # NEW

packages/contracts/src/verification.ts   # zod schema
packages/contracts/src/gate.ts           # zod schema

ops/db/init/0007_release_gate.sql        # tables: verifications, releases, decisions

stories/070-formal.md                    # BMAD story
stories/080-gatekeeper.md                # BMAD story
```

**Simple takeaway:** แยก service formal เป็นอิสระ เหมาะกับ local dev และ CI

---

# 7.4 Data Contracts

## 7.4.1 `VerificationRequest`

```ts
// packages/contracts/src/verification.ts
export const VerificationRequest = z.object({
  trace_id: z.string(),
  blueprint: Blueprint,  // จากข้อ 1
  ir: IR,                // IR ที่คอมไพล์แล้ว (ข้อ 5)
  bounds: z.object({
    k: z.number().min(128).max(8192).default(1024),   // steps for k-induction
    max_positions: z.number().default(8)
  }),
  assumptions: z.object({
    spread_bps_max: z.number().default(30),
    latency_bars_max: z.number().default(3),
  })
});
```

## 7.4.2 `VerificationReport`

```ts
export const VerificationReport = z.object({
  ok: z.boolean(),
  checks: z.object({
    no_lookahead: z.boolean(),
    termination: z.boolean(),
    bounded_leverage: z.boolean(),
    bounded_drawdown: z.boolean()
  }),
  method: z.enum(['static_only','k_induction','bounded_model']),
  k_used: z.number().optional(),
  ce_examples: z.array(z.object({
    step: z.number(),
    reason: z.string(),
    trace_uri: z.string().optional() // ถ้า dump เป็นไฟล์
  })).optional(),
  time_ms: z.number(),
  engine_version: z.string(),
  notes: z.string().optional()
});
```

## 7.4.3 `ReleaseChecklist` & `ReleaseDecision`

```ts
export const ReleaseChecklist = z.object({
  qc: z.object({ pass: z.boolean(), smm: z.number(), coverage: z.number() }),
  metrics: z.object({
    sharpe: z.number(), cvar95: z.number(), maxdd: z.number(),
    turnover: z.number(), stability: z.number() // corr across seeds/paths
  }),
  formal: VerificationReport,
  budget_ok: z.boolean(),
  reproducible: z.boolean(),
  thresholds: z.object({
    cvar95_min: z.number(), maxdd_max: z.number(), stability_min: z.number()
  })
});

export const ReleaseDecision = z.object({
  decision: z.enum(['PASS','FAIL','CONDITIONAL']),
  reasons: z.array(z.string()),
  required_actions: z.array(z.string()).optional(),
  expires_at: z.string().datetime().optional()
});
```

**Simple takeaway:** สคีมาแน่น—Claude Code parse/validate ได้ทันที

---

# 7.5 Formal Service (Python + FastAPI + Z3)

## 7.5.1 เส้นทาง API

* `POST /verify` → รับ `VerificationRequest` → run static → ถ้า ok → SMT (k-induction) → ส่ง `VerificationReport`
* `GET /health` → `{status: ok}`

## 7.5.2 Static Analyzer (หลัก ๆ)

* **Time index discipline**: ทุก node ต้องใช้ข้อมูล ≤ t-1 (ตรวจจาก dependency graph ของ IR)
* **Cooldown & Termination**: ต้องมี `cooldown_bars_min ≥ 1` และทุกออเดอร์มี path ปิดภายใน `k`
* **Risk presence**: ต้องมี `max_drawdown`, `max_concurrent`, guard sizing ไม่เกิน leverage X
* **Forbidden ops**: ห้ามใช้ “future bar” ฟังก์ชัน (เช่น `highest(high, lookahead)`), ห้าม join ข้ามสัญลักษณ์แบบ lag-mismatch

> Fail ตรงนี้ = `ok=false` ทันที (เร็วและชัด)

## 7.5.3 SMT Encoder (แก่น)

* โมเดลเป็น **transition system**:

  * state(t): `{pos_t, cash_t, equity_t, cooldown_t, ...}`
  * inputs(t): `{mid_t, bid_t, ask_t, vol_t,...}` (bounded ด้วย `assumptions`)
  * update rules จาก IR (entry/exit/filter/sizing) **ไม่ใช้ค่าที่ตนเองกำหนดในอนาคต**
* พิสูจน์:

  * **no\_lookahead**: ข้อกำหนดว่าฟังก์ชันสัญญาณใช้เฉพาะ `inputs(≤t-1)` → แปลงเป็น constraints บน index
  * **termination**: k-induction ว่า ถ้ามีสถานะ open → ภายใน ≤K จะกลับสู่ `pos=flat` (ด้วย cooldown+stop rules)
  * **bounded\_leverage**: ∀t: `|pos_t| * notional ≤ L_max * equity_t`
  * **bounded\_dd**: ∀t: `peak_equity - equity_t ≤ DD_max * peak_equity`

> ถ้า Z3 ให้ **SAT** ต่อ negation ของ property → สร้าง **counterexample trace** (CE) แล้วคืนใน report

**Simple takeaway:** Static จับเร็ว, SMT พิสูจน์เข้ม—ถ้าผิดมี CE ให้เห็นเป็นรูปธรรม

---

# 7.6 โหนด Orchestrator: `formal` & `gate`

## 7.6.1 `formal.ts`

* ดึง `blueprint+IR` จากฐาน
* POST `/verify` → Formal service
* เซฟผลลง `verifications` (DB) แบบ idempotent (`hash(trace_id, ir, bounds)`)
* `emit(trace_id, 'status', 'FORMAL', {...})` และ `emit('artifact','formal_report', uri)`

## 7.6.2 `gate.ts`

* โหลด: `qc_report`, `t2/t3 metrics`, `verification`, `budget_ledger`, `provenance`
* คำนวณ `stability`: corr ของผลลัพธ์ข้าม seeds/paths
* เทียบกับ thresholds (env/tenant policy)
* สร้าง `ReleaseChecklist` → คิด `ReleaseDecision`
* PASS → เรียก Engine `/pack` อัปเกรดเป็น **HSP v1** (เพิ่ม `formal_report.json` + `tests/golden/*`)
* Emit `final` + publish HSP ไป Portfolio

**Simple takeaway:** Gatekeeper ตัดสินจากฐานข้อมูล—ทุกเหตุผลมีหลักฐานเชิงตัวเลขพ่วงไฟล์

---

# 7.7 ฐานข้อมูล & RLS

`ops/db/init/0007_release_gate.sql`

```sql
CREATE TABLE IF NOT EXISTS verifications (
  id TEXT PRIMARY KEY,
  trace_id TEXT NOT NULL,
  method TEXT NOT NULL,
  ok BOOLEAN NOT NULL,
  checks JSONB NOT NULL,
  k_used INT,
  time_ms INT NOT NULL,
  report_uri TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  tenant_id TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS releases (
  id TEXT PRIMARY KEY,
  trace_id TEXT NOT NULL,
  checklist JSONB NOT NULL,
  decision JSONB NOT NULL,
  hsp_uri TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  tenant_id TEXT NOT NULL
);
-- RLS: tenant_id = current_setting('app.tenant') (ตามแนวทางเดียวกับตารางอื่น)
```

**Simple takeaway:** เก็บผลพิสูจน์และการตัดสิน “เป็นทางการ” พร้อมผูก tenant

---

# 7.8 HSP v1 (ไฟล์สุดท้าย)

```
hsp_v1.hspz  (zip/tar.zst)
  /manifest.json            # strategy_id, version, scenario_set_id, checksums
  /blueprint.json
  /metrics/
      t0.json, t1.json, t2.json, t3.json
  /formal_report.json
  /qc_report.json
  /tests/golden/
      seeds.json, replay_inputs.json, expected_metrics.json
  /provenance.json
```

**Simple takeaway:** ไฟล์เดียวที่พกไปไหนก็ได้—เปิดอ่านตรวจสอบย้อนหลังได้ทุกบิต

---

# 7.9 พรอมป์เทมเพลต (Formal-Explain Agent) – *เสริมเพื่อเอกสารอ่านรู้เรื่อง*

* **system**: “สรุปผล Formal เป็นภาษามนุษย์… แปลง CE ให้ผู้อ่านเข้าใจว่า fail อย่างไร/แก้อย่างไร”
* **user**: แนบ `VerificationReport` + snippet ของ IR node ที่ผิด

> ใช้เพื่อสร้างเอกสาร human-readable ใส่ใน HSP (`/formal_explain.md`) แต่ **ไม่ได้มีผลต่อการตัดสิน**

**Simple takeaway:** การตัดสินใช้กฎเครื่อง; LLM ช่วยอธิบายให้มนุษย์เข้าใจ

---

# 7.10 Tests & CI

## Unit (Formal)

* `static_no_lookahead_ok`: IR ที่ทุกฟังก์ชันใช้อินเด็กซ์ ≤ t-1 → pass
* `static_cooldown_missing`: ไม่มี cooldown → fail
* `smt_termination`: IR ง่าย ๆ ที่มี stop → prove within K
* `smt_bounded_leverage`: sizing เกินกรอบ → CE พร้อม step

## Integration

* Orchestrator run (mock engine/t2/t3) → `formal` ok → `gate` PASS → ได้ HSP v1
* `gate_fail_cvar`: ทำ metrics ให้ CVaR95 ต่ำกว่าเกณฑ์ → decision FAIL, reasons ชัด

## CI

* workflow `formal-tests.yml` (pytest + caching)
* e2e small flow (optional) พร้อม MinIO/PG/NATS

**Simple takeaway:** เทสต์ครอบ 1) กฎคงรูป, 2) พิสูจน์, 3) สายพานปล่อยงาน, 4) เส้นทางล้มเหลว

---

# 7.11 งบประมาณ & ประสิทธิภาพ

* Static check: \~10–50ms
* SMT (k-induction K≈1024): 0.2–1.5s (ขึ้นกับ IR) — มี timeout (เช่น 5s)
* Gatekeeper: <100ms (อ่านฐาน + คำนวณเล็กน้อย)
* Budget guard ฝั่ง orchestrator: หาก formal ใช้เวลานาน → emit “advice: simplify IR (nodes≤N)”

**Simple takeaway:** Formal ไม่เป็นคอขวด—เร็วพอในลูป dev ปกติ

---

# 7.12 Failure Modes & Guards

* **SMT timeout** → `ok=false`, reason: “timeout”, decision: CONDITIONAL (ให้ลดความซับซ้อน/ลด bound)
* **Static fail** → ห้ามข้าม (stop ทันที); emit CE/ตำแหน่ง node ที่ผิด
* **Inconsistent metrics** (payload vs DB) → Gate อ่านเฉพาะค่าใน DB; payload จะถูกเมิน
* **Reproducibility fail** → Gate FAIL; ต้องแพ็ก tests/golden ใหม่ให้ผ่าน

**Simple takeaway:** ทุกทางออกมีสวิตช์เซฟ—ไม่ให้ของ “ลวง/ไม่เสถียร” หลุดไป portfolio

---

# 7.13 Dev Loop (local-first)

```bash
# Formal service (Python)
cd apps/formal && uv run uvicorn formal.app:app --port 8093

# ยิงทดสอบ formal โดยตรง
curl -X POST :8093/verify -H 'Content-Type: application/json' -d @fixtures/verify_req.json | jq .

# Orchestrator รวม flow (มี t2/t3 แล้วจากข้อ 6)
curl -X POST :8080/v1/runs -d '{"prompt":"xauusd scalping","scenario_set_id":"scn_dev"}' \
  -H 'Content-Type: application/json'
curl -N :8080/v1/runs/<trace_id>/events
```

**Simple takeaway:** รัน formal แยกได้ หรือให้ orchestrator เรียกอัตโนมัติปลายสายก็ได้

---

# 7.14 BMAD Stories

## `stories/070-formal.md`

* **Background**: ต้องพิสูจน์ invariants สำคัญก่อนเผยแพร่
* **Plan**: FastAPI + static check + z3 encoder + tests + CI
* **DoD**: static/SMT tests ผ่าน, timeout guard, schema ok, report เก็บ DB

## `stories/080-gatekeeper.md`

* **Background**: รวมสัญญาทุกมิติ ตัดสินแบบกฎเครื่อง
* **Plan**: node `gate.ts` + thresholds + stability calc + HSP v1 pack
* **DoD**: PASS/FAIL/CONDITIONAL ทดสอบครบ + HSP v1 มีไฟล์ครบ

**Simple takeaway:** แตกงานเป็นชิ้นเล็กที่ตรวจรับได้—Claude Code ลงมือได้เลย

---

# 7.15 สิ่งที่ปรับได้ (Knobs)

* `FORMAL_K` (เช่น 1024 dev, 4096 prod), `FORMAL_TIMEOUT_MS`
* Gate thresholds ต่อ tier: `{cvar95_min, maxdd_max, stability_min, turnover_max}`
* Auto-Paper: `DEPLOY_AUTO_PAPER=true|false`, with probation hours
* Evidence verbosity: dump CE traces ลงไฟล์/MinIO หรือแสดงสรุปเท่านั้น

**Simple takeaway:** ปรับไม่กี่ปุ่ม—คุมความเข้มงวด/ความเร็ว/ความ “พูดภาษามนุษย์” ของรายงาน

---

## ปิดข้อ 7

คุณได้ **Formal Verification Service** + **Release Gatekeeper** ที่ต่อเข้ากับสายพาน T2/T3 อย่างเป็นระบบ—ตรวจสองชั้น (static+SMT), ตัดสินด้วยกฎเครื่องจากฐานข้อมูล, และแพ็ก **HSP v1** พร้อมหลักฐานครบชุด

**Simple takeaway:** หลังข้อ 7 ระบบของคุณ “ปลอดภัยและโปร่งใส” ระดับโปรดักชัน—พร้อมเปิด Paper/Live อย่างมั่นใจในข้อถัดไป.




มาต่อ “ข้อ 8: **Deploy Controller + Broker Hub + Paper/Live Runtime**” แบบจัดเต็ม ให้ Claude Code แค่อิมพลีเมนต์ตามสเปก—ไม่ต้องเดาเอง
โฟกัส: นำ **HSP v1** จากข้อ 7 ไป “รันจริง” ใน **PaperSim** และ **Live** ผ่าน **Broker Hub** แบบปลั๊กอิน, มี **Risk Guardian (runtime)**, **Observability/FinOps**, และ **Kill-switch** ครบ

---

## 8.1 เป้าหมาย & ขอบเขต

* บริการ **Deploy Controller** (Go) + **Broker Hub** (Go, ปลั๊กอิน)
* รองรับ **PaperSim** (local-first, deterministic) และ **Live** (เริ่มที่ OANDA Practice → Binance → MT5)
* ใช้ **HSP v1**: `manifest.json + blueprint.json + metrics + formal_report + deploy.descriptor.json`
* ระหว่างรันมี **Runtime Risk Guards** (pre-trade/post-trade), **Budget Guard**, **SSE/WS logs** และ **Kill-all**
* เก็บทุกเหตุการณ์ใน **Audit/Execution DB** + Telemetry (OTel) + ค่าต้นทุน (FinOps)
* ทำงาน **local-first** (MinIO + Postgres + Docker) และสลับ Cloud ได้ภายหลังด้วยการแก้ ENV เท่านั้น

**Simple takeaway:** ข้อ 8 ทำให้กด “Deploy→Run” ได้จริงทั้ง Paper/Live แบบปลอดภัย โปร่งใส และย้อนตรวจได้

---

## 8.2 ภาพรวมสถาปัตยกรรม (Macro)

```
┌────────────── Heliox UI/API ──────────────┐
│  Portfolio • Deploy • Monitor • Kill • Log│
└─────────────┬─────────────┬───────────────┘
              │             │
       Deploy Controller    │   (SSE/WS events)
          (Go, Gin)         ▼
              │        Live Console / Logs
              ▼
        Broker Hub (Go)
   ┌────────────┼────────────┬───────────────┐
   │            │            │               │
PaperSim     OANDA v20   Binance (Spot/Fut)  MT5 Adapter
(local)     (Practice)     (phase-in)        (phase-in)
   │            │            │               │
   ▼            ▼            ▼               ▼
Market Feed  HTTP/gRPC   HTTP/gRPC         TCP/Bridge
(Replay/RT)  (brokers)   (brokers)         (EA bridge)
```

**Simple takeaway:** UI สั่ง Deploy → Controller ประสาน → Broker Hub เลือกปลั๊กอิน → รัน/การ์ด/ส่งอีเวนต์กลับ UI

---

## 8.3 Data Contracts หลัก

### 8.3.1 `deploy.descriptor.json` (ใน HSP v1)

```json
{
  "runtime": { "mode": "paper|live", "broker": "papersim|oanda|binance|mt5" },
  "symbols": ["XAUUSD"],
  "risk_tier": "balanced",
  "safeguards": {
    "max_daily_loss": 0.03,
    "max_weekly_loss": 0.07,
    "position_limit": 3,
    "max_notional": 50000,
    "kill_on_vol_spike": true
  },
  "replay": { "scenario_set_id": "scn_...", "speed": 1.0, "from_bar": 0 }  // สำหรับ paper
}
```

**Simple takeaway:** HSP ระบุ “รันยังไง” ชัดเจน—ไม่ต้องแต่งค่าเพิ่มจนงง

### 8.3.2 Unified Order/Execution Model (ใช้กับปลั๊กอินทั้งหมด)

```ts
type Side = 'BUY'|'SELL';
type OrdType = 'MARKET'|'LIMIT'|'STOP'|'STOP_LIMIT';
type TimeInForce = 'GTC'|'IOC'|'FOK';

interface Order {
  id: string;                // client id (idempotent key)
  symbol: string;
  side: Side;
  type: OrdType;
  qty: number;               // base units (or contracts)
  price?: number;            // for LIMIT/STOP_LIMIT
  stopPrice?: number;        // for STOP/STOP_LIMIT
  tif: TimeInForce;
  meta?: Record<string, any>;
}

interface ExecutionReport {
  orderId: string;
  status: 'ACCEPTED'|'PARTIAL'|'FILLED'|'CANCELLED'|'REJECTED';
  filledQty: number;
  avgPrice?: number;
  fees?: number;
  ts: string; // ISO-8601
  brokerRef?: string;
}

interface Position {
  symbol: string;
  qty: number;         // signed
  avgPrice: number;
  unrealizedPnL: number;
}
```

**Simple takeaway:** หนึ่งสัญญาเดียว—ทุก broker แปลงเข้า/ออกตามนี้

---

## 8.4 Deploy Controller (Go, Gin)

### 8.4.1 REST API (Gateway-facing)

* `POST /v1/deployments`
  **Body:** `{ hsp_uri, mode, broker, account_ref?, capital?, overrides? }`
  **Resp:** `{ deploy_id, status: 'starting' }`
* `GET /v1/deployments/:id` → รายละเอียดสถานะล่าสุด
* `POST /v1/deployments/:id/kill` → kill-all, ปิดทุก order/position
* `GET /v1/deployments/:id/events` → **SSE**: `status|risk|order|fill|error|budget|heartbeat`

**Simple takeaway:** 4 endpoint จบ—เริ่ม/ดู/หยุด/ติดตาม (SSE)

### 8.4.2 Sequence (จากกด Deploy)

```
UI → POST /deployments {HSP} 
    → Controller: validate HSP + register deployment
    → load deploy.descriptor + safeguards
    → spin runtime session (goroutine):
         ├─ attach Budget Guard (per-tenant caps)
         ├─ hydrate state (positions, limits)
         ├─ connect BrokerHub(broker)
         ├─ stream signals (จาก Engine runtime หรือ IR evaluator)
         ├─ pre-trade Risk Checks → send order
         ├─ listen ER/Fills → update PnL/limits
         ├─ emit SSE events + persist audit
         └─ on breach/error ⇒ kill & finalize
```

**Simple takeaway:** Controller คือ “ผู้จัดการรันไทม์” มี Risk & Budget guard คร่อมทุกคำสั่ง

---

## 8.5 Broker Hub (Go) — ปลั๊กอิน

### 8.5.1 อินเทอร์เฟซ

```go
type Adapter interface {
    Name() string
    Connect(ctx context.Context, cfg map[string]any) error
    Account(ctx context.Context) (AccountInfo, error)
    Send(ctx context.Context, ord Order) (string /*brokerRef*/, error)
    Cancel(ctx context.Context, clientOrderID string) error
    StreamExec(ctx context.Context, ch chan<- ExecutionReport) error
    Positions(ctx context.Context) ([]Position, error)
    Close() error
}
```

**Simple takeaway:** ปลั๊กอิน broker ใหม่ = implement interface นี้ไฟล์เดียว

### 8.5.2 ปลั๊กอินเริ่มต้น

* **PaperSim** (จำลอง):

  * **Matching**: mid/bid-ask ตามโหมด, latency & slippage จาก `deploy.descriptor`
  * **Partial fills** & **queue depth** แบบง่าย (proportional to range)
  * **Replay source**:

    * A) ScenarioSet (T2/T3 paths) → เดินตาม `speed`/`from_bar`
    * B) Live quotes (optional ภายหลัง)
* **OANDA v20 Practice**:

  * REST/stream mapping → unified model; แนะนำเริ่มเพราะออกบัญชีฟรี
* **Binance** (Spot/Futures):

  * เริ่มจาก Spot (ง่ายกว่า) → Futures ทีหลัง
* **MT5 Adapter** (phase-in):

  * bridge → EA/Manager API หรือ TCP bridge (เรากำหนด mini-protocol)

**Simple takeaway:** เริ่ม PaperSim แน่น ๆ + OANDA Practice (ทุน 0) → ค่อยต่อ Binance/MT5

---

## 8.6 Runtime Risk Guardian (Pre/Post trade)

### 8.6.1 Pre-trade

* `max_notional`, `position_limit`, `max_concurrent`, `symbol whitelist`, `price bands` (reject orders >±x% จาก mid), `cooldown`
* ตรวจ **budget** (token/compute/network) ก่อนส่ง order (ถ้า LLM/engine on-line)

### 8.6.2 Post-trade / Streaming

* `max_daily_loss`, `max_weekly_loss`, `drawdown guard` (real-time)
* `volatility spike` (จาก realized vol/ATR) → freeze / tighten bands
* `slippage guard` (ค่าเฉลี่ย + k\*σ) → ถ้าหลุด range ติดต่อกัน N ครั้ง → halt

**Simple takeaway:** การ์ด 2 ชั้น—กันผิดก่อนส่ง และหยุด/หดวงต่อเนื่องถ้าโลกไม่เป็นมิตร

---

## 8.7 PaperSim Spec (Local-first)

* **เวลาจำลอง**: เดินบาร์ M1/M5 จาก Parquet T2/T3; internal clock = bar index
* **ราคา**: mid/bid-ask จาก path; **latency** = shift index L; **slippage** mixture; **partial fill** logistic by range
* **Order types**: MARKET/LIMIT/STOP/STOP\_LIMIT; TIF: GTC/IOC/FOK
* **ค่าธรรมเนียม**: คงที่หรือเป็น bps ใน `deploy.descriptor`
* **Determinism**: seeds จาก HSP + path นำเข้า = ผลเหมือนเดิมทุกครั้ง

**Simple takeaway:** PaperSim = “โลก sandbox” ที่ทำซ้ำได้—จับ bug และสื่อสารคาดหวังให้เทรดเดอร์ชัด

---

## 8.8 การประเมินผลระหว่างรัน

* **Runtime KPIs** (SSE & DB):

  * `equity`, `PnL`, `maxDD`, `exposure`, `turnover`, `winrate`, `slippage_mean`, `fill_ratio`, `latency_obs`
* **SLOs**:

  * SSE gap < 1s, 99p order-ack < 200ms (PaperSim) / < broker SLA (Live)
* **Drift flags**:

  * เมตริกปัจจุบัน vs HSP baselines (T2/T3) ± tolerance
  * ถ้าเบี่ยงมาก → emit `advice: reduce size / halt`

**Simple takeaway:** ไม่ใช่แค่ “วิ่ง”—แต่ “รู้ว่ากำลังหลุดจากที่พิสูจน์ไว้ไหม”

---

## 8.9 Observability & FinOps

* **OTel**: spans: `deploy.start`, `adapter.connect`, `order.send`, `fill.recv`, `risk.guard`, `kill.all`
* **Metrics**: `orders_rate`, `fills_latency_ms`, `slippage_bps`, `dd_pct`, `budget_used`
* **Logs**: structured JSON (sampled)
* **FinOps**: บันทึก **call LLM/engine** และ **network/fees** ต่อ deployment → `cost_ledger`

**Simple takeaway:** เห็นครบ—ดีบั๊กง่าย และรู้ต้นทุนจริงก่อนขึ้น Cloud

---

## 8.10 UI/UX Hook (loveable-style)

* Panel ซ้าย: Chat/Run timeline
* Panel กลาง: SSE log และ status steps: `CONNECT → SYNC → RUNNING → HALT/END`
* Panel ขวา (Preview card):

  * Strategy avatar + HSP summary
  * ปุ่ม: **Pause/Resume**, **Kill**, **Optimize**, **Export Report**
  * Gauge: `DD`, `Sharpe (live est)`, `CVaR est`, `Budget`
* Hover ที่เหตุการณ์: เปิด **Audit detail** (order → fill → guard decisions)

**Simple takeaway:** เทรดเดอร์ “ดูทันทีว่ามีอะไรเกิดขึ้น”—พร้อมกด action สำคัญแบบไม่งง

---

## 8.11 โครงสร้างโค้ด (เพิ่มเข้า monorepo)

```
apps/deployctl/                 # Deploy Controller
  go.mod
  cmd/server/main.go
  internal/http/{router.go,sse.go}
  internal/core/{runner.go,risk.go,budget.go}
  internal/hub/{hub.go,adapter_papersim.go,adapter_oanda.go,adapter_binance.go,adapter_mt5.go}
  internal/store/{db.go,models.go}
  internal/telemetry/{otel.go,metrics.go}

ops/db/init/0008_deployments.sql  # ตาราง deployments, orders, fills, positions, budgets

apps/frontend/src/routes/(app)/deploy/[id]/+page.svelte  # SSE viewer
apps/frontend/src/lib/api/deploy.ts                      # client helpers
```

**Simple takeaway:** Controller + Hub แยกชัด—ขยาย broker ใหม่ได้โดยไม่แตะเส้นเลือดใหญ่

---

## 8.12 ตารางฐานข้อมูล (สรุป)

```sql
-- deployments (หัวรัน)
(id, hsp_uri, mode, broker, status, started_at, ended_at, tenant_id, safeguards_json, budget_snapshot)

-- orders (client perspective)
(id, deploy_id, symbol, side, type, qty, price, tif, ts, meta)

-- exec_reports (broker perspective)
(id, order_id, status, filled_qty, avg_price, fees, ts, broker_ref)

-- positions
(id, deploy_id, symbol, qty, avg_price, unrealized_pnl, ts)

-- runtime_metrics
(id, deploy_id, ts, equity, pnl, maxdd, exposure, turnover, slippage_mean, fill_ratio, latency_obs)

-- budget_ledger
(id, deploy_id, ts, category, unit_cost, qty, total)
```

**Simple takeaway:** แยก “สิ่งที่เราส่ง” (orders) กับ “สิ่งที่โบรกตอบ” (exec\_reports) ชัดเจน

---

## 8.13 ตัวอย่างโค้ด (Go) — SSE skeleton

```go
// internal/http/sse.go
func (s *Server) Events(c *gin.Context) {
  id := c.Param("id")
  ch := s.Core.Subscribe(id)
  c.Stream(func(w io.Writer) bool {
    if ev, ok := <-ch; ok {
      c.SSEvent(ev.Type, ev.Payload)
      return true
    }
    return false
  })
}
```

**Simple takeaway:** UI subscribe เดียว ได้เหตุการณ์ทั้งหมดแบบเรียลไทม์

---

## 8.14 Test & CI

### Unit

* Risk guards: ปฏิเสธ order ที่เกิน `max_notional`, `position_limit`
* PaperSim fills: partial / latency / slippage ถูกคณิต
* Adapter mocks: map order → broker payload ได้

### Integration

* Deploy → PaperSim (Scenario replay) → ได้ fills/positions ตรงกับ expectation
* Kill-all: สั่ง kill แล้วไม่มี open positions เหลือ

### E2E (เลือกเปิด)

* Orchestrator ส่ง HSP v1 → Deploy Controller → Broker Hub PaperSim → monitor → kill
* ติด drift flag เมื่อ slippage/vol เกิน tolerance

**Simple takeaway:** เทสต์ครอบเส้นทางจริง—มั่นใจว่ากดแล้ว “วิ่งได้” และ “หยุดได้”

---

## 8.15 งบประมาณ & ประสิทธิภาพ

* PaperSim: >10k orders/นาที (single host) ได้สบาย (SIMD + batch match)
* SSE: <1s latency; event backlog มี backpressure
* Live: เคารพ rate limit โบรก (configurable); retry with backoff

**Simple takeaway:** เพียงพอสำหรับ dev/prod ระดับต้น—ขยายด้วย sharding ได้ภายหลัง

---

## 8.16 Failure Modes & Playbooks

* **Broker disconnect** → auto-reconnect + exponential backoff; ถ้าเกิน N ครั้ง → HALT
* **Risk breach** → Kill-all → Finalize → ส่งรายงาน
* **Clock drift (PaperSim)** → ใช้ bar index เท่านั้น (ไม่ใช้ wall-clock)
* **Idempotency** → Order ID = hash(run+seq); การส่งซ้ำต้อง “no-op”
* **Budget exceed** → pause LLM/engine calls, ลด frequency metrics, แจ้งเตือน

**Simple takeaway:** มีเบรกมือและคู่มือดับเพลิงทุกมุม

---

## 8.17 Dev Runbook (Local-first)

```bash
# 1) บูตฐาน (pg+minio)
make dev

# 2) รัน Deploy Controller
cd apps/deployctl && go run ./cmd/server

# 3) ส่ง HSP v1 (จากข้อ 7) ไป deploy แบบ PaperSim
curl -X POST :8081/v1/deployments \
  -H 'Content-Type: application/json' \
  -d '{"hsp_uri":"s3://minio/heliox/hsp/tr_abc/hsp_v1.hspz","mode":"paper","broker":"papersim"}'

# 4) เปิด SSE ดูเหตุการณ์
curl -N :8081/v1/deployments/<deploy_id>/events

# 5) Kill-all
curl -X POST :8081/v1/deployments/<deploy_id>/kill
```

**Simple takeaway:** ทั้งหมดทำในเครื่องคุณได้—ไม่มี AWS ก็รันครบลูป

---

## 8.18 BMAD Stories (ส่งให้ Claude Code)

* `stories/090-deploy-controller.md`
  **DoD:** REST + SSE + runner + guards ผ่านเทสต์; kill-all ทำงาน; audit persist ครบ
* `stories/100-broker-hub-papersim.md`
  **DoD:** Adapter PaperSim เติม; replay จาก Parquet; deterministic tests ผ่าน
* `stories/110-broker-oanda-practice.md`
  **DoD:** Connect/Send/Stream/Cancel ครบ; rate-limit เคารพ; sandbox account doc
* `stories/120-runtime-risk-guards.md`
  **DoD:** pre/post guards; breach→halt; logs/metrics ครบ

**Simple takeaway:** แตกเป็นงานเล็กพร้อม DoD ชัด—Claude Code ทำทีละสตอรี่จนฟีเจอร์สมบูรณ์

---

## 8.19 ค่าที่ปรับได้ (Knobs)

* `DEPLOY_SSE_BUFFER`, `ORDER_RETRY_MAX`, `BACKOFF_MS`
* Risk thresholds ต่อ tier (`safe/balanced/aggressive`)
* PaperSim: `replay.speed`, `latency/ slippage` factors
* Live: `rate_limit`, `heartbeat_interval`, `cancel_on_disconnect`

**Simple takeaway:** มีสวิตช์ไม่กี่อันที่ครอบทั้งความเร็ว ความเสี่ยง และ UX

---

### ปิดข้อ 8

คุณได้ “โครงกระดูกโปรดักชัน” ของ **การรันกลยุทธ์**: จาก HSP → Deploy → Paper/Live → Monitor/Guard/Kill พร้อมสัญญา ข้อมูล และเทสต์ที่ทำซ้ำได้ในเครื่อง วันนี้เริ่มจาก **PaperSim + OANDA Practice** ก่อน—พรุ่งนี้ต่อ **Binance/MT5** โดยไม่แตะสัญญาหลัก

**Simple takeaway:** ข้อ 8 เปลี่ยนของที่พิสูจน์มาแล้วให้ “วิ่งจริง” อย่างปลอดภัยและสวยงาม—พร้อมส่งมอบให้เทรดเดอร์ตั้งแต่วันแรก.









ต่อด้วย **ข้อ 9: Prompt Templates (Claude/OpenAI) — 7 เอเจนต์** แบบ “ลงมือใช้ได้ทันที”
โฟกัส: ทำให้ **Claude Code / OpenAI** “ตอบ JSON ตามสคีมาเดียวกัน” ทุกครั้ง, มี self-check, budget-aware, และไม่หลุด chain-of-thought

---

# 9.0 กติกากลางของทุกเอเจนต์ (Prompt Contract)

**A. รูปแบบคำตอบ (บังคับ):**

* *ต้องตอบเป็น JSON เท่านั้น* ตรงตามสคีมาที่แนบ (strict)
* ห้ามมีคอมเมนต์/คำอธิบาย/บรรทัดอื่นนอก JSON
* ฟิลด์ร่วมทุกเอเจนต์:

  ```json
  {
    "trace_id": "tr_...",
    "agent": "architect|synthesizer|qc_planner|formal_llm|gatekeeper|cost_guardian|style_qa",
    "version": "9.0.0",
    "status": "ok|needs_input|error",
    "data": { /* payload ตามสคีมาของเอเจนต์นั้น ๆ */ },
    "errors": []
  }
  ```

**B. Self-check ก่อนส่ง (ใน System prompt):**

* “Validate against the JSON Schema. If validation fails, FIX the JSON and re-validate. Return only the final valid JSON.”

**C. No chain-of-thought:**

* ใช้คำสั่ง: “Do not reveal chain-of-thought. Provide final JSON only.”

**D. Budget-aware:**

* ทุกเอเจนต์รับพารามิเตอร์ `budget_hint` (tokens/ms) และให้ประมาณการในผลลัพธ์ `cost_estimate` (ตัวเลขหยาบๆ สำหรับ FinOps)

**E. Determinism:**

* ใช้ `seed` + `temperature/top_p` คงที่ต่อเอเจนต์ (ตารางพารามิเตอร์ด้านล่าง)

**F. Stop-sequences:**

* กำหนด `stop: ["```", "</json>", "</end>"]` (กัน text แปลกปลอม)

**Simple takeaway:** ทุกเอเจนต์ “พูดภาษาเดียวกัน”—JSON เท่านั้น, validate เอง, ประหยัดงบ, หยุดการพล่าม

---

# 9.1 LLM Adapter (OpenAI + Claude) — JSON-only

> ทำให้ Claude Code เรียก LLM ใดก็ได้ผ่านอินเทอร์เฟซเดียว

```ts
// packages/llm/adapter.ts
import { z } from "zod";

export type LLMParams = {
  model: "openai:gpt-4.1" | "openai:gpt-4o" | "anthropic:claude-3.5" | "anthropic:claude-3-opus";
  temperature: number;
  top_p?: number;
  seed?: number;
  max_tokens?: number;
};

export async function jsonCall(
  sys: string,
  user: string,
  schema: Record<string, any>,   // JSON Schema
  params: LLMParams
): Promise<any> {
  if (params.model.startsWith("openai:")) {
    // OpenAI — JSON schema mode (Responses API style)
    const res = await fetch(process.env.OPENAI_URL!, {
      method: "POST",
      headers: { "Authorization": `Bearer ${process.env.OPENAI_API_KEY!}`, "Content-Type": "application/json" },
      body: JSON.stringify({
        model: params.model.replace("openai:", ""),
        messages: [{ role: "system", content: sys }, { role: "user", content: user }],
        response_format: { type: "json_schema", json_schema: { name: "HelioxSchema", schema, strict: true } },
        temperature: params.temperature, top_p: params.top_p ?? 1, seed: params.seed, max_output_tokens: params.max_tokens ?? 2048
      })
    });
    const j = await res.json();
    return JSON.parse(j.output?.[0]?.content?.[0]?.text ?? j.choices?.[0]?.message?.content);
  } else {
    // Anthropic — JSON only (beta format)
    const res = await fetch(process.env.ANTHROPIC_URL!, {
      method: "POST",
      headers: { "x-api-key": process.env.ANTHROPIC_API_KEY!, "anthropic-version": "2023-06-01", "Content-Type": "application/json" },
      body: JSON.stringify({
        model: params.model.replace("anthropic:", ""),
        system: sys,
        messages: [{ role: "user", content: user }],
        // ขอสัญญา JSON เท่านั้น
        metadata: { heliox: "json_only" },
        temperature: params.temperature, top_p: params.top_p ?? 1, max_tokens: params.max_tokens ?? 2048,
        // ใช้ JSON discipline ผ่านคำสั่งใน prompt + post-parse validation
      })
    });
    const j = await res.json();
    const text = j?.content?.[0]?.text ?? j?.content?.[0]?.input_json ?? j?.content?.[0]?.json;
    return JSON.parse(text);
  }
}
```

**หมายเหตุ:** เราบังคับ JSON ผ่าน prompt + post-parse; ฝั่ง OpenAI ใช้ `response_format: json_schema` ได้โดยตรง, ฝั่ง Anthropic ทำได้ด้วยคำสั่งและตรวจซ้ำ

**Simple takeaway:** เรียกโมเดลไหนก็ได้ แต่ผลลัพธ์ “เป็น JSON ถูกสคีมา” เสมอ

---

# 9.2 พารามิเตอร์ LLM ต่อเอเจนต์ (แนะนำ)

| Agent               | temperature | top\_p |  seed | max\_tokens |
| ------------------- | ----------: | -----: | ----: | ----------: |
| Strategy Architect  |         0.2 |    0.9 | fixed |        2000 |
| Synthesizer (CEGIS) |         0.4 |   0.95 | fixed |        2200 |
| QC Planner          |         0.2 |    0.9 | fixed |        1200 |
| Formal (LLM assist) |         0.0 |    1.0 | fixed |        1500 |
| Release Gatekeeper  |         0.0 |    1.0 | fixed |        1200 |
| Cost Guardian       |         0.0 |    1.0 | fixed |         800 |
| Style QA            |         0.1 |    0.9 | fixed |        1200 |

**Simple takeaway:** สร้างสรรค์ให้แค่ตรงที่ควร (Synth); ที่เหลือให้ “นิ่ง” และ “เที่ยงตรง”

---

# 9.3 สคีมารวม (Zod/JSON Schema)

> เก็บไว้ที่ `packages/contracts/src/agents.ts` แล้ว export JSON Schema ให้ Adapter

```ts
import { z } from "zod";

export const Evidence = z.object({
  summary: z.string(),
  key_points: z.array(z.string()).max(12)
});

export const Blueprint = z.object({
  name: z.string(),
  family: z.enum(["SMC","ICT","Trend","MR","Grid","Custom"]),
  timeframe: z.enum(["M1","M5","M15","H1"]),
  signals: z.array(z.object({
    id: z.string(),
    kind: z.enum(["entry","exit","filter"]),
    expr: z.string(),          // DSL expr no-lookahead
    params: z.record(z.any())
  })),
  sizing: z.object({
    method: z.enum(["fixed","atr_frac","vol_frac"]),
    max_concurrent: z.number().int().min(1).max(10),
    cooldown_bars_min: z.number().int().min(1).max(50)
  }),
  risk: z.object({
    stop_loss_bps: z.number().min(0),
    take_profit_bps: z.number().min(0),
    max_drawdown_pct: z.number().min(0.01).max(0.5),
    leverage_max: z.number().min(1).max(20)
  }),
  invariants: z.array(z.enum(["no_lookahead","termination","bounded_risk"]))
});

export const Candidate = z.object({
  id: z.string(),
  blueprint_name: z.string(),
  params: z.record(z.union([z.number(), z.string(), z.boolean()])),
  diversity_vec: z.array(z.number()).min(3).max(12),   // latent for selection
  rationale: z.string().max(400)
});

export const QcPlan = z.object({
  scenario_set_id: z.string(),
  path_budget: z.number().int().min(16).max(2048),
  selection: z.array(z.object({
    path_id: z.string(),
    weight: z.number().min(0),
    tags: z.array(z.string())
  })),
  coverage_target: z.number().min(0.7).max(1.0),
  rationale: z.string()
});

export const FormalReport = z.object({
  summary: z.string(),
  checks: z.object({
    no_lookahead: z.boolean(),
    termination: z.boolean(),
    bounded_risk: z.boolean()
  }),
  notes: z.string().optional()
});

export const Decision = z.object({
  pass: z.boolean(),
  reasons: z.array(z.string()),
  next_steps: z.array(z.string()).optional()
});

export const CostRecord = z.object({
  estimate_tokens_in: z.number(),
  estimate_tokens_out: z.number(),
  estimate_usd: z.number(),
  notes: z.string().optional()
});

export const StyleQAReport = z.object({
  family: z.enum(["SMC","ICT","Trend","MR","Grid","Custom"]),
  checklist: z.array(z.object({
    id: z.string(),
    desc: z.string(),
    passed: z.boolean(),
    evidence: z.string().optional()
  })),
  score: z.number().min(0).max(1)
});

export const Envelope = (inner: z.ZodTypeAny) => z.object({
  trace_id: z.string(),
  agent: z.string(),
  version: z.string(),
  status: z.enum(["ok","needs_input","error"]),
  data: inner,
  errors: z.array(z.string())
});
```

**Simple takeaway:** เอเจนต์ไหนก็ห่อด้วย `Envelope(schema)` เดียวกัน—รับ-ส่งง่าย

---

# 9.4 Prompt Shell มาตรฐาน (ทุกเอเจนต์)

> ไฟล์: `.claude/agents/_shell.md`

**System**

```
You are HELIOX Agent: {agent_name}.
Return JSON ONLY that matches the provided JSON Schema. 
Do not reveal chain-of-thought. Do not output text outside JSON.
Validate against the schema before responding; if invalid, FIX and re-validate.
Enforce invariants: no lookahead, cooldown≥1 bar, max_concurrent within risk tier.
Budget-aware: include a rough cost_estimate based on input size.
```

**Developer** *(optional เพิ่มเติมต่อเอเจนต์)*

```
- Use concise fields. 
- Never invent database numbers; only consume facts passed in <FACTS/> block (if any).
- When unsure, set `status="needs_input"` and list missing fields in `errors[]`.
```

**User**

```
<CONTEXT>
{user_payload_json}
</CONTEXT>
<SCHEMA>
{json_schema_here}
</SCHEMA>
<FACTS>
{factual_json_if_any}
</FACTS>
Respond in JSON only.
```

**Simple takeaway:** เปลือกเดียว ครอบทุกเอเจนต์—สลับเฉพาะ schema/ข้อกำกับ

---

# 9.5 Templates รายเอเจนต์ (พร้อมตัวอย่างสั้น)

## 9.5.1 Strategy Architect

**System (เพิ่มเฉพาะทาง):**

```
Synthesize a minimal-description-length (MDL) Blueprint.
- Prefer fewer signals with strong semantics.
- Enforce invariants: no_lookahead, termination, bounded_risk.
- Populate `evidence.summary` with 2-4 sentences.
```

**User payload (ตัวอย่าง):**

```json
{
  "prompt": "xauusd scalping, M1, small but frequent profits, low DD",
  "risk_tier": "balanced",
  "scenario_context": { "stylized": {"kurtosis": [4.5,8], "hurst":[0.52,0.6]} }
}
```

**Schema:** `Envelope(Blueprint)`

**ตัวอย่างผลลัพธ์ (ย่อ):**

```json
{
  "trace_id":"tr_001","agent":"architect","version":"9.0.0","status":"ok","data":{
    "name":"XAU-MicroPulse","family":"ICT","timeframe":"M1",
    "signals":[
      {"id":"ent1","kind":"entry","expr":"breakout(lowest(low,12),+spread)", "params":{"lookback":12}},
      {"id":"flt1","kind":"filter","expr":"atr(14)<pctl(atr,30)","params":{"lookback":14}},
      {"id":"ext1","kind":"exit","expr":"trailing_atr(6,1.2)","params":{"lookback":6,"mult":1.2}}
    ],
    "sizing":{"method":"atr_frac","max_concurrent":2,"cooldown_bars_min":3},
    "risk":{"stop_loss_bps":35,"take_profit_bps":0,"max_drawdown_pct":0.2,"leverage_max":5},
    "invariants":["no_lookahead","termination","bounded_risk"]
  },"errors":[]
}
```

**Simple takeaway:** สร้าง DSL/AST ที่ *เรียบแต่แรง* และเคารพกฎ

---

## 9.5.2 Synthesizer (CEGIS)

**System (เพิ่ม):**

```
Propose 6–12 diverse Candidates from the gene space implied by the Blueprint.
Use LHS for numeric params; ensure diversity_vec far apart (approx cosine).
For each candidate include a one-paragraph rationale.
```

**Input:** Blueprint + `budget_hint`
**Schema:** `Envelope(z.object({ candidates: z.array(Candidate) , cost_estimate: CostRecord}))`

**ตัวอย่างผลลัพธ์ (ย่อ):**

```json
{
 "trace_id":"tr_001","agent":"synthesizer","version":"9.0.0","status":"ok",
 "data":{
   "candidates":[
     {"id":"cand_01","blueprint_name":"XAU-MicroPulse",
      "params":{"lookback":10,"atr_frac":0.7,"cooldown":3},
      "diversity_vec":[-0.12,0.83,0.41],"rationale":"..."},
     {"id":"cand_02","blueprint_name":"XAU-MicroPulse",
      "params":{"lookback":14,"atr_frac":0.5,"cooldown":4},
      "diversity_vec":[0.56,-0.22,0.78],"rationale":"..."}
   ],
   "cost_estimate":{"estimate_tokens_in":1300,"estimate_tokens_out":800,"estimate_usd":0.03}
 },"errors":[]
}
```

**Simple takeaway:** เสนอชุดพารามิเตอร์ “หลากหลายและมีเหตุผล” พร้อมค่าใช้จ่ายคาดการณ์

---

## 9.5.3 QC Planner

**System (เพิ่ม):**

```
Select a minimal set of scenario paths to achieve coverage≥target while minimizing path_budget.
Use tags from stylized QC: extremes(fat_tails), trend, mean-revert, vol_high, vol_low.
Return a weighted list; heavier weights get sampled more frequently during T2/T3.
```

**Input:** `scenario_set_id`, coverage target, budget hint
**Schema:** `Envelope(QcPlan)`

**Simple takeaway:** เลือกสนามทดสอบอย่างชาญฉลาด—ครอบคลุมด้วยงบต่ำ

---

## 9.5.4 Formal Verifier (LLM Assist)

> *หมายเหตุ:* ข้อนี้เป็นตัวช่วย *อธิบาย/เตรียม* ไม่ใช่ผู้ตัดสินสุดท้าย (ผู้พิสูจน์จริงอยู่ที่บริการ Formal ในข้อ 7)

**System (เพิ่ม):**

```
Given the Blueprint and a list of IR rules, check for likely violations of
(no_lookahead, termination, bounded_risk).
Return a FormalReport with boolean checks and a short summary.
If uncertain, set field to false and explain briefly.
```

**Schema:** `Envelope(FormalReport)`

**Simple takeaway:** LLM เป็น “lint ทางตรรกะ” ก่อนส่งเข้าตู้พิสูจน์จริง

---

## 9.5.5 Release Gatekeeper

**System (เพิ่ม):**

```
You must read facts from the <FACTS/> block only (metrics from DB, qc_report, verification_report).
Compare against thresholds; never copy claims from agents. Decide PASS/FAIL.
Populate `reasons[]` precisely; if FAIL, include actionable `next_steps[]`.
```

**Input FACTS (ตัวอย่าง):**

```json
{
  "qc":{"pass":true,"smm":0.19,"coverage":0.93},
  "metrics":{"sharpe":1.6,"cvar95":0.04,"maxdd":0.12,"turnover":1.8,"stability":0.71},
  "formal":{"no_lookahead":true,"termination":true,"bounded_risk":true},
  "thresholds":{"cvar95_min":0.03,"maxdd_max":0.2,"stability_min":0.6}
}
```

**Schema:** `Envelope(Decision)`

**Simple takeaway:** ตัดสินบน “ข้อมูลจริงจากฐาน” เท่านั้น—PASS/FAIL มีเหตุผล

---

## 9.5.6 Cost Guardian

**System (เพิ่ม):**

```
Estimate LLM and compute cost for the next step(s).
If forecast exceeds budget_hint, set status="needs_input" and propose 1–2 lower-cost plans.
Record estimate in CostRecord.
```

**Schema:** `Envelope(CostRecord)`

**Simple takeaway:** กันค่าใช้จ่ายบานปลาย ด้วยแผนสำรองอัตโนมัติ

---

## 9.5.7 Style QA Sentinels

**System (เพิ่ม):**

```
Based on family, evaluate a machine-checkable checklist:
- DCA: fixed interval, size discipline, drawdown guard
- Grid: step size bounds, max ladder levels, martingale forbidden
- Trend: MA/ATR discipline, whipsaw filter present
- ICT/SMC: fair value gap usage, liquidity sweep rules, time window constraints
Return score in [0,1].
```

**Schema:** `Envelope(StyleQAReport)`

**Simple takeaway:** ตรวจ “วัฒนธรรมของกลยุทธ์” ให้ถูกสำนักและวัดได้

---

# 9.6 Prompt Files ใน repo (Claude Code friendly)

```
.claude/agents/
  _shell.md                    # เปลือกมาตรฐาน
  architect.md                 # เติม system/dev/user template เฉพาะทาง
  synthesizer.md
  qc-planner.md
  formal-llm.md
  gatekeeper.md
  cost-guardian.md
  style-qa.md
packages/contracts/src/agents.ts        # Zod & JSON Schema
packages/llm/adapter.ts                 # jsonCall()
packages/agents/{architect.ts,...}      # wrapper per agent
tests/agents/{architect.test.ts,...}    # unit tests validate schema
```

**ตัวอย่าง `.claude/agents/architect.md` (ย่อ):**

```
# System
{{ include "_shell.md" with {agent_name:"Strategy Architect"} }}
Additional rules:
- Prefer MDL; avoid overfitting hints; respect risk tier caps.

# Developer
- If expr references future bars, mark status="error" with errors[] entries.

# User
<CONTEXT>
{{json user_payload}}
</CONTEXT>
<SCHEMA>
{{json schema_envelope_blueprint}}
</SCHEMA>
Respond in JSON only.
```

**Simple takeaway:** แยกไฟล์ตามเอเจนต์—Claude Code เข้าใจและเรียกใช้ได้ทันที

---

# 9.7 Wrapper ต่อเอเจนต์ (ตัวอย่าง Architect)

```ts
// packages/agents/architect.ts
import { Envelope, Blueprint } from "@contracts/agents";
import { jsonCall } from "@llm/adapter";

export async function callArchitect(input: any, params) {
  const schema = Envelope(Blueprint).toJSON();
  const sys = await loadAgentSystem("architect");   // โหลดจาก .claude/agents/architect.md
  const user = JSON.stringify(input);
  const out = await jsonCall(sys, user, schema, params);
  return Envelope(Blueprint).parse(out);
}
```

**Simple takeaway:** โค้ด wrapper ทุกตัวเหมือนกัน ต่างแค่ schema + template path

---

# 9.8 Unit Tests (เอาให้ผ่านก่อน merge)

* `architect.test.ts`: ให้ prompt เดิม → ต้อง **parse ผ่าน** และมี `invariants` ครบ
* `synthesizer.test.ts`: ใส่ Blueprint → ได้ `6–12 candidates` และ diversity\_vec ความห่างเฉลี่ย > 0.3
* `qc-planner.test.ts`: เลือก path ≤ budget, coverage ≥ target
* `gatekeeper.test.ts`: ให้ FACTS ชุด PASS/FAIL → ตอบถูกต้อง
* `style-qa.test.ts`: แต่ละ family → checklist สำคัญต้องถูกต้อง

**Simple takeaway:** ทุก PR จะบังคับให้ “เอเจนต์พูด JSON เป็น และทำหน้าที่ตัวเองจริง”

---

# 9.9 CI Hook (Claude Code auto-fix)

* GitHub Action รัน unit tests เอเจนต์ทุกตัว
* หากตก ให้ Action ping Claude Code ด้วยคอนเท็กซ์: test logs + agent prompt file → *ให้มัน PR แก้ prompt ไฟล์นั้น ๆ โดยอัตโนมัติ* (ยังคงให้คุณ review/merge)

**Simple takeaway:** วงจร “ตก→แก้→เทสต์ผ่าน” อัตโนมัติ ลดภาระมนุษย์

---

# 9.10 ตัวอย่าง FACTS Plumbing (Gatekeeper)

> ที่ฝั่ง orchestrator เราจะดึงค่า *จริง* จาก DB/Service แล้วห่อเข้า `<FACTS>{...}</FACTS>`
> Prompt ระบุชัด “ห้ามเดาข้อมูลนอก FACTS”

**Simple takeaway:** กัน hallucination ด้วยการ *ป้อนข้อเท็จจริง* ให้ชัด

---

# 9.11 ข้อผิดพลาดที่พบบ่อย & ทางแก้ใน Prompt

* โมเดลชอบพิมพ์คำอธิบายนอก JSON → ใช้ `response_format` (OpenAI) + Shell ที่เข้ม + stop-sequences
* ฟิลด์หาย → Self-check ก่อนส่ง + unit test schema
* ค่าเกินกรอบ (เช่น `max_concurrent` > 10) → ระบุ range ในสคีมา และระบบต้อง “reject”
* เกินงบ → `Cost Guardian` ตอบ `needs_input` และเสนอทางลดงบ (เช่น ลด candidates)

**Simple takeaway:** เราวาง “รั้วสามชั้น” = prompt shell + schema + tests

---

# 9.12 พารามิเตอร์ runtime (ENV)

```
LLM_ARCHITECT_MODEL=anthropic:claude-3.5
LLM_SYNTH_MODEL=openai:gpt-4o
LLM_QC_PLANNER_MODEL=anthropic:claude-3.5
LLM_FORMAL_HELPER_MODEL=openai:gpt-4.1
LLM_GATEKEEPER_MODEL=anthropic:claude-3-opus
LLM_COST_MODEL=openai:gpt-4o-mini
LLM_STYLEQA_MODEL=openai:gpt-4o

LLM_TEMP_ARCHITECT=0.2
LLM_TEMP_SYNTH=0.4
...
```

**Simple takeaway:** สลับรุ่น/ความดุได้ด้วย ENV—ไม่ต้องแก้โค้ด

---

# 9.13 ตัวอย่าง “งานเต็ม” ต่อสาย (Pseudo-sequence)

1. `callArchitect()` → Envelope(Blueprint)
2. `callSynthesizer()` → Candidates
3. `callQcPlanner()` → QcPlan
4. Orchestrator เรียก Engine T2/T3 (จริง)
5. Formal Service (จริง) + `callFormalLLM()` (อธิบาย)
6. `callGatekeeper(facts)` → Decision
7. ถ้า PASS → pack HSP v1

**Simple takeaway:** Prompt เป็น “ฟันเฟือง” ในสายพาน—ต่อกับของจริงได้เนียน

---

# 9.14 ตัวอย่าง Prompt/Output ชุดสั้น (End-to-End mini)

* Architect → Blueprint **status=ok**
* Synthesizer → 8 candidates + `estimate_usd: 0.04`
* QC Planner → coverage 0.9 budget 128
* Gatekeeper(PASS) → reasons: `meets cvar95`, `formal ok`, `stability ≥ 0.6`

*(แนบตัวอย่างเต็มใน `tests/fixtures/agents/*.json`)*

**Simple takeaway:** มีไฟล์ตัวอย่างไว้ให้ Claude Code เรียนรู้จากของ “ผ่านเทสต์จริง”

---

# 9.15 Checklist สำหรับรีวิว PR Prompt

* [ ] มี Shell ตาม `_shell.md`
* [ ] สคีมากล่าวถึง range ทุกฟิลด์สำคัญ
* [ ] มี self-check และ stop-sequences
* [ ] มี unit tests + fixtures
* [ ] มี budget\_hint/estimate
* [ ] Gatekeeper อ่านจาก `<FACTS/>` เท่านั้น

**Simple takeaway:** Prompt ก็ต้องผ่าน DoD—ไม่ใช่แค่โค้ด

---

## ปิดข้อ 9

คุณได้ **Prompt Templates ครบ 7 เอเจนต์** + โครงสคีมา + อแดปเตอร์ LLM (OpenAI/Claude) + เทสต์ + CI auto-fix—ทั้งหมดออกแบบให้ “JSON เท่านั้น, ตรวจเอง, เคารพงบ, และไม่แตะ chain-of-thought”

**Simple takeaway:** ตั้งแต่วันนี้ Claude Code จะ “เขียนตามสั่ง” แบบไม่มั่ว—เพราะคุณล็อกสัญญา/สคีมา/เทสต์ไว้รอบด้านแล้ว.






จัดให้ครบแพ็ก—**ข้อ 10 (ฉบับสมบูรณ์หลังพัฒนาจบ)** ที่คุณขอ:

* ASCII wireframe สุดท้าย (ยืนยัน UX แบบ Lovable.dev: แชทซ้าย/พรีวิวขวา + Drawer)
* โครงไฟล์/เพจ SvelteKit + Tailwind (พร้อมสคริปต์/สโตร์/ฮุค SSE)
* สัญญา API/อีเวนต์ + TypeScript types
* ปุ่ม/IDs ครบเพื่อผูกเทเลเมทรี/ชอร์ตคัต
* ชุด **BMAD Story files** แบ่งงานย่อย (10A–10G) พร้อม DoD & Test checklist (Claude Code แค่โค้ด)
* สเคลตันเทสต์ (Vitest + Playwright) + Telemetry + Empty states/Fixtures

ด้านล่างคัดลอกไปใส่ repo ได้ทันที

---

# 10.0 Scope & Dependencies

* ใช้ **VibeCode × BMAD × Claude Code — Full Template** (SvelteKit + Tailwind, Go API).
* เชื่อม **OpenAI/Claude** ผ่าน backend; FE ใช้เฉพาะ REST + SSE.
* เก็บทุกอย่าง **local‑first** ได้ (Docker Compose) แต่ Endpoints/Contracts เท่าเดิม—ย้ายขึ้นคลาวด์ภายหลังไม่สะดุด.

**Simple takeaway:** ข้อ 10 นี้เป็นสเปก FE/UX + สัญญา API ที่ล็อคแล้ว—ทำงานได้ทั้ง local และคลาวด์

---

# 10.1 ASCII Wireframe (Final)

```ascii
┌───────────────────────────────────────────────────────────────────────────────────────────────┐
│  TopBar                                                                                       │
│  [Heliox] | New Strategy | Portfolio | Marketplace | Search[⌘K] | Billing $ (87) | 🌓 | (User) │
└────────────┬──────────────────────────────────────────────────────────────────────────────────┘
             │
┌────────────▼───────────────┬──────────────────────────────────────────────────────────────────┐
│  CHAT (left ~400px)        │  WORKSPACE (right, flexible)                                     │
│  ┌───────────────────────┐ │  ┌────────────────────────────────────────────────────────────┐  │
│  │ ● Heliox Assistant    │ │  │  Empty Preview (logo+tips) / Timeline / Metrics / Files    │  │
│  └───────────────────────┘ │  └────────────────────────────────────────────────────────────┘  │
│  [Quick Actions]: Optimize | Backtest only | Explain | Risk‑tuned | Attach CSV/ind            │
│  ─ Messages (stream) ───── │  Floating Toolbelt: [Preview][Timeline][Metrics][Files][Deploy] │
│  Trader: "XAUUSD scalping" │                       [Compare][Simulate Again][Export][Alerts] │
│  AI: "Drafting blueprint"  │  Right Drawer (on click): Tabs Preview | Timeline | Metrics |... │
│  ...                       │                                                                  │
│  Composer: [ Ask Heliox… ][ Chat ▶ ]                                                          │
└─────────────────────────────┴──────────────────────────────────────────────────────────────────┘
```

**Simple takeaway:** โครงหลัก 2 คอลัมน์ + Toolbelt + Drawer—เข้าใจง่ายและขยายได้

---

# 10.2 File Tree (เพิ่ม/แก้ใน `apps/frontend/`)

```txt
src/
 ├─ lib/
 │   ├─ api/client.ts
 │   ├─ hooks/useEventStream.ts
 │   ├─ stores/chat.ts
 │   ├─ stores/run.ts
 │   ├─ types/events.ts
 │   └─ telemetry.ts
 │
 │   └─ components/
 │       ├─ ChatPanel.svelte
 │       ├─ Workspace.svelte
 │       ├─ FloatingToolbelt.svelte
 │       ├─ RightDrawer.svelte
 │       └─ KpiBadges.svelte
 │
 ├─ routes/
 │   ├─ (app)/
 │   │   ├─ builder/+page.svelte
 │   │   ├─ portfolio/+page.svelte
 │   │   └─ settings/+page.svelte
 │   └─ +layout.svelte (+layout.server.ts มีอยู่แล้ว)
 │
 ├─ fixtures/
 │   ├─ events.ndjson
 │   ├─ blueprint.json
 │   └─ metrics.json
 └─ tests/
     ├─ runStore.spec.ts
     └─ e2e/
         └─ builder.spec.ts
```

**Simple takeaway:** แตกไฟล์เป็น components/Stores/Hooks ชัดเจน—ส่งงานเป็น PR ย่อยได้

---

# 10.3 API Contracts (FE ใช้)

* `POST /v1/runs` → `{ run_id, trace_id }`
* `GET  /v1/runs/:trace_id/events?lastEventId=…` (SSE)

  * `type`: `status/* | artifact/file | metrics/summary | decision/gate | deploy/fill | error`
* `POST /v1/runs/:run_id/actions/{optimize|simulate|export|deploy|kill|alerts}`
* Portfolio

  * `GET /v1/portfolio/assets`
  * `POST /v1/portfolio/assets` (Save HSP)
* Billing/Settings:

  * `GET /v1/billing/usage`, `POST /v1/billing/topup`
  * `GET/PUT /v1/settings` (LLM provider, budgets, adapters)

**Simple takeaway:** สัญญาคงที่—Claude Code ฝั่ง BE/FE โค้ดตามนี้ได้เลย

---

# 10.4 Event Types (TypeScript)

```ts
// src/lib/types/events.ts
export type Phase = 'architect'|'synthesize'|'qc'|'verify'|'gate'|'pack'|'deployed'|'error';

export type StatusPhase = { type:'status/phase'; phase: Phase; ts:number; run_id:string };
export type StatusProgress = { type:'status/progress'; phase:Phase; progress:number; msg?:string };
export type ArtifactFile = { type:'artifact/file'; name:string; uri:string; checksum?:string };
export type MetricsSummary = {
  type:'metrics/summary';
  kpis: { sharpe:number; cvar95:number; maxdd:number; winrate:number; stability?:number }
};
export type GateDecision = { type:'decision/gate'; pass:boolean; reasons:string[]; next_steps:string[] };
export type DeployFill = { type:'deploy/fill'; mode:'paper'|'live'; symbol:string; px:number; qty:number; side:'buy'|'sell'; ts:number };
export type ErrorEvt = { type:'error'; code:string; message:string; hint?:string };

export type RunEvent = StatusPhase|StatusProgress|ArtifactFile|MetricsSummary|GateDecision|DeployFill|ErrorEvt;

export type RunState = {
  runId?: string; traceId?: string;
  phase?: Phase; kpis?: MetricsSummary['kpis'];
  files: ArtifactFile[]; timeline: RunEvent[];
  error?: ErrorEvt; deployed?: boolean;
};
```

**Simple takeaway:** FE มี types ที่ครอบคลุมทุกอีเวนต์—สโตร์จะ “ปลอดเดา”

---

# 10.5 Stores

```ts
// src/lib/stores/run.ts
import { writable } from 'svelte/store';
import type { RunEvent, RunState } from '$lib/types/events';
export const runState = writable<RunState>({ files:[], timeline:[] });

export function reduceEvent(s:RunState, e:RunEvent): RunState {
  const next = { ...s, timeline:[...s.timeline, e] };
  if (e.type==='status/phase') next.phase = e.phase;
  if (e.type==='metrics/summary') next.kpis = e.kpis;
  if (e.type==='artifact/file') next.files = [...(s.files||[]), e];
  if (e.type==='decision/gate') next.deployed = e.pass ? false : s.deployed;
  if (e.type==='error') next.error = e;
  return next;
}
```

```ts
// src/lib/stores/chat.ts
import { writable } from 'svelte/store';
export type ChatMsg = { role:'user'|'ai'|'status'|'artifact'; text:string };
export const chat = writable<ChatMsg[]>([]);
```

**Simple takeaway:** state update แบบ reducer—ง่ายต่อการทดสอบและ replay

---

# 10.6 API Client + SSE Hook

```ts
// src/lib/api/client.ts
const BASE = (import.meta.env.PUBLIC_API_BASE as string) || 'http://localhost:8080';
export async function api(path:string, init:RequestInit={}) {
  const res = await fetch(`${BASE}${path}`, { headers:{'Content-Type':'application/json'}, credentials:'include', ...init });
  if (!res.ok) throw new Error(`${res.status}`);
  return res.json();
}
export const postJson = (p:string, b:any) => api(p, { method:'POST', body:JSON.stringify(b) });
```

```ts
// src/lib/hooks/useEventStream.ts
import { runState, reduceEvent } from '$lib/stores/run';
import type { RunEvent } from '$lib/types/events';

export function useEventStream(traceId:string) {
  let es: EventSource | undefined;
  let lastId = localStorage.getItem(`sse:${traceId}:lastId`) || undefined;

  const connect = () => {
    const url = new URL(`/v1/runs/${traceId}/events`, import.meta.env.PUBLIC_API_BASE);
    if (lastId) url.searchParams.set('lastEventId', lastId);
    es = new EventSource(url.toString(), { withCredentials:true });
    es.onmessage = (ev) => {
      lastId = ev.lastEventId || lastId || '';
      localStorage.setItem(`sse:${traceId}:lastId`, lastId);
      const data = JSON.parse(ev.data) as RunEvent;
      runState.update(s => reduceEvent(s, data));
    };
    es.onerror = () => { es?.close(); setTimeout(connect, 1000 + Math.random()*4000); };
  };
  connect();
  return { close: () => es?.close() };
}
```

**Simple takeaway:** Hook นี้ reconnect+resume ได้—แค่ส่ง `traceId` ก็พอ

---

# 10.7 Components (สั้น กระชับ ใช้งานได้)

```svelte
<!-- src/lib/components/ChatPanel.svelte -->
<script lang="ts">
  import { chat } from '$lib/stores/chat'; import { runState } from '$lib/stores/run';
  import { postJson } from '$lib/api/client'; import { useEventStream } from '$lib/hooks/useEventStream';
  let input = ''; let connecting = false;

  async function send() {
    if (!input.trim()) return;
    chat.update(x => [...x, {role:'user', text:input}]);
    connecting = true;
    const { run_id, trace_id } = await postJson('/v1/runs', { prompt: input });
    runState.update(s => ({...s, runId: run_id, traceId: trace_id}));
    useEventStream(trace_id); // fire-and-forget
    input = ''; connecting = false;
  }
</script>

<div class="h-full flex flex-col">
  <header class="flex items-center justify-between py-2">
    <div class="font-semibold">● Heliox Assistant</div>
    <div class="text-xs opacity-70">{connecting ? 'connecting…' : 'connected'}</div>
  </header>

  <div class="flex-1 overflow-auto space-y-2 pr-2">
    {#each $chat as m}
      <div class="text-sm">
        <span class="font-medium">{m.role}:</span> {m.text}
      </div>
    {/each}
  </div>

  <div class="mt-2 flex gap-2">
    <input id="composer:input" class="flex-1 border rounded px-3 py-2" bind:value={input} placeholder="Ask Heliox…" />
    <button id="composer:send" class="px-3 py-2 rounded bg-black text-white" on:click={send}>Chat ▶</button>
  </div>
</div>
```

```svelte
<!-- src/lib/components/FloatingToolbelt.svelte -->
<script lang="ts">
  export let onOpen = (tab:string)=>{};
  const tabs = ['preview','timeline','metrics','files','deploy','compare'];
</script>
<div class="fixed right-6 bottom-6 flex gap-2">
  {#each tabs as t}
    <button id={'tb:'+t} class="px-3 py-2 bg-white shadow rounded" on:click={() => onOpen(t)}>{t}</button>
  {/each}
</div>
```

```svelte
<!-- src/lib/components/RightDrawer.svelte -->
<script lang="ts">
  import { runState } from '$lib/stores/run'; export let open=false; export let tab='preview';
  const tabs = ['preview','timeline','metrics','files','deploy','compare'];
</script>
<aside class="fixed top-0 right-0 h-full w-[520px] bg-white shadow-2xl border-l transition-transform"
       class:translate-x-full={!open}>
  <div class="p-3 border-b flex gap-2">{#each tabs as t}
    <button class="px-3 py-1 rounded {tab===t?'bg-black text-white':''}" on:click={()=>tab=t}>{t}</button>
  {/each}</div>

  <div class="p-4 overflow-auto text-sm">
    {#if tab==='preview'}
      <h3 class="font-semibold mb-2">KPIs</h3>
      <pre>{JSON.stringify($runState.kpis, null, 2)}</pre>
      <div class="mt-3 flex gap-2">
        <button id="act:optimize" class="btn">Optimize</button>
        <button id="act:simulate" class="btn">Simulate Again</button>
        <button id="act:export" class="btn">Export</button>
        <button id="act:save-portfolio" class="btn">Save</button>
      </div>
    {:else if tab==='files'}
      <ul class="space-y-2">
        {#each $runState.files as f}
          <li class="flex justify-between">
            <span>{f.name}</span><a class="text-blue-600 underline" href={f.uri} target="_blank">Download</a>
          </li>
        {/each}
      </ul>
    {:else}
      <pre>{tab} — coming alive with data…</pre>
    {/if}
  </div>
</aside>

<style>
  .btn { @apply px-3 py-2 bg-black text-white rounded; }
</style>
```

```svelte
<!-- src/lib/components/Workspace.svelte -->
<script lang="ts">
  export let openDrawer = (tab:string)=>{};
</script>
<div class="h-full w-full grid place-items-center text-gray-500">
  <div class="text-center">
    <div class="text-2xl font-semibold mb-2">Spinning up preview…</div>
    <button class="px-3 py-2 border rounded" on:click={()=>openDrawer('preview')}>Open Preview</button>
  </div>
</div>
```

```svelte
<!-- src/routes/(app)/builder/+page.svelte -->
<script lang="ts">
  import ChatPanel from '$lib/components/ChatPanel.svelte';
  import Workspace from '$lib/components/Workspace.svelte';
  import FloatingToolbelt from '$lib/components/FloatingToolbelt.svelte';
  import RightDrawer from '$lib/components/RightDrawer.svelte';
  let drawerOpen=false, drawerTab='preview';
  const openDrawer = (tab:string) => { drawerTab=tab; drawerOpen=true; };
</script>

<div class="h-screen grid grid-cols-[400px_1fr]">
  <div class="border-r p-3"><ChatPanel /></div>
  <div class="relative"><Workspace {openDrawer} /><FloatingToolbelt onOpen={openDrawer} /></div>
  <RightDrawer bind:open={drawerOpen} bind:tab={drawerTab} />
</div>
```

**Simple takeaway:** โค้ดสั้นแต่ครบ—รันได้/ขยายง่าย—Claude Code เติมฟีเจอร์ในแต่ละแท็บต่อได้ทันที

---

# 10.8 Portfolio & Settings (สรุปคอมโพเนนต์)

* `/portfolio/+page.svelte`: ตารางกลยุทธ์ + ฟิลเตอร์ + Compare
* `/settings/+page.svelte`: LLM provider, budgets, adapters

> ทั้งสองหน้าใช้ **IDs** ตามสเปกก่อนหน้า (`pf:*`, `deploy:*`, …)

**Simple takeaway:** แยกหน้าเพื่อความชัดเจน—ไม่ปะปนกับ Builder

---

# 10.9 Telemetry (FE)

```ts
// src/lib/telemetry.ts
export const track = (name:string, data:Record<string,any>={}) =>
  console.log('[telemetry]', name, { ...data }); // later: send to OTel collector

// usage: track('ui.click.tb:preview', { traceId, runId });
```

**Simple takeaway:** จุดเดียวสำหรับยิงเหตุการณ์—เปลี่ยน backend ทีหลังได้

---

# 10.10 Tests (สเคลตัน)

**Vitest – run store**

```ts
// src/tests/runStore.spec.ts
import { reduceEvent } from '$lib/stores/run';
test('append metrics', () => {
  const s = { files:[], timeline:[] };
  const e = { type:'metrics/summary', kpis:{ sharpe:1.4, cvar95:0.04, maxdd:0.1, winrate:0.55 } } as any;
  const n = reduceEvent(s as any, e);
  expect(n.kpis?.sharpe).toBe(1.4);
  expect(n.timeline).toHaveLength(1);
});
```

**Playwright – e2e**

```ts
// src/tests/e2e/builder.spec.ts
import { test, expect } from '@playwright/test';
test('start run and open drawer', async ({ page }) => {
  await page.goto('/builder');
  await page.getByPlaceholder('Ask Heliox').fill('XAUUSD scalping');
  await page.getByRole('button', { name: 'Chat ▶' }).click();
  await page.getByRole('button', { name: 'preview', exact:true }).click();
  await expect(page.locator('aside')).toBeVisible();
});
```

**Simple takeaway:** มีทั้ง unit และ e2e ตัวอย่าง—Claude Code เติมเคสจริงได้ทันที

---

# 10.11 BMAD Stories (สร้างไฟล์ใน `/stories/`)

> **ทุกไฟล์ใช้เทมเพลต** `_TEMPLATE.md` เดิม (Background / Input Contract / Implementation Plan / DoD / Tests / Rollback).
> ผมให้เนื้อหาย่อพร้อม DoD/Test สำคัญ—คัดลอกวางได้เลย

### `stories/UI-10A-builder-shell.md`

* **Background:** สร้างหน้า `/(app)/builder` เลย์เอาต์ 2 คอลัมน์, ใส่ ChatPanel/Workspace/Toolbelt/Drawer
* **Input Contract:** ไม่มี (Mock first)
* **Implementation Plan:** สร้างไฟล์ตาม 10.2; เติม Tailwind classes; Mock states
* **DoD:**

  * Layout แสดงครบ, IDs ถูกต้อง, Responsive <1024px สลับแท็บ
  * Lighthouse ≥90 (local)
* **Tests:** Playwright เปิดหน้า, ปุ่ม Toolbelt เปิด Drawer ได้
* **Rollback:** ลบเพจ + คอมโพเนนต์ใหม่

### `stories/UI-10B-sse-hook-and-stores.md`

* **Background:** Hook SSE auto‑reconnect/resume + run/chat stores
* **Input Contract:** SSE event schema (10.4)
* **Implementation Plan:** สร้าง `useEventStream.ts`, `run.ts`, `chat.ts`
* **DoD:** reconnect 1–5s backoff, resume by `lastEventId`, reducer ปลอด side effect
* **Tests:** Vitest reducer; Mock ES server ใน e2e
* **Rollback:** ปิดใช้ SSE, fallback โหมด mock

### `stories/UI-10C-right-drawer-tabs.md`

* **Background:** Drawer แท็บ Preview/Timeline/Metrics/Files/Deploy/Compare
* **Plan:** โครงแท็บ + ปุ่ม IDs + placeholder content; Metrics ใช้ fixture
* **DoD:** ปุ่มทุกอันมี ID, Files list ดาวน์โหลดได้จาก URI
* **Tests:** เปิดแต่ละแท็บ/สลับแท็บ/ดาวน์โหลดลิงก์แรก

### `stories/UI-10D-floating-toolbelt.md`

* **Background:** Toolbelt ลอยล่างขวา เปิด Drawer/แท็บ
* **Plan:** คอมโพเนนต์ + mapping ปุ่มไปแท็บ
* **DoD:** ปุ่มทั้งหมดทำงาน; มี aria‑label
* **Tests:** คลิกแต่ละปุ่มแล้ว Drawer เปิดแท็บที่ถูกต้อง

### `stories/UI-10E-portfolio-and-compare.md`

* **Background:** หน้า `/portfolio` + Compare overlay
* **Plan:** ตาราง + ฟิลเตอร์ + Bulk actions (mock)
* **DoD:** เลือกได้หลายกลยุทธ์, ส่งค่าไป Compare view
* **Tests:** ฟิลเตอร์ PASS only, Compare แสดง KPI รวม

### `stories/UI-10F-deploy-flow-paper.md`

* **Background:** แท็บ Deploy—เลือก adapter/บัญชี, safeguards, mode Paper
* **Input Contract:** `POST /v1/runs/:id/actions/deploy` payload (mock)
* **Plan:** ฟอร์ม + ปุ่ม submit + SSE fills view
* **DoD:** ส่ง payload ตามสเปก, แสดง fills event
* **Tests:** Playwright: เลือก PaperSim → Deploy → รับ 1 fill

### `stories/UI-10G-billing-settings-telemetry.md`

* **Background:** Billing mini-panel + Settings + event tracking
* **Plan:** หน้า `/settings`, ฟอร์ม LLM/budget/adapters; telemetry wrapper
* **DoD:** track ทุก ID ที่สเปกกำหนด; settings persist (mock)
* **Tests:** กดปุ่มหลายอันแล้ว console telemetry มีรายการ

**Simple takeaway:** แบ่งงาน 7 ชิ้น ขนาดพอดี PR—DoD ชัด, เทสต์แน่น, ย้อนกลับง่าย

---

# 10.12 Fixtures (ใส่เพื่อเดโม่/ทดสอบ)

* `fixtures/events.ndjson` — 20 บรรทัด ตัวอย่าง `status/phase`, `metrics/summary`, `artifact/file`
* `fixtures/blueprint.json`, `fixtures/metrics.json` — สำหรับ Preview/Metrics
* Dev server สามารถอ่านไฟล์เหล่านี้ถ้าไม่มี SSE จริง

**Simple takeaway:** ต่อ BE ทีหลังได้—ตอนนี้ก็โชว์งานครบ flow

---

# 10.13 Accessibility / Keyboard / Empty States

* Shortcuts: `⌘K` search, `⌘⏎` ส่งข้อความ, `]` สลับแท็บ Drawer, `Esc` ปิด Drawer
* Empty states: Chat/Workspace/Portfolio พร้อมคำอธิบายสั้น
* a11y: focus ring ชัด, aria‑label ทุกปุ่ม, axe ไม่มี critical

**Simple takeaway:** ใช้ได้จริงสำหรับทุกคน—พร้อมรีวิวด้านการเข้าถึง

---

# 10.14 Performance Budgets

* FCP < 1.5s, Bundle < 250KB gz (หน้า Builder)
* SSE latency < 250ms/event (local)
* Virtualize chat/timeline > 200 รายการ

**Simple takeaway:** กำหนดเพดานชัด—โค้ดไม่บานปลาย

---

# 10.15 What Claude Code ต้องทำ (ขั้นลำดับ)

1. **10A** สร้างหน้า Builder shell + components/IDs ตามไฟล์ทรี
2. **10B** ทำ stores + SSE hook + unit test
3. **10C** เติม Drawer tabs + Toolbelt + fixtures
4. **10D** เชื่อม Files/Export (URI mock)
5. **10E** ทำ Portfolio/Compare + e2e
6. **10F** ทำ Deploy(Paper) flow + fills SSE mock
7. **10G** ใส่ Billing/Settings + telemetry

> เปิด PR แยกตาม story; CI รัน Vitest/Playwright อัตโนมัติ; ถ้าไม่ผ่านให้ Claude Code **fix‑until‑green** (เปิด `workflow_run` trigger กับ retrial)

**Simple takeaway:** ขั้นบันไดชัด—“แดงแล้วแก้ให้เขียว” อัตโนมัติในแต่ละ PR

---

## ปิดท้าย

* ข้อ 10 นี้ **แทนของเก่าเต็มรูป**: เพิ่ม Toolbelt/Drawer/Portfolio/Compare/Billing/Settings/IDs/SSE/Tests/Stories
* คัดลอกส่วน “BMAD stories” ไปวางใน `/stories/` แล้วสั่ง **@scrum‑master → @dev → @qa** ตามลำดับ—งานจะเดินแบบ deterministic

ต้องการให้ผม **สร้างไฟล์จริงทั้งหมด** (stories + scaffolds) ในรูปแบบข้อความสำหรับ commit แรก (ใส่ path+content) เลยไหม? ทำได้ทันทีเพื่อให้คุณวางลง repo แล้วให้ Claude Code เปิด PR ต่อได้เลย.




มาครบชุด—**ข้อ 11: Security & FinOps (Phase 1–2, Local‑first)**
ออกแบบให้ “แข็งแกร่งตั้งแต่วันแรก” แม้อยู่บนเครื่องคุณ (local) แต่สลับขึ้นคลาวด์ได้ทันทีโดยไม่เปลี่ยนสัญญาใด ๆ

---

# 11.0 ขอบเขต & หลักคิด

* ครอบคลุมชั้น **Gateway → AuthN/Z → DB/RLS → Secrets/Vault → Engine Sandbox → Cost Guard → SSE Backpressure → Observability/Audit → CI/SecOps**
* ยึดสแตกของเทมเพลตเรา: **Go (Gin) API + Postgres + SvelteKit FE + Docker Compose**
* หน่วยงานกำกับ: **BMAD Story 11A–11G** (ท้ายเอกสารมีรายการ + DoD/Tests พร้อม)

**Simple takeaway:** ข้อ 11 = ระเบียบวินัยของระบบทั้งหมด—กันพัง, กันรั่ว, กันเปลือง, ตรวจย้อนหลังได้

---

# 11.1 Threat Model & Trust Boundaries (ASCII)

```ascii
[Browser/FE] ──TLS──> [API Gateway (Gin)]
   |                        |
   | JWT (Bearer)           |  Policies: CORS allowlist, RateLimit, SizeCap, AuthZ/RBAC, ErrorSanitizer
   v                        v
[LLM Keys in Vault(dev)]  [Engine Sandbox]  ── no-net, WORK_DIR, seccomp(⊕), timeouts
                              |
                              v
                       [Simulator/CEGIS]  ── deterministic seeds, CRN/antithetic
                              |
                              v
                     [Redis (cache)]  [Postgres (RLS on)]
                              |
                              v
                     [SSE Streamer with backpressure]
```

ภัยหลักที่ปิด: token leak, CORS ลอย, brute force, noisy neighbor, query over‑fetch, job runaway, SSE memory blowup

**Simple takeaway:** มีรั้วทุกชั้น—จากเบราว์เซอร์ถึงซิมูเลเตอร์

---

# 11.2 Gateway Hardening (Go/Gin)

### นโยบาย/ฟีเจอร์

* **CORS allowlist** (env `CORS_ALLOWED_ORIGINS`) — ปฏิเสธ Origin ไม่อยู่ลิสต์
* **RateLimit (token bucket)** per‑IP (config `RATE_LIMIT_RPS`)
* **RBAC/JWT** (roles: `user, admin`; claims: `sub, tenant_id, role, tier, scopes[]`)
* **ErrorSanitizer** — ไม่โชว์ stack; ติด `X-Trace-Id`
* **Request Size Cap** (เช่น 1–5 MB) กัน upload/JSON ใหญ่ผิดปกติ
* **Idempotency-Key** header บน endpoints ที่ทำงานซ้ำได้ (เช่น `/v1/runs`)
* **Replay window** สำหรับ JWT (ตรวจ `iat/exp` + clock skew <= 60s)

### ตัวอย่างโค้ด: SizeCap + RequestID

```go
// middleware/sizecap.go
func SizeCap(max int64) gin.HandlerFunc {
  return func(c *gin.Context) {
    c.Request.Body = http.MaxBytesReader(c.Writer, c.Request.Body, max)
    c.Next()
  }
}

// middleware/requestid.go
func RequestID() gin.HandlerFunc {
  return func(c *gin.Context) {
    id := c.GetHeader("X-Request-Id")
    if id == "" { id = uuid.NewString() }
    c.Writer.Header().Set("X-Request-Id", id)
    c.Set("req_id", id)
    c.Next()
  }
}
```

**Simple takeaway:** เกตเวย์เรามี “เบรก” และ “กันชน” ครบ—ยิงแรงยังไงก็ไม่ล้มทั้งระบบ

---

# 11.3 AuthN/Z Model (JWT + RBAC Matrix)

**Claims ที่ต้องมี**

```json
{
  "sub": "user_123",
  "tenant_id": "ten_abc",
  "role": "user",
  "tier": "pro",
  "scopes": ["runs:create","portfolio:write"],
  "exp": 1735689600,
  "iat": 1735682400
}
```

**RBAC Matrix (ตัวอย่าง)**

| Endpoint                         | user | admin |
| -------------------------------- | :--: | :---: |
| POST `/v1/runs`                  |   ✓  |   ✓   |
| GET  `/v1/runs/:id/events` (SSE) |   ✓  |   ✓   |
| POST `/v1/runs/:id/actions/*`    |   ✓  |   ✓   |
| GET/POST `/v1/portfolio/*`       |   ✓  |   ✓   |
| GET/PUT `/v1/settings`           |   ✓  |   ✓   |
| Admin ops `/v1/admin/*`          |   –  |   ✓   |

**Backend pattern:** หลัง verify JWT → inject context (`tenant_id`,`user_id`,`role`) → ใช้กับ RLS

**Simple takeaway:** สิทธิ์ชัด, ตรวจเร็ว, คลีน—ไม่มี “หลุดสิทธิ์ข้ามเช่า” (tenant)

---

# 11.4 Database Security (Postgres RLS)

### สคีมาแบบ multi‑tenant

```sql
ALTER TABLE runs ADD COLUMN tenant_id text NOT NULL;
ALTER TABLE runs ENABLE ROW LEVEL SECURITY;

CREATE POLICY runs_isolation ON runs
USING (tenant_id = current_setting('app.tenant_id')::text);

-- เหมือนกันสำหรับ artifacts, portfolio_assets, cost_ledger
```

### ตั้งค่า context ต่อ request

ใน Go handler:

```go
pool, _ := pgxpool.New(ctx, cfg.DatabaseURL)
func WithTenant(ctx context.Context, conn *pgxpool.Conn, tenant, user string) {
  conn.Exec(ctx, "SET LOCAL app.tenant_id = $1", tenant)
  conn.Exec(ctx, "SET LOCAL app.user_id = $1", user)
}
```

### Indexing & Least Privilege

* Composite index `(tenant_id, created_at desc)` บนทุกตารางที่ query ตาม tenant
* ใช้ DB role แยก `app_read`, `app_rw`; ไม่ใช้ `superuser` ใน dev ด้วย

**Simple takeaway:** RLS เปิดเสมอ; ทุก query เดินผ่าน context—ตัดปัญหาข้ามข้อมูลเช่า

---

# 11.5 Secrets & Vault (dev)

ตัวเลือกปลอดภัยและง่าย:

1. **age‑encrypted vault** (`dev.vault.json.age`) เก็บที่ repo, ไขด้วย key ใน `~/.config/heliox/keys/agekey`
2. หรือ **Doppler / direnv** จ่าย env ให้ `docker compose` อัตโนมัติ

**ตัวอย่างรูปแบบ vault (ถอดรหัสแล้วใน memory เท่านั้น)**

```json
{
  "OPENAI_API_KEY": "sk-***",
  "ANTHROPIC_API_KEY": "sk-ant-***",
  "OANDA_API_KEY": "oanda-***",
  "BINANCE_API_KEY": "bin-***",
  "BINANCE_API_SECRET": "sec-***"
}
```

**Loader (Go)**

```go
type Secrets struct { OpenAI string; Anthropic string; Oanda string; BinanceKey string; BinanceSecret string }
func LoadSecrets() Secrets {
  // 1) อ่านจาก env ถ้ามี; 2) ถ้าไม่มี ลองอ่านไฟล์ถอดรหัสที่ TMP (dev only)
  // fail‑fast หากขาด keys ที่จำเป็น
}
```

**Simple takeaway:** dev ก็มี vault จริง—คีย์ไม่ลอยในโค้ด/PR

---

# 11.6 Engine Sandbox (WORK\_DIR, Determinism, Cache)

### กติกา Sandbox

* ทุกงานรันใน **WORK\_DIR** ใต้ `/tmp/heliox/<run_id>`
* **no network** (ตั้งค่า container profile/iptables หรือ run flag), **seccomp** (deny exec อื่น), **ulimit** (`cpu`, `nofile`, `as`)
* **timeouts** ต่อขั้น (`T0/T1` ≤ 60s, `T2/T3` ≤ 300s dev)
* Clean‑up อัตโนมัติหลังปิดงาน/หมดเวลา

### Determinism

* **MasterSeed** ต่อ run + **CRN** (common random numbers) ข้าม candidates
* **Antithetic** sample: ใช้ `u` และ `1-u` เพื่อเร่งความนิ่งของตัวชี้วัด

### Content‑hash Cache

คีย์ = `blake3(blueprint|scenario_set_id|sim_cfg|seed_block|engine_version)`
สโตร์ = Redis (`SIM_RESULT:<hash>` → gzip JSON, TTL 7d) + ดัชนีใน Postgres (artifact table)

**ตัวอย่าง pseudo**

```go
key := Blake3(blueprintJSON + scenarioID + simCfg + seedBlock + engineVer)
if val, ok := redis.Get(key); ok { return val } // hit
res := runSimulator(...)
redis.SetEX(key, res, 7*24*time.Hour)
```

**Simple takeaway:** งานซ้ำไม่เผาเครื่อง—ดีเทอร์มิแนนต์และแคชจับต้องได้

---

# 11.7 FinOps: Preflight, Early‑Stop, Bandit

### 11.7.1 Cost Model (ตัวอย่าง)

```yaml
pricing:
  llm:
    openai.gpt-4o: { input: 5e-6, output: 15e-6 }    # $/token
    claude.opus:   { input: 15e-6, output: 75e-6 }
  sim:
    cpu_per_sec: 0.00006   # $ ต่อวินาที CPU (ประเมิน)
  storage:
    per_mb: 0.00002
```

### 11.7.2 Preflight API

* **POST** `/v1/cost/preflight`
* **in** `{ "plan": { "blueprint_tokens": 3_200, "candidates": 128, "t0_secs": 15, "t1_secs": 30, "t2_paths": 256 }, "model": "claude.opus", "caps": { "run": 2.0, "daily": 20.0 } }`
* **out** `{ "ok": true, "est_usd": 1.42, "headroom": 18.58, "advice": ["use gpt-4o for T0"] }`

**อัลกอริทึม:**
คำนวณ LLM tokens โดยประมาณ + เวลาซิมรวม → รวมเป็น `$est` เทียบ caps → ถ้าเกิน ส่ง `ok=false` และแผนลดขั้น (เช่นลด `candidates`, ใช้ 2‑stage)

### 11.7.3 Early‑Stop Rules

* **Median‑of‑Means**: batch ย่อย 4 ก้อน; หาก median performance < threshold ตัดทิ้ง
* **Sequential Halving**: N ผู้สมัคร → รันเร็ว → เก็บ top 1/2 → เพิ่มงานบนที่เหลือ
* **Safety guard**: ถ้า `MaxDD` ชั่วคราว > hard cap ให้หยุดทันที

### 11.7.4 Bandit Allocator (UCB1 ย่อ)

```python
for round in 1..R:
  for each candidate i:
    score_i = mean_i + c * sqrt(log t / n_i)
  pick argmax score_i; allocate more T1/T2
  update (mean_i, n_i) with new metric (e.g., Sharpe surrogate)
```

**Simple takeaway:** ใช้งบอย่างฉลาด—ประเมินก่อน, หยุดไว, ทุ่มให้ตัวมีแวว

---

# 11.8 SSE Backpressure & Reliability

### นโยบาย

* คิวอีเวนต์ per‑run (bounded `< 100` รายการ)
* **Coalesce** metrics ภายใน 200ms (รวมหลายอีเวนต์เป็นชุดเดียว)
* **Throttle** ส่งไม่เกิน 20 events/sec
* **Heartbeat** ทุก 10s (`type:"status/heartbeat"`)
* ถ้าคลายช้า → **drop‑latest noncritical** (เช่น progress), ไม่ดรอป `artifact/file`/`error`
* รองรับ **`Last-Event-Id`** (resume)

### โค้ด SSE (Go สรุปแนวคิด)

```go
type Evt struct { ID string; Data []byte; Critical bool }

func stream(c *gin.Context, ch <-chan Evt) {
  c.Writer.Header().Set("Content-Type", "text/event-stream")
  c.Writer.Header().Set("Cache-Control", "no-cache")
  flusher, _ := c.Writer.(http.Flusher)
  ticker := time.NewTicker(10 * time.Second)
  defer ticker.Stop()
  buf := make([]Evt,0,100)
  for {
    select {
    case e := <-ch:
      if len(buf) >= cap(buf) && !e.Critical { continue } // drop-latest noncritical
      buf = append(buf, e)
    case <-time.After(200 * time.Millisecond):
      if len(buf) > 0 {
        for _, e := range buf {
          fmt.Fprintf(c.Writer, "id: %s\n", e.ID)
          fmt.Fprintf(c.Writer, "data: %s\n\n", e.Data)
        }
        buf = buf[:0]
        flusher.Flush()
      }
    case <-ticker.C:
      fmt.Fprintf(c.Writer, "event: heartbeat\ndata: {}\n\n")
      flusher.Flush()
    case <-c.Request.Context().Done():
      return
    }
  }
}
```

**Simple takeaway:** สตรีม “หนึบ” ไม่ล้นหน่วยความจำ ไม่ตกอีเวนต์สำคัญ และต่อใหม่ได้

---

# 11.9 Observability & Audit

### Logs (structured)

```json
{
  "ts":"2025-08-24T05:10:03Z","trace":"tr_abc","req":"rq_123",
  "sub":"user_123","tenant":"ten_abc","route":"/v1/runs",
  "phase":"synthesize","duration_ms":842,"tokens_in":1800,"tokens_out":600,
  "cost_usd":0.045,"status":"ok"
}
```

### Audit tables

* `audit_events(id, ts, tenant_id, user_id, action, entity, entity_id, attrs jsonb)`
* ทุก “ตัดสินใจสำคัญ” (deploy, save portfolio, gate PASS/FAIL) ต้องเขียน audit

### Tracing

* OTel exporter (stdout ใน dev) — span ต่อ step (`architect`, `synthesize` …)

**Simple takeaway:** วัดทุกบาท/วินาที/การตัดสินใจ — ย้อนดูที่มาที่ไปได้ครบ

---

# 11.10 CI/SecOps (ทดสอบด้านความปลอดภัย)

* **gitleaks** (secrets scan), **gosec** (Go SAST), **osv‑scanner/trivy** (deps), **hadolint** (Dockerfile)
* **OWASP ZAP baseline** (optional) ยิงกับ dev server
* **Unit tests** สำหรับ: JWT validator, RLS guard (integration), RateLimit, SizeCap, SSE coalesce

**ตัวอย่าง unit (Go) — RateLimit**

```go
func TestRateLimit(t *testing.T) {
  r := gin.New(); r.Use(RateLimit(2)); r.GET("/", func(c *gin.Context){ c.Status(200) })
  w1 := httptest.NewRecorder(); r.ServeHTTP(w1, httptest.NewRequest("GET","/",nil))
  w2 := httptest.NewRecorder(); r.ServeHTTP(w2, httptest.NewRequest("GET","/",nil))
  w3 := httptest.NewRecorder(); r.ServeHTTP(w3, httptest.NewRequest("GET","/",nil))
  if w3.Code != http.StatusTooManyRequests { t.Fatal("should throttle") }
}
```

**Simple takeaway:** PR ไหนไม่ผ่านการ์ดพวกนี้—ห้ามเข้า main

---

# 11.11 Config & Env (เพิ่มจาก `.env.example`)

```env
# Security
REQUEST_SIZE_MAX=5242880          # 5 MB
JWT_ISSUER=heliox.local
JWT_AUDIENCE=heliox.app
JWT_ROTATE_AFTER_DAYS=30

# FinOps / Budgets
BUDGET_MAX_RUN_USD=2.00
BUDGET_MAX_DAILY_USD=20.00
PRICING_LLM=openai.gpt-4o          # default
PRICING_SIM_CPU_PER_SEC=0.00006

# Sandbox
WORK_DIR=/tmp/heliox
SANDBOX_TIMEOUT_FAST=60
SANDBOX_TIMEOUT_HEAVY=300
SANDBOX_DISABLE_NET=true

# SSE
SSE_MAX_QUEUE=100
SSE_COALESCE_MS=200
SSE_HEARTBEAT_SEC=10

# Cache
REDIS_URL=redis://redis:6379
CACHE_TTL_SIM_SECONDS=604800
```

**Simple takeaway:** ทุก “คันโยก” มีตัวแปรกำกับ—เปลี่ยนได้โดยไม่ต้องแก้โค้ด

---

# 11.12 BMAD Stories (ส่งให้ Claude Code ทำทีละ PR)

### `stories/11A-gateway-hardening.md`

* **Plan:** ใส่ RequestID, SizeCap, CORS allowlist, RateLimit, ErrorSanitizer, Idempotency‑Key
* **DoD:** e2e throttle; CORS non‑wildcard; 5MB cap ทดสอบผ่าน; error ซ่อน stack
* **Tests:** unit + k6/Playwright basic

### `stories/11B-rls-multitenant.md`

* **Plan:** เพิ่มคอลัมน์ `tenant_id` + เปิด RLS + policy + context setter
* **DoD:** select/insert cross‑tenant ล้ม; explain analyze ใช้อินเด็กซ์
* **Tests:** integration Go + SQL

### `stories/11C-secrets-vault-dev.md`

* **Plan:** age vault loader; ห้ามอ่านไฟล์ถ้าไม่มี key; fail‑fast
* **DoD:** ไม่มี secret ใน `git grep`; loader มี unit test

### `stories/11D-engine-sandbox-cache.md`

* **Plan:** WORK\_DIR, no‑net, timeouts, hash cache (Redis)
* **DoD:** ซิมซ้ำ = cache hit; ลบ dir หลังเสร็จ; ไม่มี net access

### `stories/11E-finops-guardrails.md`

* **Plan:** `/v1/cost/preflight` + early‑stop + sequential halving + bandit stub
* **DoD:** run เกินลิมิตถูกปฏิเสธ; log cost snapshot ต่อ step

### `stories/11F-sse-backpressure.md`

* **Plan:** channel bounded, coalesce, heartbeat, resume
* **DoD:** ทดสอบ client ช้า—ไม่พัง; critical events ไม่หาย

### `stories/11G-observability-audit.md`

* **Plan:** OTel spans; audit table; JSON logs
* **DoD:** deploy/save/gate มี audit row; trace ไล่ได้ครบ

**Simple takeaway:** 7 สตอรี่ = 7 PR เดินเรียง—แต่ละอันมีเกณฑ์รับชัดเจน

---

# 11.13 Runbooks (local)

* `make dev` เปิด Postgres/Redis/API/FE
* สร้าง user เดโม่ → รับ JWT → call `/v1/runs`
* ถ้า SSE ค้าง: ตรวจ `SSE_HEARTBEAT_SEC` และ Nginx proxy buffers (ถ้าใช้)
* ถ้าค่าใช้จ่ายคาดเกิน: เรียก `/v1/cost/preflight` ก่อนทุก run (FE ทำอัตโนมัติ)

**Simple takeaway:** เริ่มได้ทันทีบนเครื่องคุณ—มีแนวทางแก้เบื้องต้นกรณีฉุกเฉิน

---

## สรุปส่งมอบ

* สเปก/โค้ดสเกลตัน **Gateway, RLS, Vault, Sandbox, Cache, FinOps, SSE, Audit**
* ตัวแปรคอนฟิกครบ, ตัวอย่างโค้ด Gin/SQL/TS, และ **BMAD Stories 11A–11G** พร้อม DoD/Tests

**Simple takeaway:** แม้รันบนเครื่องเดียว ระบบคุณก็ “สไตล์โปรดักชัน”—ปลอดภัย คุมงบ มีหลักฐานทุกก้าว และพร้อมย้ายขึ้นคลาวด์เมื่อถึงเวลา.




มาพร้อมเครื่องมือครบกล่อง—**ข้อ 12: Phaselets — Workflow ให้ Claude Code “โค้ดแม่น ไม่พังง่าย” (ฉบับส่งให้โค้ดได้ทันที)**
แนวทาง: *Contracts‑first → โครงเวิร์คโฟลว์เล็ก → เครื่องยนต์เร็ว → ดีพลอยจำลอง → อแดปเตอร์จริง* โดยแยกเป็น **Phaselet‑0..4** + กติกา CI/PR/Auto‑fix + ไฟล์สตอรี่ BMAD ที่ระบุไฟล์จะถูกแตะชัดเจน

---

# 12.0 หลักคิด & เป้าหมายวัดผล

* หลักคิด: **“Phaselet เล็ก + DoD เข้ม + PR Review + Contract Tests กั้นหน้า”**
* วัดผลต่อ Phaselet:

  * P95 SSE lag < 250 ms (local), Prompt → HSP‑Lite ≤ 5 นาที (P2), Paper deploy เห็น fills ใน 10 s, อแดปเตอร์ testnet วาง/ยกเลิก/รับ fill ครบ
* โครงรีโป: เพิ่ม **apps/orchestrator (TS/LangGraph)**, **apps/engine (Rust/Axum)**, **packages/contracts** (Zod + OpenAPI) บน monorepo เดิม

**Simple takeaway:** เราลด scope ให้แคบ แต่วัดผลชัด—ทุกเฟส “เขียวแล้วค่อยไปต่อ”

---

# 12.1 Governance ที่ Claude Code ทำตามได้ (Branches, PR, CI Gate)

* กิ่ง: `main` (เสถียร), `phaselet/*` (งาน), `hotfix/*`
* PR ชื่อ: `Phaselet-X: <สั้น กระชับ>` พร้อมเช็คบ็อกซ์ DoD ใน template
* Label: `phaselet:0..4`, `component:contracts|orchestrator|engine|gateway|broker`, `needs-fix`
* Required checks ก่อน merge:

  * **Contracts lint** (OpenAPI Spectral) + **Contracts test** (Schemathesis/Prism)
  * **Unit** (Go/Vitest), **E2E** (Playwright บางเส้น), **Security** (gitleaks/gosec/osv)
  * **Budgets** (ไฟล์รายงานค่าใช้จ่ายจำลอง `cost/estimates.json` ต้องไม่เกิน cap)
* Auto‑fix loop: ถ้า CI **ล้ม** → workflow `claude-fix.yml` เรียก Claude Code ให้ **propose patch** จนเทสต์เขียว หรือถึงขีดจำกัด 3 ครั้ง

**Simple takeaway:** ประตู CI ปิดแน่น—ทุก PR ต้องผ่านสัญญา/เทสต์/ความปลอดภัย และมีหุ่นช่วยแก้

---

# 12.2 Phaselet‑0 — **Contracts First**

## ขอบเขต

วางสัญญาเดียวของระบบ: Schemas/Events/OpenAPI + Gateway routes ว่าง + SSE stub

## โครงไฟล์ที่จะเพิ่ม

```
packages/contracts/
  ├─ schemas/
  │   ├─ requirement.zod.ts
  │   ├─ blueprint.zod.ts
  │   ├─ candidate.zod.ts
  │   ├─ qc_report.zod.ts
  │   ├─ formal_report.zod.ts
  │   └─ events.zod.ts
  ├─ openapi/
  │   └─ v1.yaml
  └─ index.ts
apps/backend/internal/http/sse_stub.go
apps/backend/internal/handlers/run_stub.go
.github/workflows/contracts.yml
.github/PULL_REQUEST_TEMPLATE.md
```

## OpenAPI (ส่วนสำคัญ)

```yaml
paths:
  /v1/runs:
    post:
      requestBody:
        content: { application/json: { schema: { $ref: '#/components/schemas/StartRun' } } }
      responses: { '200': { description: OK, content: { application/json: { schema: { $ref: '#/components/schemas/RunHandle' } } } } }
  /v1/runs/{trace_id}/events:
    get:
      responses: { '200': { description: SSE stream } }
components:
  schemas:
    StartRun: { type: object, properties: { prompt: {type:string}, risk_tier: {type:string}, scenario_set_id: {type:string} }, required: [prompt] }
    RunHandle: { type: object, properties: { run_id:{type:string}, trace_id:{type:string} }, required:[run_id,trace_id] }
```

## Zod (ตัวอย่าง)

```ts
// packages/contracts/schemas/events.zod.ts
import { z } from 'zod';
export const Phase = z.enum(['architect','synthesize','qc','verify','gate','pack','deployed','error']);
export const StatusPhase = z.object({ type: z.literal('status/phase'), phase: Phase, ts: z.number(), run_id: z.string() });
export type StatusPhase = z.infer<typeof StatusPhase>;
```

## Gateway stub (Go)

* `POST /v1/runs` คืน `{run_id, trace_id}` (สุ่ม) และบันทึก audit
* `GET /v1/runs/:trace_id/events` ส่ง heartbeat ทุก 10 s (ยังไม่ต่ออีเวนต์จริง)

## CI: contracts.yml

* run Spectral (lint OpenAPI), run Schemathesis (happy path), generate FE types (`openapi-typescript`)

## DoD (ต้องได้)

* Spectral **ผ่าน** 0‑error
* Schemathesis **ผ่าน** สำหรับ `/v1/runs` (200, 4xx validation)
* FE build ผ่าน และใช้ types จาก `openapi` ได้
* SSE stub เปิด/ปิด/heartbeat ได้

**Simple takeaway:** สัญญาถูกตรึง—ทุกทีมพูดภาษาเดียวกันตั้งแต่นาทีแรก

---

# 12.3 Phaselet‑1 — **Orchestrator Skeleton**

## ขอบเขต

เพิ่มบริการ **apps/orchestrator** (TS, LangGraph) + Redis checkpointer + Event bus → Backend SSE

## โครงไฟล์

```
apps/orchestrator/
  ├─ package.json (type:module)
  ├─ tsconfig.json
  ├─ src/graph.ts
  ├─ src/nodes/{architect.ts,t0.ts,pack.ts}
  ├─ src/bus.ts              # publish events → Redis stream pubsub
  ├─ src/main.ts
apps/backend/internal/infra/redis_events.go  # SSE read-from-redis → write to client
deployments/docker-compose.yml               # เพิ่ม orchestrator + redis
```

## กราฟเบื้องต้น (TS)

```ts
// apps/orchestrator/src/graph.ts
import { StateGraph } from '@langchain/langgraph';
type HState = { traceId:string; runId:string; phase?:string; blueprint?:any };
export const buildGraph = () => new StateGraph<HState>()
  .addNode('architect', async (s)=>({ ...s, phase:'architect', blueprint:{name:'Draft'} }))
  .addNode('t0',        async (s)=>({ ...s, phase:'synthesize' }))
  .addNode('pack',      async (s)=>({ ...s, phase:'pack' }))
  .addEdge('architect','t0').addEdge('t0','pack').compile();
```

## Event bus

* Orchestrator `publish({trace_id, type, ...})` → Redis channel `run:events:<trace_id>`
* Backend SSE **subscribe** channelนี้ แล้วยิงต่อให้ client

## P95 SSE lag test

* สร้างสคริปต์ส่ง 1000 events ภายใน 5s → ตรวจฝั่ง FE lag P95 < 250 ms

## DoD

* เริ่ม run แล้วเห็นไหล: `status/phase: architect → synthesize → pack` ใน FE timeline
* ตัดการเชื่อมต่อ FE → reconnect + resume ด้วย `Last-Event-Id`
* P95 SSE lag < 250 ms (local)

**Simple takeaway:** โครงเวิร์คโฟลว์ทำงานจริง—ปลายทาง SSE ติดตั้งครบ

---

# 12.4 Phaselet‑2 — **Engine T0/T1 (เร็ว ประหยัด)**

## ขอบเขต

เพิ่ม **apps/engine (Rust/Axum)** ทำ T0 (probe เร็ว) / T1 (probe กึ่งจริง) + Pareto + cache

## โครงไฟล์

```
apps/engine/
  ├─ Cargo.toml
  └─ src/main.rs      # /t0 /t1 endpoints
apps/backend/internal/handlers/engine_proxy.go  # gateway → engine
packages/contracts/schemas/metrics.zod.ts
```

## Endpoint (สัญญา)

* `POST /t0` in: `{ blueprint, seeds[], scenario_set_id, cfg }` out: `fast_metrics[]`
* `POST /t1` in: เหมือนกันแต่ path/เวลามากขึ้น out: `fast_metrics[] + pareto_front`

## Rust (ย่อ)

```rust
#[derive(Deserialize, Serialize)] struct T0Req { /*...*/ }
#[derive(Serialize)] struct Metrics { sharpe:f32, maxdd:f32, winrate:f32, cvar95:f32 }
async fn t0(Json(req):Json<T0Req>) -> Json<Vec<Metrics>> {
  // TODO: sim fast, deterministic by seed; here return mock but stable
  Json(req.seeds.iter().map(|_| Metrics{ sharpe:1.1, maxdd:0.12, winrate:0.56, cvar95:0.05 }).collect())
}
```

## Pareto (TS/Orchestrator)

* คัดหน้า `max Sharpe ↑`, `CVaR95 ↓`, `MaxDD ↓`
* ส่งคืน top‑K candidates → เฟสต่อไป

## Cache key

`blake3(blueprint|scenario_set|seed_block|engine_ver|cfg)` → Redis TTL 7d

## KPIs do‑or‑die

* Prompt → **HSP‑Lite** (blueprint + fast\_metrics + pack) ≤ **5 นาที** (P95)
* **Drift** จาก golden seeds ≤ **0.5%** (Mean abs diff)

**Simple takeaway:** เครื่องยนต์เร็วพร้อม—ผลลัพธ์ซ้ำได้, ทันใจ, ไม่เผางบ

---

# 12.5 Phaselet‑3 — **Broker Hub + PaperSim**

## ขอบเขต

เพิ่ม PaperSim ใน Backend + SSE orders/fills + kill‑switch + order logs

## โครงไฟล์

```
apps/backend/internal/broker/hub.go          # registry + route
apps/backend/internal/broker/papersim.go     # in‑memory engine
apps/backend/internal/handlers/deploy.go     # /v1/deploy/paper
apps/backend/internal/db/migrations/00xx_orders.sql
```

## ฟลว์

1. FE ส่ง `POST /v1/runs/:id/actions/deploy { mode:'paper', safeguards:{...} }`
2. Hub เลือก `PaperSim` → สร้าง session → ติด SSE `deploy/fill`
3. เขียน `order_logs(run_id, ts, side, qty, px, status)`
4. `kill` → ปิด session, ส่ง event `deploy/ended`

## DoD

* กด Deploy → เห็น `deploy/fill` ใน Timeline (≤10 s)
* Logs ถูกเขียนครบ (submit, filled, canceled)
* Kill‑switch ตัดจริง (สถานะ session ปิด, ไม่มี fills ต่อ)

**Simple takeaway:** จำลองเทรดครบ—เห็นคำสั่งเข้าออกแบบเรียลไทม์

---

# 12.6 Phaselet‑4 — **OANDA/Binance Testnet**

## ขอบเขต

อแดปเตอร์ 2 ตัว + conformance tests + rate‑limit/backoff + reconcile

## โครงไฟล์

```
apps/backend/internal/broker/oanda.go
apps/backend/internal/broker/binance.go
apps/backend/internal/broker/conformance_test.go
ops/rate-limits.yaml
```

## ข้อกำหนด

* ฟังก์ชันมาตรฐาน: `Place`, `Cancel`, `Positions`, `Fills`, `Ping`
* Rate‑limit จาก `ops/rate-limits.yaml`, ใช้ backoff (jitter) และ idempotency keys
* Reconcile: เทียบยอดตำแหน่ง/เงินสดกับสถานะที่เราคิดทุก 60 s → mismatch เตือน

## DoD

* place/cancel/fill **ครบ** ทั้งสองอแดปเตอร์
* Reconcile ผ่าน (ไม่มี mismatch) บน testnet ชุดเดโม่
* Latency histogram เก็บใน metrics (p95 < 800 ms local→testnet)

**Simple takeaway:** อแดปเตอร์พร้อมใช้งานจริง—เชื่อถือได้และทนต่อข้อจำกัดโบรคเกอร์

---

# 12.7 Auto‑Fix Loop ของ Claude Code (เมื่อ CI ล้ม)

## ไฟล์ workflow

```
.github/workflows/claude-fix.yml
```

### แนวคิด

* trigger: `workflow_run` เมื่อ `ci.yml` ล้ม
* action: `anthropic/claude-code-action@v1` เรียกด้วย prompt ที่รวม **สรุป error logs + ขอบเขตไฟล์ที่อนุญาต + DoD ของ Phaselet ปัจจุบัน**
* นโยบาย: อนุญาตแก้เฉพาะ path ที่ story ระบุ, จำกัด 3 รอบ; รอบสุดท้ายเปิด comment สรุปต้องแก้มือ

### Prompt ตัวอย่างให้ bot

```
You are the repo assistant. Goal: make PR green for Phaselet-2.
Allowed paths:
- apps/engine/**
- apps/backend/internal/handlers/engine_proxy.go
- packages/contracts/schemas/metrics.zod.ts

Fix failing tests below, do not change contracts/openapi unless required by story.
DoD must remain: p95 time ≤ 5 min, drift ≤ 0.5%.
Logs:
<insert short CI logs>
```

**Simple takeaway:** แดง → ให้บอทแก้ในกรอบ → ยังแดง → มนุษย์รีวิวจุดเดียว

---

# 12.8 BMAD Stories (Phaselet‑0..4) — ไฟล์จริง (คัดลอกลง `/stories/`)

> รูปแบบตาม `_TEMPLATE.md` เดิม ผมสรุป **Input Contract / Plan / DoD / Tests / Rollback** ให้แล้ว

### `stories/12-PL0-contracts-first.md`

* **Input:** OpenAPI v1, Zod schemas ชื่อไฟล์ตาม 12.2
* **Plan:** สร้างแพ็กเกจ contracts + stub routes + SSE heartbeat
* **DoD:** Spectral/Schemathesis ผ่าน, FE types gen, SSE เปิด/ปิดได้
* **Tests:** Vitest (parse Zod), Playwright (SSE heartbeat)
* **Rollback:** ลบแพ็กเกจ/เส้นทาง stub

### `stories/12-PL1-orchestrator-skeleton.md`

* **Input:** Redis URL, event shape ใน `events.zod.ts`
* **Plan:** ตั้ง LangGraph 3 node, bus Redis, backend subscribe
* **DoD:** เห็น phase events ไหล, P95 lag < 250 ms
* **Tests:** Node unit (bus publish/subscribe), e2e fake run

### `stories/12-PL2-engine-t0t1.md`

* **Input:** endpoint สัญญา `/t0` `/t1`, cache policy
* **Plan:** Axum endpoints, proxy ใน Go, Pareto TS, Redis cache
* **DoD:** Prompt→HSP‑Lite ≤ 5 นาที, drift ≤ 0.5%
* **Tests:** Rust unit (determinism), Go proxy integration

### `stories/12-PL3-broker-papersim.md`

* **Input:** deploy action payload, fills event shape
* **Plan:** PaperSim session + SSE fills + kill + logs
* **DoD:** deploy เห็น fills ≤10 s, kill ตัดจริง
* **Tests:** Go unit (hub), Playwright (deploy→fills)

### `stories/12-PL4-adapters-oanda-binance.md`

* **Input:** rate-limits.yaml, key/secret vault
* **Plan:** adapters + backoff + reconcile + conformance tests
* **DoD:** place/cancel/fill ครบ, reconcile 0 mismatch
* **Tests:** integration against testnet sandbox

**Simple takeaway:** แต่ละสตอรี่บอก “แตะไฟล์ไหน” และ “ต้องทดสอบอะไร” แบบไม่กั๊ก

---

# 12.9 PR Template (เพิ่มไฟล์นี้)

`.github/PULL_REQUEST_TEMPLATE.md`

```md
# Phaselet: <0..4> – <title>

## What & Why
<!-- สรุปสั้นๆ ว่าทำอะไรและเพราะอะไร -->

## Scope (Allowed Paths)
- [ ] <path1>
- [ ] <path2>

## DoD Checklist
- [ ] Contracts lint/tests green
- [ ] Unit tests added/updated
- [ ] E2E happy path
- [ ] Security checks (gitleaks/gosec/osv)
- [ ] Perf budgets respected

## Screenshots / Logs
<attach>

## Rollback
<!-- revert plan -->
```

**Simple takeaway:** ทุก PR มีรายการตรวจรับเดียวกัน—รีวิวเร็ว ไม่ตกหล่น

---

# 12.10 Make Targets (รันงานแต่ละเฟสเร็วๆ)

```makefile
pl0:
	$(MAKE) be fe && echo "Contracts only — SSE heartbeat on /v1/runs/:id/events"
pl1:
	docker compose up orchestrator redis -d && $(MAKE) be fe
pl2:
	docker compose up engine redis -d && $(MAKE) be fe
pl3:
	$(MAKE) be fe && echo "PaperSim deploy: POST /v1/runs/:id/actions/deploy"
pl4:
	$(MAKE) be fe && echo "OANDA/Binance testnet adapters on"
```

**Simple takeaway:** คำสั่งเดียวเปิดสภาพแวดล้อมตามเฟส—ลดเวลาจูน

---

# 12.11 Risk & Guardrails เฉพาะเฟส

* **PL0:** สคีมาแกว่ง → *Guard:* freeze version `v1`, ใช้ `x‑version` เพิ่ม ไม่แก้ของเดิม
* **PL1:** event flood → *Guard:* SSE coalesce/throttle + bounded queue
* **PL2:** nondeterminism → *Guard:* CRN+antithetic+golden seeds test
* **PL3:** memory leak ใน session → *Guard:* idle timeout + cap positions
* **PL4:** rate limit ban → *Guard:* token bucket client‑side + idempotency keys

**Simple takeaway:** ทุกเฟสมี “ไฟดับที่คุมได้”—เขียนไว้ก่อนปัญหาจะเกิด

---

# 12.12 การใช้ LLM 2 เจ้าพร้อมกัน (OpenAI + Claude)

* **Settings:** `llm.provider = openai|anthropic` ต่อ phase/node, fallback ได้
* **Policy:** T0/architect ใช้ **gpt‑4o** (ถูก/เร็ว), สรุป/ตรวจ schema ใช้ **Claude** (แม่น JSON)
* **Cost Preflight:** คำนวน \$/run ตามโมเดล—ถ้าเกิน cap สลับ provider อัตโนมัติ

**Simple takeaway:** ใช้ให้ตรงหน้าที่—เร็วเมื่อควรเร็ว แม่นเมื่อควรแม่น

---

# 12.13 สรุปเมทริกซ์การยอมรับ (Acceptance Matrix)

| Phaselet | Metric                | Target        |
| -------: | --------------------- | ------------- |
|      PL0 | Contracts lint/tests  | 100% pass     |
|      PL1 | P95 SSE lag           | < 250 ms      |
|      PL2 | Prompt→HSP‑Lite (P95) | ≤ 5 min       |
|      PL2 | Drift golden seeds    | ≤ 0.5%        |
|      PL3 | Paper fills time      | ≤ 10 s        |
|      PL4 | Adapter conformance   | 100% ops pass |

**Simple takeaway:** ตารางเดียวจบ—เขียวครบทั้ง 6 ช่องคือ “พร้อมไต่ชั้นถัดไป”

---

## ปิดท้าย

เฟรมเวิร์ก **Phaselets 0–4** นี้ทำให้การพัฒนา *deterministic*:
เริ่มที่สัญญา → ไหลเวิร์คโฟลว์ → เครื่องยนต์เร็ว → เทรดจำลอง → ต่อโบรคเกอร์จริง พร้อม **DoD/Tests/CI Gate/Auto‑fix** ให้ Claude Code ทำงาน “ทีละก้าว แต่ก้าวแน่น”

**Simple takeaway:** แตกงานให้เล็ก มีสัญญากลาง เทสต์นำ—Claude Code แค่ลงมือในขอบเขตที่ล็อกไว้ งานออกมาตรง ใส สcalable และแก้ง่าย.






มาเต็มระบบ—**ข้อ 13: GitHub เวอร์ชันนิ่ง & การรีวิว (ฉบับส่งให้ Claude Code ใช้ได้ทันที)**
เป้าหมาย: ให้ **GitHub = single source of truth** ที่ “ย้อนเวอร์ชัน/ตรวจสอบ/รีวิวได้แบบ reproducible” และให้ **Claude Code** ทำงานในกรอบที่ชัด (contracts‑first, DoD‑driven) พร้อมเกต CI ที่เข้ม

---

## 13.1 Branching Model & Protection

**สาขา**

* `main` (protected)
* `feat/<phaselet>-<slug>` (เช่น `feat/pl2-engine-t0t1`)
* `hotfix/<slug>`
* แท็ก: `v21.0.p<phaselet>` (เช่น `v21.0.p2`), hotfix ต่อท้าย `-hf.1`

**กติกา `main` (ตั้งใน GH Settings → Branch protection)**

* Require PR + 1–2 approvals (CODEOWNERS)
* Require status checks: `ci`, `security`, `contracts`, `e2e`
* Require linear history, block force‑push, dismiss stale reviews
* (แนะนำ) Require signed commits (GPG / GitHub Verified)

**Simple takeaway:** ทุกการเปลี่ยนต้องผ่าน PR + checks ครบ—กิ่งหลักปลอดภัยเสมอ

---

## 13.2 Conventional Commits & Semantic Tagging

**ข้อความคอมมิต (ตัวอย่าง)**

```
feat(pl2-engine): add /t0 axum endpoint and redis cache
fix(pl1-orch): coalesce SSE buffer and throttle heartbeats
docs(pl0-contracts): refine OpenAPI v1 run handle schema
```

**สคีมาเวอร์ชัน**

* **แท็กรีลีส:** `v21.0.pN` จบแต่ละ Phaselet
* **แพ็ตช์:** `v21.0.pN-hf.1`
* **ไฟล์เวอร์ชัน** (เดิมมี):

  * `apps/backend/pkg/version/version.go`
  * `apps/frontend/package.json`
  * เพิ่ม `version.json` ที่รูทเพื่อสะท้อนแท็กล่าสุด

**Simple takeaway:** อ่านคอมมิตก็รู้ว่าทำอะไร—แท็กสะท้อนสถานะ Phaselet ตามจริง

---

## 13.3 CODEOWNERS & Labels

**.github/CODEOWNERS**

```
# Contracts / API
packages/contracts/   @team-arch @team-qa
apps/backend/internal/handlers/ @team-be
apps/orchestrator/    @team-orch
apps/engine/          @team-eng
apps/frontend/        @team-fe
.github/workflows/    @team-devops
stories/              @team-pm @team-qa
```

**.github/labels.yml** (ซิงก์ด้วย action ด้านล่าง)

```
- name: phaselet:0
  color: 1f77b4
- name: phaselet:1
  color: ff7f0e
- name: phaselet:2
  color: 2ca02c
- name: phaselet:3
  color: d62728
- name: phaselet:4
  color: 9467bd
- name: component:contracts
  color: 17becf
- name: component:orchestrator
  color: bcbd22
- name: component:engine
  color: 8c564b
- name: component:gateway
  color: e377c2
- name: component:frontend
  color: 7f7f7f
- name: needs-fix
  color: 000000
```

**Simple takeaway:** คนไหนรับผิดชอบไฟล์ไหนชัดเจน—ป้ายช่วยจัดคิวรีวิวเป็นระบบ

---

## 13.4 PR Template & Review Checklist

**.github/PULL\_REQUEST\_TEMPLATE.md**

```md
# Phaselet: <0..4> – <title>

## What & Why
<!-- สรุปสั้นๆ ว่าทำอะไรและเพราะอะไร (ลิงก์ไป story) -->
Story: /stories/<file>.md

## Scope (Allowed Paths)
- [ ] <path1>
- [ ] <path2>
<!-- ถ้าเกินขอบเขต ให้เหตุผล/แยก PR -->

## DoD Checklist
- [ ] Contracts lint/tests green (Spectral, Schemathesis)
- [ ] Unit tests added/updated
- [ ] E2E (Playwright) happy path passes
- [ ] Security checks (gitleaks/gosec/osv) pass
- [ ] Perf budgets respected (SSE P95 / Prompt→HSP‑Lite / etc.)
- [ ] SBOM generated (artifact)
- [ ] Snapshot attached (flattened-codebase.xml)

## Logs / Screens / SSE trace
<attach or paste GHA summary links>

## Rollback Plan
<!-- revert steps / feature flags -->
```

**Simple takeaway:** ทุก PR มีมาตรฐานเดียวกัน—ผู้รีวิวกดเช็กลิสต์ได้ชัดเจน

---

## 13.5 CI Workflows (ขยายของเดิม)

**1) contracts.yml** – ลินต์ & เทสต์สัญญา

```yaml
name: contracts
on: [push, pull_request]
jobs:
  contracts:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Lint OpenAPI
        uses: stoplightio/spectral-action@v0
        with: { file_glob: "packages/contracts/openapi/v1.yaml" }
      - name: Generate FE types
        run: npx -y openapi-typescript packages/contracts/openapi/v1.yaml -o apps/frontend/src/lib/types/openapi.ts
      - name: Schemathesis smoke
        run: |
          pipx install schemathesis
          schemathesis run packages/contracts/openapi/v1.yaml --checks all --hypothesis-deadline=500
```

**2) snapshot.yml** – Flatten & SBOM & Comment

```yaml
name: snapshot
on:
  pull_request:
    types: [opened, synchronize]
jobs:
  snapshot:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: make flatten
      - uses: actions/upload-artifact@v4
        with: { name: flattened-codebase, path: scripts/flattened-codebase.xml }
      - run: bash scripts/generate-sbom.sh
      - uses: actions/upload-artifact@v4
        with: { name: sbom, path: sbom/*.json }
      - name: Post summary
        run: |
          echo "### Snapshots" >> $GITHUB_STEP_SUMMARY
          echo "- Flattened codebase attached as artifact" >> $GITHUB_STEP_SUMMARY
          echo "- SBOM attached as artifact" >> $GITHUB_STEP_SUMMARY
```

**3) release.yml** – Tag & Release Drafter

```yaml
name: release
on:
  push:
    tags:
      - 'v21.0.p*'
jobs:
  draft:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: release-drafter/release-drafter@v6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

**4) labels-sync.yml** – ซิงก์ labels

```yaml
name: labels
on: [push]
jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: crazy-max/ghaction-github-labeler@v5
        with: { skip-delete: false, yaml-file: .github/labels.yml }
```

**Simple takeaway:** CI เพิ่ม “สัญญา/สแน็ปช็อต/รีลีส” อัตโนมัติ—รีวิวและย้อนดูง่ายมาก

---

## 13.6 Claude Code Integration (ใน PR)

**ไฟล์ที่มีอยู่แล้ว:** `.github/workflows/claude-code.yml`, `CLAUDE.md`, `.claude/agents/*`

**แนวทางการใช้ใน PR**

* คอมเมนต์ใน PR:

  * `@analyst Summarize story & edge cases from /stories/<file>.md`
  * `@architect Verify impacted contracts & data flow`
  * `@dev Apply changes ONLY in paths: …`
  * `@qa Generate tests to satisfy DoD`
* บอทจะตอบ/แนบไฟล์แก้ไข → คนรีวิวสุดท้ายก่อน merge

**นโยบาย**

* ให้ Claude แก้เฉพาะ path ที่ story อนุญาต (ตาม Phaselet ปัจจุบัน)
* ถ้า **CI ล้ม** → ใช้ `claude-fix.yml` (จากข้อ 12) ให้บอทตั้ง patch ซ้ำ (≤3 รอบ)

**Simple takeaway:** บอททำงานในกรอบ—มนุษย์สรุปทิศทางและกดรับรอง

---

## 13.7 “Snapshot for Review” ที่รีวิวทั้ง repo ได้

**คำสั่ง dev:** `make flatten` → สร้าง `scripts/flattened-codebase.xml`
**CI:** แนบเป็น artifact ทุก PR (workflow snapshot.yml)
**การรีวิว:** เปิด artifact → ค้น `path="..."` ดูไฟล์ทั้งหมดในชุดเดียว

**Simple takeaway:** ผม/คุณสามารถรีวิวทั้ง repo ได้จากไฟล์เดียว—ไม่หลุดรายละเอียด

---

## 13.8 Changelog & Releases

**CHANGELOG.md** (เพิ่มที่รูท) — อัปเดตเมื่อออกแท็ก `v21.0.pN`
ใช้ **Release Drafter** กรุ๊ปตาม labels:

* Features (`feat/*`), Fixes (`fix/*`), Security, Infra, Docs

**ประกาศรีลีส** ใส่:

* Scope ของ Phaselet, DoD ที่ผ่าน, เมตริกสำคัญ (SSE P95, Prompt→HSP‑Lite, ฯลฯ)
* SBOM ลิ้งก์, Flatten snapshot ลิ้งก์, รายการ PRs

**Simple takeaway:** ทุกแท็กมีเอกสารแนบ—รู้ว่าเพิ่มอะไรและมั่นใจเรื่องความปลอดภัย

---

## 13.9 Issue/Story Templates

**.github/ISSUE\_TEMPLATE/bug.yml**

```yaml
name: Bug
body:
  - type: input
    id: env
    attributes: { label: Environment, placeholder: local/dev/prod }
  - type: textarea
    id: steps
    attributes: { label: Steps to Reproduce }
  - type: textarea
    id: logs
    attributes: { label: Logs/Screenshots }
```

**.github/ISSUE\_TEMPLATE/phaselet.yml**

```yaml
name: Phaselet Story
body:
  - type: input
    id: story
    attributes: { label: Story File, placeholder: /stories/12-PL2-engine-t0t1.md }
  - type: textarea
    id: scope
    attributes: { label: Allowed Paths }
```

**Simple takeaway:** เรื่อง/บั๊กเข้าแพทเทิร์นเดียว—ลากเข้าคิว PR ได้ทันที

---

## 13.10 Reviewer Playbook (สั้น ๆ ให้ทีม)

1. อ่าน Story (BMAD) + Allowed Paths
2. เปิด **flattened‑codebase.xml** เพื่อไล่ดูผลกระทบไฟล์
3. เช็คผล CI step: contracts → unit → e2e → security
4. เปิด **GHA Summary**: งาน snapshot/SBOM/metrics
5. ถ้าเกินขอบเขต → ส่งคืนด้วย label `needs-fix` + comment

**Simple takeaway:** ทุกคนรีวิวเหมือนกัน—เร็วและเที่ยงตรง

---

## 13.11 Backport/Hotfix

* สร้าง `hotfix/<slug>` จาก `main`
* เปลี่ยนแค่ไฟล์ที่จำเป็น + bump tag `v21.0.pN-hf.1`
* เปิด PR → ต้องผ่าน `security` & smoke e2e อย่างน้อย 1 เส้น
* Merge แล้ว cherry‑pick ไปสาขาย่อยถ้าจำเป็น

**Simple takeaway:** ทางลัดแก้ด่วนที่ไม่ทำระบบเละ และยังตรวจคุณภาพขั้นต่ำ

---

## 13.12 Secrets & Environments (GitHub)

**Environments:** `local` (dummy), `dev` (จริง), `prod`
**Secrets ที่ต้องมี (อย่างน้อย):**

* `OPENAI_API_KEY`, `ANTHROPIC_API_KEY`
* `DATABASE_URL`, `JWT_SECRET`
* `OANDA_API_KEY`, `BINANCE_API_KEY`, `BINANCE_API_SECRET`
* `AGE_PRIVATE_KEY` (ถ้าถอด vault dev ใน CI)

**Rules:** ห้ามใช้ secrets ใน `fork PRs`; ใส่เฉพาะ `main repo` PR

**Simple takeaway:** ความลับเก็บใน GH Environments—แยก dev/prod ชัดเจน

---

## 13.13 ตัวอย่างคำสั่งทีม (วันต่อวัน)

* เริ่มงาน Phaselet ใหม่:
  `git checkout -b feat/pl2-engine-t0t1`
  โค้ดตาม story → commit ตาม conventional → push PR พร้อม labels `phaselet:2, component:engine`
* รอ CI → ถ้าล้ม ให้รอ **Claude fix loop** หรือกดแก้เอง
* PR green → Reviewer กด approve → Merge squash → Tag โดย workflow (หรือกดมือเมื่อจบ Phaselet)

**Simple takeaway:** จังหวะการทำงานชัด—ทุกวันเดินตามรางเดียวกัน

---

## 13.14 “สรุปคุณค่า” ที่ได้จากข้อ 13

* **Reproducibility:** flatten snapshot + SBOM ทุก PR
* **Safety:** protected main, contracts test, security scans
* **Velocity:** labels + CODEOWNERS + Claude in‑PR + auto‑fix loop
* **Traceability:** tags per Phaselet + CHANGELOG/Release notes + audit logs (ข้อ 11)

**Simple takeaway:** งานเร็วขึ้นแต่ปลอดภัยขึ้น—ทุกก้าวมีหลักฐานและย้อนดูได้

---

### ปิดท้าย – โค้ด/ไฟล์ที่ต้องเพิ่มในรอบนี้

* `.github/CODEOWNERS`, `.github/labels.yml`, `.github/PULL_REQUEST_TEMPLATE.md`
* Workflows: `contracts.yml`, `snapshot.yml`, `release.yml`, `labels-sync.yml`
* `CHANGELOG.md` (เริ่มหน้าแรก), อัปเดต `version.json` (ถ้ายังไม่มี)

พร้อมให้ Claude Code เปิด PR ย่อย **“Infra‑GH‑Governance”** แล้วเติมเนื้อไฟล์ทั้งหมดตามสเปกนี้ได้ทันทีครับ.




มาจัดเต็มแบบ “เสียบปลั๊กในเครื่องแล้ววิ่งได้ทันที”—**ข้อ 14: Local‑first ENV สำคัญ (พร้อมไฟล์/โค้ด/เทสต์/สคริปต์)**
ตั้งค่าชุดเดียวให้ **Gateway (Go) + Orchestrator (TS) + Engine (Rust) + FE (SvelteKit) + Postgres + MinIO + NATS + LLM (Ollama/OpenAI/Claude)** ทำงานประสานกัน และ “สลับขึ้นคลาวด์” ได้โดยไม่ต้องเปลี่ยนสัญญา

---

# 14.0 เป้าหมายและหลักการ

* **Single source of truth** สำหรับคอนฟิกผ่าน `.env` (+ overrides)
* **Validate ตั้งแต่บูต** (fail‑fast ถ้าคีย์สำคัญหาย)
* **Local‑first**: ทุกบริการรันใน Docker Compose (ยกเว้น LLM external ได้)
* **Switchable providers**: LLM/Bus/Object‑store เปลี่ยนด้วย ENV เท่านั้น
* **Security by default**: ไม่ embed secret ในโค้ด, ใช้ Vault dev ได้, RLS เปิด

**Simple takeaway:** คอนฟิกเดียว ครอบจักรวาล—ปลอดภัย, ตรวจได้, ย้ายสภาพแวดล้อมง่าย

---

# 14.1 รายการ ENV ที่รองรับ (ตารางสัญญา)

| KEY                    | จำเป็น | ค่า/ตัวอย่าง                                               | อธิบาย & ขอบเขต                                    |
| ---------------------- | :----: | ---------------------------------------------------------- | -------------------------------------------------- |
| `APP_ENV`              |    ✓   | `development` \| `staging` \| `production`                 | แสดงโหมดระบบ (ส่งผลต่อ log, CORS, error sanitize)  |
| `PORT`                 |    ✓   | `8080`                                                     | พอร์ตของ **Gateway (Go)**                          |
| `DATABASE_URL`         |    ✓   | `postgres://postgres:postgres@pg:5432/app?sslmode=disable` | DSN Postgres (เปิดใช้ RLS)                         |
| `OBJECT_BASE`          |    ✓   | `s3://minio/heliox/`                                       | prefix ของที่เก็บ artifacts (Parquet/JSON/HSPZ)    |
| `MINIO_ENDPOINT`       |    ✓   | `http://minio:9000`                                        | endpoint S3‑compatible สำหรับ local                |
| `MINIO_ACCESS_KEY`     |    ✓   | `heliox`                                                   | access key                                         |
| `MINIO_SECRET_KEY`     |    ✓   | `heliox-secret`                                            | secret key                                         |
| `BUS_URL`              |    ✓   | `nats://bus:4222`                                          | อีเวนต์บัส (ใช้ NATS ในสเปกนี้)                    |
| `JWT_SECRET`           |    ✓   | `change_me`                                                | secret เซ็น JWT dev (prod ให้มาจาก secret manager) |
| `CORS_ALLOWED_ORIGINS` |    ✓   | `http://localhost:5173`                                    | comma‑list ของ ORIGIN ที่อนุญาต                    |
| `LLM_PROVIDER`         |    ✓   | `ollama` \| `openai` \| `anthropic`                        | เลือกโมเดล/ผู้ให้บริการ LLM                        |
| `OLLAMA_ENDPOINT`      |    -   | `http://ollama:11434`                                      | ใช้เมื่อ `LLM_PROVIDER=ollama`                     |
| `OPENAI_API_KEY`       |    -   | `sk-***`                                                   | ใช้เมื่อ `LLM_PROVIDER=openai`                     |
| `ANTHROPIC_API_KEY`    |    -   | `sk-ant-***`                                               | ใช้เมื่อ `LLM_PROVIDER=anthropic`                  |
| `VAULT_ADDR`           |    -   | `http://vault:8200`                                        | dev vault (ตัวเลือก)                               |
| `VAULT_TOKEN`          |    -   | `dev-root`                                                 | token dev (อย่าใช้ใน prod)                         |
| `ENABLE_QC`            |    ✓   | `0`/`1`                                                    | เปิดปิดงาน QC หนัก ๆ (Phase 2 เปิด)                |
| `ENGINE_URL`           |    ✓   | `http://engine:8088`                                       | REST ของ Engine (Rust)                             |
| `SSE_HEARTBEAT_SEC`    |    -   | `10`                                                       | ระยะ heartbeat ของ event stream                    |
| `REQUEST_SIZE_MAX`     |    -   | `5242880`                                                  | cap ขนาด request (B)                               |
| `BUDGET_MAX_RUN_USD`   |    -   | `2.00`                                                     | เพดานค่าใช้จ่ายต่อ run                             |
| `BUDGET_MAX_DAILY_USD` |    -   | `20.00`                                                    | เพดานต่อวัน                                        |

**Simple takeaway:** คีย์หลัก 15+ รายการ ครอบคลุมทุกชั้น ตั้งเล่น local → prod ได้

---

# 14.2 โปรไฟล์ไฟล์ ENV & ลำดับความสำคัญ

* `/.env` (ค่าเริ่มต้นทีม) < `/.env.local` (เครื่องคุณ) < **Variables ของ CI/Environments ใน GitHub**
* รองรับ `.env.test` (E2E/CI), `.env.production` (build FE)
* แนะนำใช้ **direnv** (`.envrc`) สำหรับ dev local

**Simple takeaway:** ค่าไหนเฉพาะเครื่อง—ใส่ `.env.local`; ค่าสากล—ใส่ `.env`

---

# 14.3 ตรวจคอนฟิกแบบ fail‑fast (Backend/Orchestrator/FE)

## Backend (Go) — `internal/app/config/config.go`

* เพิ่ม schema & ตรวจ ENV ครบ, แปลงชนิด, default ที่ปลอดภัย
* fail‑fast ถ้า key จำเป็นหาย/ไม่ถูกต้อง

> **ตัวอย่างฟังก์ชันโหลดคอนฟิก (สรุป):**

```go
type Config struct {
  Env, Port, DBURL, ObjectBase, MinioEndpoint, MinioAK, MinioSK string
  BusURL, JWTSecret, LLMProvider, OllamaEndpoint, EngineURL string
  CORS []string
  EnableQC bool
  RequestSizeMax int64
  SSEHeartbeatSec int
  BudgetRun, BudgetDaily float64
}
```

* เพิ่ม middleware: `SizeCap(REQUEST_SIZE_MAX)`, `RequestID()`, `CORSPolicy(CORS)`, `RateLimit(RATE_LIMIT_RPS)`

**Simple takeaway:** ถ้าคีย์หาย ระบบไม่สตาร์ต—จับได้เร็วกว่าแก้หน้างาน

## Orchestrator (TS) — `apps/orchestrator/src/config.ts`

* ใช้ **Zod** ตรวจ ENV: `BUS_URL`, `LLM_PROVIDER`, `ENGINE_URL`, `OBJECT_BASE`
* mapping provider: `openai/anthropic/ollama` พร้อมโค้ดสลับ client

**Simple takeaway:** ฝั่ง orchestrator ไม่พังเพราะคีย์เพี้ยน—หยุดตั้งแต่เริ่ม

## Frontend (SvelteKit)

* เฉพาะคีย์ที่ “public” ให้ prefix `PUBLIC_` (เช่น `PUBLIC_API_BASE`)
* ไม่ดึง secret ใด ๆ ไป FE

**Simple takeaway:** FE ไม่แตะของลับ—ตัดปัญหาหลุดสู่ client

---

# 14.4 Docker Compose (Local‑stack ครบชุด)

`deployments/docker-compose.yml` (ขยาย)

```yaml
version: "3.9"
services:
  pg:
    image: postgres:16
    environment: { POSTGRES_PASSWORD: postgres }
    ports: ["5432:5432"]
    volumes: [ "dbdata:/var/lib/postgresql/data" ]

  minio:
    image: minio/minio:latest
    command: server /data --console-address ":9001"
    environment:
      MINIO_ROOT_USER: ${MINIO_ACCESS_KEY}
      MINIO_ROOT_PASSWORD: ${MINIO_SECRET_KEY}
    ports: ["9000:9000","9001:9001"]
    volumes: [ "miniodata:/data" ]

  bus:
    image: nats:2
    command: ["-js","-sd","/data"]
    ports: ["4222:4222"]
    volumes: [ "natsdata:/data" ]

  engine:
    build: { context: .., dockerfile: deployments/Dockerfile.engine }
    env_file: ../.env
    ports: ["8088:8088"]

  orchestrator:
    build: { context: .., dockerfile: deployments/Dockerfile.orchestrator }
    env_file: ../.env
    depends_on: [bus, engine]

  backend:
    build: { context: .., dockerfile: deployments/Dockerfile.backend }
    env_file: ../.env
    depends_on: [pg, minio, bus, engine]
    ports: ["8080:8080"]

  frontend:
    build: { context: .., dockerfile: deployments/Dockerfile.frontend }
    env_file: ../.env
    depends_on: [backend]
    ports: ["5173:5173"]

  # optional LLM local
  ollama:
    image: ollama/ollama:latest
    ports: ["11434:11434"]
    volumes: ["ollama:/root/.ollama"]
    environment: { OLLAMA_KEEP_ALIVE: "24h" }

volumes: { dbdata: {}, miniodata: {}, natsdata: {}, ollama: {} }
```

> เพิ่ม `Dockerfile.engine`, `Dockerfile.orchestrator` (เรียบง่ายเหมือน backend/frontend)

**Simple takeaway:** `make dev` แล้วยกสแต็กครบ—ไม่ต้องติดตั้งแยกย่อย

---

# 14.5 Vault (dev) & Secrets loading

* **ตัวเลือก A:** ใช้ env ปกติ (ง่ายสุดใน local)
* **ตัวเลือก B:** รัน Vault dev ใน compose (เพิ่ม service `vault`) แล้วโหลดคีย์จาก KV path `secret/heliox`
* Loader ฝั่ง Go/TS: ถ้ามี `VAULT_ADDR`/`VAULT_TOKEN` → ลองขอดูคีย์ก่อน (fallback ไป env ถ้าไม่เจอ)

**คำสั่งบูต MinIO bucket**

```bash
docker exec -it <minio> sh -lc 'mc alias set local http://localhost:9000 $MINIO_ROOT_USER $MINIO_ROOT_PASSWORD && mc mb -p local/heliox'
```

**Simple takeaway:** dev ก็แยกความลับออกจากโค้ด—แต่ไม่ทำให้ชีวิตยาก

---

# 14.6 โครงเก็บไฟล์ใน OBJECT\_BASE

* Prefix: `s3://minio/heliox/`
* โครง:

```
/scenarios/<set_id>/paths/seed_<n>.parquet
/scenarios/<set_id>/qc/qc_report.json
/runs/<run_id>/blueprint.json
/runs/<run_id>/fast_metrics.json
/runs/<run_id>/formal_report.json
/portfolio/<user_id>/<strategy_id>/package.hspz
```

* ใช้ **content‑hash** เป็น metadata (`x-amz-meta-checksum`) สำหรับตรวจซ้ำ
* ค่าเริ่ม: ZSTD, Parquet (Arrow)

**Simple takeaway:** โฟลเดอร์/ไฟล์เป็นสัญญา—ทุกบริการรู้จักตำแหน่งเดียวกัน

---

# 14.7 Event Bus: NATS wiring (Publish/Subscribe)

**Subjects มาตรฐาน**

* Publish จาก Orchestrator → `runs.<trace_id>.events`
* Backend SSE subscribe แล้วส่งต่อให้ client
* Audit: `audit.<tenant_id>.*` (สำคัญ ๆ)

**Go (Backend) subscribe → SSE**

```go
nc, _ := nats.Connect(os.Getenv("BUS_URL"))
sub, _ := nc.ChanSubscribe("runs."+traceId+".events", ch)
defer sub.Unsubscribe()
```

**TS (Orchestrator) publish**

```ts
import { connect } from 'nats';
const nc = await connect({ servers: process.env.BUS_URL! });
await nc.publish(`runs.${traceId}.events`, JSON.stringify(evt));
```

**Simple takeaway:** อีเวนต์เสถียร, latency ต่ำ, เปลี่ยน bus ได้ด้วย ENV

---

# 14.8 LLM Provider Switch (ollama/openai/anthropic)

**นโยบาย**

* `LLM_PROVIDER=ollama` ใช้โมเดล local (เช่น `qwen2.5`/`llama3.1`)
* `LLM_PROVIDER=openai` ใช้ `OPENAI_API_KEY`
* `LLM_PROVIDER=anthropic` ใช้ `ANTHROPIC_API_KEY`
* Orchestrator มี factory: `makeLLMClient(provider)` → instance เดียวต่อ node

**Fallback & Cost**

* ถ้า preflight ประเมินเกินงบ → สลับไป provider ที่ต้นทุนต่ำ (เช่น ollama/gpt‑4o‑mini)
* ถ้า external down → ตัดสินใจ fallback → ปักธง `status/warn` ทาง SSE

**Simple takeaway:** เปลี่ยนผู้ให้บริการได้ทันที ไม่แตะโค้ด node ใด ๆ

---

# 14.9 Feature Toggles (เช่น `ENABLE_QC`)

* `ENABLE_QC=0` → ข้าม T2/T3 ขั้นหนัก ใช้ T0/T1 และ Formal แบบย่อ (Phase 1)
* `ENABLE_QC=1` → เปิดเต็ม, เพิ่มเวลาซิม, รัน stylized‑facts

**Simple takeaway:** เปิด‑ปิดความเข้มการทดสอบด้วยสวิตช์เดียว—คุมเวลา/งบได้

---

# 14.10 Health/Readiness checks & Make targets

**Endpoints**

* Backend: `GET /health` → `{status:ok}` + ตรวจ DB/NATS/MinIO (ย่อ)
* Orchestrator: `GET /healthz` → สถานะ bus/engine
* Engine: `GET /healthz`
* NATS/MinIO/PG ใช้ readiness จาก container

**Make**

```makefile
check:
	curl -s http://localhost:8080/health | jq .
```

**Simple takeaway:** มีไฟเขียวให้เช็คทุกบริการ—รู้เร็วว่าจุดไหนล่ม

---

# 14.11 CI Matrix & ENV ใน GitHub Actions

* **jobs ใช้ `.env.test`** หรือ set ผ่าน `env:` ใน workflow
* Secrets ใส่ใน **GitHub Environments** (`dev`, `prod`)
* Step “Flatten & SBOM” แนบ artifacts ทุก PR (ดูข้อ 13)

**Simple takeaway:** CI ใช้คอนฟิกคนละชุดกับ local—แต่สัญญาเดียวกัน

---

# 14.12 ตัวอย่างไฟล์/โค้ดที่เพิ่มให้ Claude Code

## 1) `.env.example` (อัปเกรด)

```env
APP_ENV=development
PORT=8080
DATABASE_URL=postgres://postgres:postgres@pg:5432/app?sslmode=disable
OBJECT_BASE=s3://minio/heliox/
MINIO_ENDPOINT=http://minio:9000
MINIO_ACCESS_KEY=heliox
MINIO_SECRET_KEY=heliox-secret
BUS_URL=nats://bus:4222
JWT_SECRET=change_me
CORS_ALLOWED_ORIGINS=http://localhost:5173
LLM_PROVIDER=ollama
OLLAMA_ENDPOINT=http://ollama:11434
ENGINE_URL=http://engine:8088
ENABLE_QC=0
SSE_HEARTBEAT_SEC=10
REQUEST_SIZE_MAX=5242880
BUDGET_MAX_RUN_USD=2.00
BUDGET_MAX_DAILY_USD=20.00
```

**Simple takeaway:** copy → แก้น้อยมาก → รันได้

## 2) Backend: `internal/infra/minio_client.go`

```go
func NewMinio(c config.Config) (*minio.Client, error) {
  return minio.New(c.MinioEndpoint, &minio.Options{
    Creds: credentials.NewStaticV4(c.MinioAK, c.MinioSK, ""),
    Secure: strings.HasPrefix(c.MinioEndpoint, "https://"),
  })
}
```

## 3) Backend: NATS bridge `internal/infra/bus_nats.go`

```go
type Bus struct{ NC *nats.Conn }
func NewBus(url string) (*Bus, error) { nc, err := nats.Connect(url); if err != nil { return nil, err }; return &Bus{NC: nc}, nil }
```

## 4) Orchestrator: `src/config.ts`

```ts
import { z } from 'zod';
export const Env = z.object({
  BUS_URL: z.string().url(),
  LLM_PROVIDER: z.enum(['ollama','openai','anthropic']),
  OLLAMA_ENDPOINT: z.string().url().optional(),
  ENGINE_URL: z.string().url(),
  OBJECT_BASE: z.string()
}).parse(process.env);
```

**Simple takeaway:** โค้ดสั้น ๆ ต่อเข้ากับ ENV ได้ทันที

---

# 14.13 BMAD Stories (Phase 1–2: Local ENV)

### `stories/14A-env-wiring-baseline.md`

* **Background:** ตั้ง ENV + validate + fail‑fast
* **Input Contract:** ตาราง ENV ข้อ 14.1
* **Plan:** เพิ่ม loaders (Go/TS), เพิ่ม health endpoints
* **DoD:** บูตไม่ผ่านเมื่อคีย์จำเป็นขาด; `/health` บอกสถานะครบ
* **Tests:** unit env‑validation, integration health

### `stories/14B-local-stack-compose.md`

* **Plan:** เพิ่ม services (pg/minio/nats/engine/orchestrator/ollama)
* **DoD:** `make dev` เปิดสแต็ก; bucket `heliox` สร้างอัตโนมัติ
* **Tests:** smoke curl `/health`, publish NATS → SSE รับได้

### `stories/14C-llm-provider-switch.md`

* **Plan:** factory LLM; สลับ provider ผ่าน ENV; preflight แจ้งเตือน
* **DoD:** ollama/openai/anthropic ใช้งานได้ทั้งสามแบบใน local
* **Tests:** mock call 3 provider แล้วผ่าน schema เดียวกัน

### `stories/14D-object-layout-contract.md`

* **Plan:** เสริม path helper สำหรับ OBJECT\_BASE; checksum metadata
* **DoD:** อัปโหลด/ดาวน์โหลดไฟล์รายงาน ตรงตำแหน่งตามสัญญา
* **Tests:** e2e write/read, verify checksum

**Simple takeaway:** แตกเป็น 4 โจทย์เล็ก—เดิน PR ลื่น ไม่ชนกัน

---

# 14.14 คู่มือสั้น ๆ (Runbook)

1. `cp .env.example .env` แล้วแก้ `CORS_ALLOWED_ORIGINS`, `JWT_SECRET`
2. `make dev` → เปิดสแต็กทั้งหมด
3. สร้าง bucket: `mc mb -p local/heliox` (ถ้าไม่ทำ auto)
4. เปิด FE: `http://localhost:5173` → ลอง `New Strategy` → timeline ไหล
5. ถ้า SSE ไม่มา: เช็ค `BUS_URL`, ดู container `bus` log, ตรวจ `SSE_HEARTBEAT_SEC`

**Simple takeaway:** 5 ขั้นตอน—เห็นทุกอย่างวิ่งในเครื่องคุณ

---

# 14.15 Troubleshooting แมพกับ ENV

* **CORS 403:** ตรวจ `CORS_ALLOWED_ORIGINS` มี `http://localhost:5173` หรือไม่
* **SSE หลุดบ่อย:** ลด `SSE_HEARTBEAT_SEC` → 5, เช็ค proxy buffer ถ้ามี
* **อัปโหลด MinIO fail:** ตรวจ `OBJECT_BASE`/`MINIO_*`, สร้าง bucket แล้วหรือยัง
* **LLM 401:** ลืมตั้ง `OPENAI_API_KEY`/`ANTHROPIC_API_KEY`, หรือ provider ผิด
* **NATS connect error:** `BUS_URL` พิมพ์ผิด, port 4222 ถูกจอง

**Simple takeaway:** อาการยอดฮิตแก้ได้ที่ ENV ก่อน—เร็วสุด

---

## สรุปส่งมอบ

* **สเปก ENV** ครบ (ตาราง + ความหมาย + ค่า default)
* **Docker Compose** พร้อมบริการ local ทั้งชุด
* **โค้ดสเกลตัน** โหลดคอนฟิก + MinIO + NATS + Zod validation
* **BMAD stories** สำหรับ ENV/stack/LLM/object storage
* **Runbook & Troubleshooting** ใช้งานจริงได้ทันที

**Simple takeaway:** ข้อ 14 ปูทางทั้งหมดให้ “รันในเครื่องก่อน” อย่างปลอดภัย, ตรวจสอบได้, และกดสวิตช์ขึ้นคลาวด์ได้โดยไม่เปลี่ยนสัญญา.





มัดแน่นทุกจุดรั่ว—**ข้อ 15: จุดเสี่ยง & การ์ด (Production Guardrails, พร้อมไฟล์/สัญญา/โค้ด/เทสต์/อัลาร์ม)**
เป้าหมาย: ให้ Claude Code ลงมือทำ “การ์ด” เป็นโค้ดจริงได้ทันที โดยยึดสัญญาเดียวกับ Phase 1–2

---

## 15.1 Event out‑of‑order (ไทม์ไลน์เพี้ยน, ซ้ำ, ขาด)

**ความเสี่ยง**: อีเวนต์มาจากหลายโหนด/บัส → ลำดับมั่ว, FE แสดงผิด, state ผิดรุ่น
**การ์ด**

* **Sequence stamp เดียวจาก Orchestrator**: ทุก event มี `seq:uint64` (monotonic per `trace_id`) และ `phase_seq` (ย่อยต่อเฟส)
* **Gateway reordering buffer**: บัฟเฟอร์ 1–3 s (config `SSE_REORDER_WINDOW_MS`) → sort ตาม `seq` → ส่งออก
* **Dedup**: เก็บ `last_seq` ต่อ `trace_id`; ทิ้ง frame ที่ `seq ≤ last_seq`
* **At‑least‑once + idempotent**: FE ใช้ `Last-Event-Id` + `?from_seq=` เพื่อ resume
* **Clock‑free**: ใช้ `seq` ไม่ใช้เวลาจากระบบเพื่อจัดลำดับ

**ตัวอย่าง (TS/Orchestrator):**

```ts
let seq = 0;
function publish(evt) {
  seq += 1;
  bus.publish(`runs.${traceId}.events`, JSON.stringify({ ...evt, seq }));
}
```

**ตัวอย่าง (Go/Gateway SSE):**

```go
type evt struct{ Seq uint64; Payload json.RawMessage }
buf := heapMinBySeq{}
deadline := time.Now().Add(reorderWindow)
for {
  e := <-in
  heap.Push(&buf, e)
  for buf.Len()>0 {
    top := heap.Peek(&buf).(*evt)
    if top.Seq == lastSeq+1 || time.Now().After(deadline) {
      heap.Pop(&buf); lastSeq = top.Seq; sseWrite(top)
    } else { break }
  }
}
```

**BMAD story**: `stories/15A-event-ordering.md` (Plan: seq stamp + buffer + dedup; DoD: ส่ง 10k events สลับลำดับ P95 lag < 250 ms, ไม่มีย้อนลำดับ/สูญหาย)

**Simple takeaway:** ทุก event มี `seq` เดียว—GW เรียงก่อนส่ง, FE resume ได้, ไม่พึ่งนาฬิกา

---

## 15.2 S3/วัตถุแบบ eventual (ไฟล์ไม่พร้อม/ขาดชิ้น)

**ความเสี่ยง**: อัปโหลดสำเร็จแต่ FE/ขั้นต่อไปอ่านไม่เจอ/อ่านชิ้นไม่ครบ
**การ์ด**

* **Two‑phase publish**: เขียนไฟล์ → ตรวจ `HEAD` รับ `ETag/Size` → เขียน `manifest.json` (รวม checksums) → ค่อยปล่อย event `artifact_ready:true`
* **Atomicity โดเมน**: ใช้พาธ staging `.../tmp/<uuid>/` → ย้ายเป็น `.../runs/<run_id>/` เมื่อครบ
* **Contract**: ทุก `artifact/*` event ต้องพก `manifest_uri` และ `etag`

**ตัวอย่าง (Go สั้น ๆ)**

```go
put(obj); head := stat(obj)
manifest := Manifest{Path: obj, ETag: head.ETag, Size: head.Size, Sha256: sha256(obj)}
put(manifestPath, manifest)
publish("artifact/ready", { manifest_uri: manifestPath })
```

**BMAD story**: `stories/15B-artifact-two-phase.md` (DoD: อ่านกลับจาก `manifest` ได้ครบ 100%, checksum ตรง)

**Simple takeaway:** “พร้อมจริงค่อยบอก”—ใช้ manifest + two‑phase publish ปิดรู eventual

---

## 15.3 Allocator เปลืองคอมพิวต์ (งบล้น, ลูปไม่รู้จบ)

**ความเสี่ยง**: T0/T1/T2 ซิมหนักเกิน, LLM เรียกถี่, ค่าใช้จ่ายเกิน cap
**การ์ด**

* **Budget preflight**: ประเมินค่าใช้จ่ายล่วงหน้า (LLM tokens + sim time) → ถ้าเกิน `BUDGET_MAX_RUN_USD` ให้ hard‑stop หรือสลับ provider/ลด batch
* **Early‑stop**: ระหว่าง T0/T1 ถ้า KPIs ต่ำกว่า dynamic floor (เช่น Sharpe < 0.2 หรือ CVaR95 > 10%) → หยุดแบตช์ต่อไป
* **Content‑hash cache**: คีย์ `hash(blueprint|scenario_set|seed_block|engine_ver|cfg)` ป้องกันงานซ้ำ
* **Bandit allocator (optional)**: กระจายงบให้ candidates ที่ promising (epsilon‑greedy/UCB) ใน T1/T2

**ตัวอย่าง Preflight (TS):**

```ts
const est = estimateCost({ llmTokens, simSec, provider });
if (est.runUSD > budget.maxRun || est.dailyUSD > budget.maxDaily) {
  return { status:'error', code:'BUDGET_EXCEEDED', suggestion:'reduce batch or switch provider' }
}
```

**BMAD story**: `stories/15C-budget-guard.md` (DoD: run ใกล้เกินงบ → หยุด/ลดอัตโนมัติ, cache hit-rate ≥ 50% บนซ้ำเดิม)

**Simple takeaway:** ตั้งงบก่อนวิ่ง, หยุดเร็วถ้าไม่เวิร์ก, งานซ้ำไม่ทำสองรอบ

---

## 15.4 Lookahead หลุด (กลยุทธ์โกงอนาคต/เลี่ยงข้อจำกัด)

**ความเสี่ยง**: บลูปรินต์/โค้ดใช้ข้อมูลอนาคตโดยไม่ตั้งใจ → ผลลวง
**การ์ด**

* **AST invariants**: DSL/AST ต้องผ่านกฎ `no_future_read`, `cooldown≥1`, `max_concurrent≤N`
* **Taint analysis**: ฟังก์ชันที่ “อันตราย” (เช่น `peekFuture`, `nextBar`) ถูกบล็อกโดยตัวคอมไพเลอร์ DSL
* **Property‑based tests**: สุ่ม blueprint → สร้างสัญญาณบนสตรีมที่มี “spike อนาคต” → assert ว่าผลไม่เปลี่ยนเมื่อย้าย spike ไปอนาคต
* **Formal check**: SMT (ถ้ามี) เขียนพร็อพ `∀t: signal(t) independent of price(t+Δ)`

**ตัวอย่าง Property Test (TS):**

```ts
it('no future dependency', () => {
  const s1 = runSignal(bp, seriesWithFutureSpike(1000, +10% at t=500))
  const s2 = runSignal(bp, seriesWithFutureSpike(1000, +10% at t=700))
  expect(s1.before(500)).toEqual(s2.before(500))  // ไม่มีผลก่อน spike
})
```

**BMAD story**: `stories/15D-anti-lookahead.md` (DoD: 100 blueprints สุ่มผ่าน property test ≥ 99%)

**Simple takeaway:** ห้ามอ่านอนาคตทั้งเชิงสแตติกและไดนามิก—พิสูจน์ด้วยเทสต์

---

## 15.5 WS/SSE หลุดตอน Deploy (fills สูญหาย/สถานะเพี้ยน)

**ความเสี่ยง**: ขาดเน็ต/รีโหลดหน้า → ไม่เห็นคำสั่ง/สถานะจริง
**การ์ด**

* **Reconnect with offset**: FE เก็บ `last_seq` และ `session_id`; reconnect ใช้ `?from_seq=`
* **Snapshot API**: `GET /v1/deploy/:session/snapshot` → คืนสถานะล่าสุด (positions, orders, last\_seq) แล้วตามด้วยไลฟ์
* **Idempotent ops**: `Place/Cancel` มี `client_order_id`; retry ไม่ทำซ้ำ
* **Backoff & venue health**: exponential backoff + circuit breaker เมื่อโบรคเกอร์ล่ม
* **Periodic reconcile**: ทุก 60 s เทียบตำแหน่ง/เงินสดกับโบรคเกอร์ → mismatch แจ้งเตือน

**FE (TS) reconnect สั้น ๆ:**

```ts
const es = new EventSource(`/v1/runs/${trace}/events?from_seq=${lastSeq}`);
es.onmessage = (e)=> { const ev = JSON.parse(e.data); lastSeq = ev.seq; apply(ev) }
es.onerror = ()=> setTimeout(reconnect, backoff.next());
```

**BMAD story**: `stories/15E-deploy-resilience.md` (DoD: ปิดแท็บ/เปิดใหม่ → fills ครบจาก snapshot+replay; idempotency pass)

**Simple takeaway:** หลุดก็ไม่หาย—มีสแน็ปช็อต+รีเพลย์+ไอดีคำสั่งกันซ้ำ

---

## 15.6 ความเสี่ยงข้ามชั้น (เสริม)

* **Clock skew**: ใช้ `seq` แทนเวลาในการสั่งเรียง; มอนิเตอร์ skew ของคอนเทนเนอร์
* **Seed non‑determinism**: บังคับ CRN+antithetic; ใส่ `engine_ver` ลง cache key
* **Payload ใหญ่**: `REQUEST_SIZE_MAX` + chunk upload สำหรับไฟล์ >5 MB
* **Rate‑limit โบรคเกอร์**: client‑side token bucket + backoff jitter + pacing
* **RLS bypass**: เปิด RLS ทุกตาราง + ให้ service role เฉพาะ backend
* **Schema drift**: ตรึง `contracts` เวอร์ชัน; PR ที่แก้ schema ต้องมี `migrations`/compat tests
* **Memory leak**: session idle timeout; cap concurrent runs; Prometheus alerts บน RSS/FD

**Simple takeaway:** ใส่รั้วตั้งแต่ DB → API → FE—บังคับพฤติกรรมถูกตั้งแต่ต้นน้ำ

---

## 15.7 Metrics & Alerts (ผูกกับข้อเสี่ยงทีละตัว)

* **Event ordering**: `event_out_of_order_total`, `sse_p95_lag_ms` (WARN > 350 ms, CRIT > 600 ms)
* **Artifacts**: `artifact_manifest_miss_total`, `artifact_read_retry_total`
* **Budget**: `run_cost_usd`, `budget_exceeded_total`, `cache_hit_ratio`
* **Lookahead**: `prop_test_fail_total`, `formal_violation_total`
* **Deploy link**: `ws_reconnect_total`, `snapshot_served_total`, `venue_unhealthy_seconds_total`
* อัลาร์ม: PagerDuty/WARN channel ตามเส้น

**Simple takeaway:** ทุกการ์ดมีตัวเลขวัด—ดังตอนป่วย เงียบตอนสุขภาพดี

---

## 15.8 ไฟล์/โค้ดที่จะเพิ่ม (ให้ Claude Code ทำ)

```
stories/
  15A-event-ordering.md
  15B-artifact-two-phase.md
  15C-budget-guard.md
  15D-anti-lookahead.md
  15E-deploy-resilience.md
apps/orchestrator/src/event_seq.ts
apps/backend/internal/http/sse_reorder.go
apps/backend/internal/artifacts/manifest.go
apps/backend/internal/budget/preflight.go
apps/backend/internal/deploy/snapshot.go
apps/engine/tests/no_lookahead.spec.ts
apps/frontend/src/lib/sse/reconnect.ts
ops/alerts/rules.yml
```

**Simple takeaway:** เส้นทางไฟล์ระบุชัด—ลงมือได้ทันทีเป็น PR ย่อย ๆ

---

## 15.9 Acceptance Matrix (ต้อง “เขียว” ถึงจะผ่านข้อ 15)

| การ์ด              | เกณฑ์ผ่าน                                                            |
| ------------------ | -------------------------------------------------------------------- |
| Event ordering     | 10k events สลับลำดับ → FE ไม่ย้อนลำดับ, P95 lag < 250 ms             |
| Artifact two‑phase | อ่านกลับจาก manifest ครบ 100%, checksum เท่ากัน                      |
| Budget guard       | Run เกินงบ → ถูกหยุดหรือปรับลดอัตโนมัติ, cache hit ≥ 50% (บนงานซ้ำ)  |
| Anti‑lookahead     | Property test 100 เคส ผ่าน ≥ 99%, formal violation = 0               |
| Deploy resilience  | ปิด/เปิดหน้าใหม่ → fills ครบ, ไม่มีคำสั่งซ้ำ, reconcile mismatch = 0 |

**Simple takeaway:** ตารางเดียวบอกชัด—การ์ดทำงานจริง วัดได้ ตรวจได้

---

### ปิดท้าย

ชุดการ์ดนี้ **ล็อกความเสถียร/ความคุ้ม/ความเร็ว** ตั้งแต่วันแรก: ลำดับอีเวนต์ถูก, ไฟล์พร้อมค่อยประกาศ, งบถูกคุม, ไม่มี “อ่านอนาคต”, และดีพลอยไม่ตกน้ำเมื่อเน็ตหลุด—ทั้งหมดแปลงเป็นไฟล์/โค้ด/สตอรี่ที่ Claude Code นำไปลงมือได้ทันที.





มาแบบ “เสียบเข้าระบบแล้วใช้ได้ทันที”—**ข้อโบนัส (ฉบับสมบูรณ์): Prompt Suite สำหรับเอเจนต์ *Strategy Architect***
รวมสัญญา (Schema), แม่แบบพรอมป์ 3 ระดับ (system/dev/user), รีแพร์‑ลูปอัตโนมัติ, โค้ดเรียก LLM (OpenAI/Anthropic/Local), วาลิเดชัน, ยูนิตเทสต์, และไฟล์/พาธที่ Claude Code ต้องแก้เท่านั้น

---

## B.1 สัญญา (Contracts): Blueprint Schema

### โครง JSON Schema (สำหรับการตรวจฝั่ง Gateway/Orchestrator/CI)

`packages/contracts/schemas/blueprint.schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "heliox://schemas/blueprint.json",
  "title": "StrategyBlueprint",
  "type": "object",
  "required": ["id","name","family","entry","exit","filters","sizing","risk","evidence","meta"],
  "properties": {
    "id": { "type": "string", "pattern": "^[a-z0-9-]{6,64}$" },
    "name": { "type": "string", "minLength": 3, "maxLength": 80 },
    "family": { "type": "string", "enum": ["SMC","ICT","Trend","MeanRevert","GridSafe","Custom"] },
    "entry": {
      "type": "object",
      "required": ["signals"],
      "properties": {
        "signals": {
          "type": "array",
          "minItems": 1,
          "items": {
            "type": "object",
            "required": ["type","params"],
            "properties": {
              "type": { "type": "string" },
              "params": { "type": "object", "additionalProperties": true }
            },
            "additionalProperties": false
          }
        }
      },
      "additionalProperties": false
    },
    "exit": {
      "type": "object",
      "required": ["take_profit","stop_loss","time_based"],
      "properties": {
        "take_profit": { "type": "object", "properties": { "rr": { "type": "number", "minimum": 0.1, "maximum": 10 }}, "required": ["rr"] },
        "stop_loss":   { "type": "object", "properties": { "atr_mult": { "type": "number", "minimum": 0.1, "maximum": 10 }}, "required": ["atr_mult"] },
        "time_based":  { "type": "object", "properties": { "bars": { "type": "integer", "minimum": 1, "maximum": 5000 }}, "required": ["bars"] }
      },
      "additionalProperties": false
    },
    "filters": {
      "type": "array",
      "items": { "type": "object", "required": ["name","params"], "properties": {
        "name": { "type": "string" },
        "params": { "type": "object", "additionalProperties": true }
      }, "additionalProperties": false }
    },
    "sizing": {
      "type": "object",
      "required": ["mode","params"],
      "properties": {
        "mode": { "type": "string", "enum": ["fixed","vol_target","grid_step"] },
        "params": { "type": "object", "additionalProperties": true }
      },
      "additionalProperties": false
    },
    "risk": {
      "type": "object",
      "required": ["max_concurrent","cooldown_bars","position_limit_x","leverage_max_x"],
      "properties": {
        "max_concurrent": { "type": "integer", "minimum": 1, "maximum": 10 },
        "cooldown_bars":  { "type": "integer", "minimum": 1, "maximum": 10000 },
        "position_limit_x": { "type": "number", "minimum": 0.1, "maximum": 5 },
        "leverage_max_x": { "type": "number", "minimum": 0.1, "maximum": 20 }
      },
      "additionalProperties": false
    },
    "evidence": {
      "type": "object",
      "required": ["rationale","failure_modes","envelope"],
      "properties": {
        "rationale": { "type": "string", "maxLength": 4000 },
        "failure_modes": { "type": "array", "items": { "type": "string" } },
        "envelope": { "type": "object", "properties": {
          "spread_bps": { "type": "integer", "minimum": 0, "maximum": 200 },
          "slip_bps":   { "type": "integer", "minimum": 0, "maximum": 200 },
          "regimes":    { "type": "array", "items": { "type": "string" } }
        }, "required": ["spread_bps","slip_bps","regimes"] }
      },
      "additionalProperties": false
    },
    "meta": {
      "type": "object",
      "required": ["risk_tier","created_by","version"],
      "properties": {
        "risk_tier": { "type": "string", "enum": ["cons","bal","agg"] },
        "created_by": { "type": "string" },
        "version": { "type": "string", "pattern": "^v\\d+\\.\\d+(\\.\\d+)?$" }
      },
      "additionalProperties": false
    }
  },
  "additionalProperties": false
}
```

**Simple takeaway:** สคีมาชัด—ทุกเอาต์พุตของ Architect ต้องผ่าน schema นี้ก่อนถึงจะไปขั้นถัดไป

---

## B.2 Zod Types (สำหรับ Orchestrator/FE)

`packages/contracts/src/blueprint.ts`

```ts
import { z } from "zod";
export const Blueprint = z.object({
  id: z.string().min(6).max(64).regex(/^[a-z0-9-]+$/),
  name: z.string().min(3).max(80),
  family: z.enum(["SMC","ICT","Trend","MeanRevert","GridSafe","Custom"]),
  entry: z.object({ signals: z.array(z.object({ type: z.string(), params: z.record(z.any()) })).min(1) }),
  exit: z.object({
    take_profit: z.object({ rr: z.number().min(0.1).max(10) }),
    stop_loss:   z.object({ atr_mult: z.number().min(0.1).max(10) }),
    time_based:  z.object({ bars: z.number().int().min(1).max(5000) })
  }),
  filters: z.array(z.object({ name: z.string(), params: z.record(z.any()) })),
  sizing: z.object({ mode: z.enum(["fixed","vol_target","grid_step"]), params: z.record(z.any()) }),
  risk: z.object({
    max_concurrent: z.number().int().min(1).max(10),
    cooldown_bars: z.number().int().min(1).max(10000),
    position_limit_x: z.number().min(0.1).max(5),
    leverage_max_x: z.number().min(0.1).max(20)
  }),
  evidence: z.object({
    rationale: z.string().max(4000),
    failure_modes: z.array(z.string()),
    envelope: z.object({
      spread_bps: z.number().int().min(0).max(200),
      slip_bps: z.number().int().min(0).max(200),
      regimes: z.array(z.string())
    })
  }),
  meta: z.object({
    risk_tier: z.enum(["cons","bal","agg"]),
    created_by: z.string(),
    version: z.string().regex(/^v\d+\.\d+(\.\d+)?$/)
  })
});
export type TBlueprint = z.infer<typeof Blueprint>;
```

**Simple takeaway:** Zod = ตัวจริงในรันไทม์; JSON Schema = ใช้ใน CI/gateway—สองอันสอดคล้องกัน

---

## B.3 Prompt Templates (3 ชั้น): System / Developer / User

`apps/orchestrator/src/agents/architect.prompts.ts`

```ts
export const SYSTEM = `
You are the Strategy Architect for Heliox ATLAS.
Design a trading strategy as a DSL/AST with these components:
- entry.signals[], exit.{take_profit,stop_loss,time_based}, filters[], sizing{mode,params}, risk{max_concurrent,cooldown_bars,position_limit_x,leverage_max_x}
Hard constraints:
- No lookahead or future data. All logic must depend only on t and past.
- cooldown_bars >= 1
- risk.max_concurrent <= N derived from risk_tier
- Output STRICT JSON only that matches the Blueprint schema. No extra commentary.
Safety:
- If input is insufficient, return: {"status":"needs_input","missing":["..."]} (and nothing else).
- If constraints collide, return: {"status":"error","message":"..."} (and nothing else).
`;

export const DEVELOPER = `
Contract:
- Respond ONLY with a single JSON object matching Blueprint or a "status" object as specified.
- Use snake_case keys exactly as in schema.
- "evidence": keep concise but precise (rationale, failure_modes, envelope).
- "meta.version" as semantic version like "v1.0".
Risk tiers mapping:
- cons: max_concurrent <= 1, leverage_max_x <= 2
- bal : max_concurrent <= 2, leverage_max_x <= 5
- agg : max_concurrent <= 4, leverage_max_x <= 10
Family hints:
- SMC/ICT prefer session filters; Trend uses slope filters; MeanRevert uses band/osc; GridSafe must cap position_limit_x <= 1.5
Return JSON only.
`;

export const USER = (payload: {
  prompt: string,
  risk_tier: "cons" | "bal" | "agg",
  scenario_context?: Record<string, any>
}) => `
{
  "prompt": ${JSON.stringify(payload.prompt)},
  "risk_tier": "${payload.risk_tier}",
  "scenario_context": ${JSON.stringify(payload.scenario_context || {})}
}
`;

export const REPAIR = (errMsg: string, lastJSON: string) => `
Your previous output failed validation: ${errMsg}
Return a corrected JSON matching the Blueprint schema. Only JSON. Here is your last attempt for reference:
${lastJSON}
`;
```

**Simple takeaway:** มี system/dev/user ครบ + เทมเพลต REPAIR สำหรับรี‑ลองเมื่อวาลิเดชันตก

---

## B.4 JSON‑Only Wrapper (รองรับ OpenAI/Anthropic/Local Ollama)

`apps/orchestrator/src/llm/jsonClient.ts`

```ts
import { Blueprint } from "@contracts/blueprint";
import { Env } from "../config";
import { z } from "zod";

type Provider = "openai"|"anthropic"|"ollama";
const provider = Env.LLM_PROVIDER as Provider;

export async function llmJSON(messages: {role:"system"|"user"|"assistant", content:string}[], schemaName: "Blueprint") {
  const maxRetries = 2;
  let last: any = null, lastText = "";

  for (let i=0; i<=maxRetries; i++) {
    const text = await callProvider(messages);
    lastText = text;

    // Strict JSON strip
    const trimmed = text.trim().replace(/^[\s\S]*?({)/, "$1").replace(/(})[\s\S]*$/, "$1");

    try {
      const obj = JSON.parse(trimmed);

      // status passthrough
      if (obj && (obj.status === "needs_input" || obj.status === "error")) return obj;

      // schema validate
      const parsed = Blueprint.parse(obj);
      return parsed;
    } catch (e: any) {
      messages = [
        messages[0],
        ...messages.slice(1),
        { role: "user", content: `Validator error: ${e.message}. Return corrected JSON only.` }
      ];
      // Add explicit repair instruction only once
      if (i === maxRetries) {
        return { status: "error", message: `LLM JSON parse/validate failed: ${e.message}`, last_text: lastText.slice(0, 1000) };
      }
    }
  }
}

async function callProvider(messages: {role:"system"|"user"|"assistant", content:string}[]) {
  if (provider === "openai") {
    // Pseudocode; implement with official SDK
    const res = await openai.chat.completions.create({
      model: process.env.OPENAI_MODEL || "gpt-4.1-mini",
      messages,
      temperature: 0.2,
      response_format: { type: "json_object" }
    });
    return res.choices[0].message.content || "{}";
  }
  if (provider === "anthropic") {
    const res = await anthropic.messages.create({
      model: process.env.ANTHROPIC_MODEL || "claude-3-5-sonnet",
      max_tokens: 2000,
      temperature: 0.2,
      messages,
      // Use JSON mode if available in your SDK; otherwise rely on strict instructions
    } as any);
    return (res as any).content?.[0]?.text || "{}";
  }
  // ollama local
  const r = await fetch(`${process.env.OLLAMA_ENDPOINT || "http://localhost:11434"}/api/generate`, {
    method: "POST",
    body: JSON.stringify({ model: process.env.OLLAMA_MODEL || "qwen2.5", prompt: messages.map(m=>m.content).join("\n") })
  });
  const txt = await r.text();
  return txt;
}
```

**Simple takeaway:** ฟังก์ชันกลางเดียว—สลับผู้ให้บริการด้วย ENV; คืนเฉพาะ JSON หรือสถานะ error/needs\_input

---

## B.5 Agent Function (Architect) + Idempotency + Events

`apps/orchestrator/src/agents/architect.ts`

```ts
import { Blueprint, TBlueprint } from "@contracts/blueprint";
import { SYSTEM, DEVELOPER, USER, REPAIR } from "./architect.prompts";
import { llmJSON } from "../llm/jsonClient";
import { publishEvent } from "../bus/nats";
import { upsertBlueprint } from "../stores/blueprints";
import { nanoid } from "nanoid";

export async function runArchitect(ctx: { trace_id: string, run_id: string, requirement: any, created_by: string }) {
  const id = `bp-${nanoid(8)}`;

  const messages = [
    { role: "system", content: SYSTEM },
    { role: "assistant", content: DEVELOPER },
    { role: "user", content: USER({ prompt: ctx.requirement.prompt, risk_tier: ctx.requirement.risk_tier, scenario_context: ctx.requirement.scenario_context }) }
  ] as const;

  const t0 = Date.now();
  const out = await llmJSON(messages as any, "Blueprint");

  if ((out as any).status) {
    await publishEvent(ctx.trace_id, { type: "architect/status", seq: 0, payload: out });
    return out;
  }

  const bp = out as TBlueprint;
  const final: TBlueprint = {
    ...bp,
    id,
    meta: { ...bp.meta, created_by: ctx.created_by, version: "v1.0" }
  };

  await upsertBlueprint(ctx.run_id, final);
  await publishEvent(ctx.trace_id, {
    type: "artifact/blueprint",
    seq: 1,
    payload: { id: final.id, name: final.name, family: final.family, time_ms: Date.now() - t0 }
  });

  return final;
}
```

**Simple takeaway:** ฟังก์ชันเดียวจบ: สร้างข้อความ → เรียก LLM JSON → ตรวจสคีมา → บันทึก DB → ส่งอีเวนต์

---

## B.6 Unit Tests (Happy/Repair/Fail)

`apps/orchestrator/test/architect.spec.ts`

```ts
import { runArchitect } from "../src/agents/architect";
import * as jsonClient from "../src/llm/jsonClient";

test("happy path returns valid Blueprint", async () => {
  jest.spyOn(jsonClient, "llmJSON").mockResolvedValue({
    id: "bp-demo",
    name: "XAU-MicroPulse v1",
    family: "Trend",
    entry: { signals: [{ type: "breakout", params: { period: 20 } }] },
    exit: { take_profit:{ rr: 1.5 }, stop_loss:{ atr_mult: 1.2 }, time_based:{ bars: 600 } },
    filters: [{ name:"session", params:{ allow:["LDN","NY"] } }],
    sizing: { mode:"vol_target", params:{ annual_vol: 0.2 } },
    risk: { max_concurrent: 2, cooldown_bars: 10, position_limit_x: 1.0, leverage_max_x: 5 },
    evidence: { rationale:"vol regime scalping", failure_modes:["low-liquidity"], envelope:{ spread_bps:12, slip_bps:8, regimes:["range","trend"] } },
    meta: { risk_tier:"bal", created_by:"test", version:"v1.0" }
  });
  const out = await runArchitect({ trace_id:"t", run_id:"r", created_by:"u", requirement:{ prompt:"xauusd scalping", risk_tier:"bal" }});
  expect((out as any).family).toBeDefined();
});

test("repair path returns status error if invalid twice", async () => {
  jest.spyOn(jsonClient, "llmJSON").mockResolvedValue({ status:"error", message:"validation failed" } as any);
  const out = await runArchitect({ trace_id:"t", run_id:"r", created_by:"u", requirement:{ prompt:"x", risk_tier:"bal" }});
  expect((out as any).status).toBe("error");
});
```

**Simple takeaway:** ยูนิตเทสต์ 2 เส้น—ผ่านกรณีสุขภาพดี และรีพอร์ตกึ่งล้มเหลวอย่างถูกต้อง

---

## B.7 Cost‑Preflight (ก่อนเรียก LLM)

`apps/orchestrator/src/cost/preflight.ts`

```ts
export function estimateArchitectCost({ provider, tokens }: {provider:string, tokens:number}) {
  const usdPer1k = provider === "openai" ? 0.005 : provider === "anthropic" ? 0.006 : 0.0;
  return (tokens/1000) * usdPer1k;
}
```

รวมใน orchestrator ก่อน `llmJSON`:

* ถ้า > `BUDGET_MAX_RUN_USD` → ส่งสถานะ `error` พร้อมคำแนะนำลดคอนเท็กซ์

**Simple takeaway:** กันงบล้นตั้งแต่ก่อนคุย LLM—ไม่เผาเครดิตโดยไม่จำเป็น

---

## B.8 Developer Notes (Prompt Hygiene)

* **JSON‑only**: ย้ำใน System/Developer + ใช้ `response_format` เมื่อรองรับ
* **No tool‑use ในขั้นนี้**: Architect ห้ามแตะ path → ลด bias
* **Self‑check list**: ย้ำข้อห้ามและ risk‑tier mapping ใน DEV prompt
* **Repair with diff**: ส่งข้อความ error/field ที่ผิดกลับเข้า REPAIR เท่านั้น
* **Determinism**: temperature 0.2, top\_p 0.9, seed หากผู้ให้บริการรองรับ

**Simple takeaway:** วิศวกรรมพรอมป์แบบมีรั้ว ป้องกันหลุด JSON/ละเมิดอินวาเรี่ยนต์

---

## B.9 Files & Paths ที่ให้ Claude Code สร้าง/แก้

```
packages/contracts/schemas/blueprint.schema.json
packages/contracts/src/blueprint.ts
apps/orchestrator/src/agents/architect.prompts.ts
apps/orchestrator/src/agents/architect.ts
apps/orchestrator/src/llm/jsonClient.ts
apps/orchestrator/src/cost/preflight.ts
apps/orchestrator/test/architect.spec.ts
```

**Simple takeaway:** จำกัดขอบเขตไฟล์—ลดโอกาส “แก้ทั้งโปรเจกต์แล้วพัง”

---

## B.10 BMAD Story (สำหรับ PR นี้)

`stories/bonus-architect-prompt-suite.md`

```md
# Story: Architect Prompt Suite (JSON-only, contracts-first)

## Background
เราต้องการเอเจนต์ Architect ที่ให้ผลลัพธ์เป็น JSON ตรงตาม Blueprint schema เสมอ พร้อมรีแพร์อัตโนมัติและ cost-preflight

## Input Contract
- packages/contracts/schemas/blueprint.schema.json
- Zod type: packages/contracts/src/blueprint.ts

## Implementation Plan
- เพิ่ม architect.prompts.ts (SYSTEM/DEVELOPER/USER/REPAIR)
- เพิ่ม llmJSON wrapper รองรับ openai/anthropic/ollama
- เพิ่ม runArchitect() → persist + publish event
- เพิ่ม unit tests (happy/repair)
- ผูก cost preflight

## Acceptance (DoD)
- JSON‑only: invalid → repair ≤ 2 ครั้ง จากนั้นสถานะ error
- วาลิเดชันผ่าน Blueprint schema 100% ใน happy path
- ยูนิตเทสต์ผ่าน, contracts lint ผ่าน
- เปิดแค่ไฟล์ตามรายการ (paths allowed)
```

**Simple takeaway:** PR ชิ้นเดียว—ครบตั้งแต่สัญญา → พรอมป์ → โค้ด → เทสต์ → เกณฑ์ผ่าน

---

## B.11 ตัวอย่างการเรียก (End‑to‑end)

```ts
const result = await runArchitect({
  trace_id: "trc_123",
  run_id: "run_abc",
  created_by: "uid_demo",
  requirement: { prompt: "xauusd scalping เน้น volatility regime", risk_tier: "bal", scenario_context: { session:["LDN","NY"], spread_bps: 12 } }
});
if ((result as any).status === "error") {/* surface to UI */}
```

**Simple takeaway:** โค้ดฝั่ง orchestrator เรียก 1 ฟังก์ชัน—ได้ Blueprint ที่ตรวจแล้วหรือสถานะ error

---

## B.12 Prompt (ฉบับพร้อมคัดลอกไปใช้—อัปเกรดจากเวอร์ชันย่อ)

**System**

```md
You are the Strategy Architect for Heliox ATLAS.
Task: Output a trading strategy as a strict JSON object matching the Blueprint schema (provided separately), including:
- entry.signals[], exit.{take_profit,stop_loss,time_based}, filters[], sizing{mode,params}, risk{max_concurrent,cooldown_bars,position_limit_x,leverage_max_x}, evidence{rationale,failure_modes,envelope}, meta{risk_tier,created_by,version}.
Constraints:
- No lookahead (no access to future bars). All logic must depend only on current/past bars.
- cooldown_bars >= 1
- risk.max_concurrent must respect risk_tier.
If info is insufficient: return {"status":"needs_input","missing":[...]} only.
If constraints collide: return {"status":"error","message":"..."} only.
Return JSON only. No commentary.
Temperature=0.2, be concise and consistent.
```

**Developer**

```md
Contract reminders:
- Keys in snake_case; values within schema ranges.
- Family guidance: SMC/ICT uses session/liq filters; Trend uses slope/MA; MeanRevert uses bands; GridSafe caps position_limit_x <= 1.5.
- Evidence: list 1–3 failure_modes; envelope must include spread_bps, slip_bps, regimes[].
- meta.version "v1.0" (or higher if updated).
Return a single JSON object only.
```

**User (ตัวอย่าง)**

```json
{
  "prompt": "xauusd แบบ scalping เน้น volatility regime",
  "risk_tier": "bal",
  "scenario_context": { "session": ["LDN","NY"], "spread_bps": 12 }
}
```

**Repair**

```md
Your last JSON failed validation: <validator message>.
Return a corrected JSON matching the Blueprint schema. Output JSON only.
```

**Simple takeaway:** คัดลอกได้ตรง ๆ—ครอบสถานการณ์ error/needs\_input พร้อมลูปแก้ตัวเอง

---

## ปิดท้าย

* สคีมาชัด → พรอมป์สะอาด (JSON‑only) → วาลิเดชัน/รีแพร์ → บันทึก/อีเวนต์ → เทสต์ผ่าน
* Claude Code จะโฟกัส “แค่โค้ดตามไฟล์/พาธนี้” โดยไม่ไปแตะส่วนอื่น ทำให้ปลอดภัยและตรวจรับได้เร็ว

**Simple takeaway:** Bonus นี้คือ “แม่แบบพร้อมใช้งาน” ของ Architect—เสียบเข้าระบบ v21 แล้ววิ่งได้เลย, ลดหลุด JSON, คุมงบ, เทสต์ครบ.





มาจบชุดสเปกด้วย “คู่มือเดินงานให้ตรงใจ 100%” ที่ **Claude Code ทำงานแทนได้ทันที**—ตั้งแต่การแตกงาน, PR เดียวต่อ phaselet, การ์ด CI, การรีวิว, การแท็กรีลีส, จนถึงโรลแบ็กอัตโนมัติ

---

# 0) เป้าหมาย

* เปลี่ยน “ความต้องการ” → “สัญญาที่เครื่องตรวจได้” (contracts/tests) → “PR สำเร็จรูป”
* จำกัดขอบเขตการแก้ไขของเอเจนต์, ป้องกันแกะทั้งโปรเจ็กต์
* ทุก PR ต้องมี **DoD วัดได้**; ไม่ผ่านก็ **ตีตกอัตโนมัติ**

**Simple takeaway:** ทำให้ “สิ่งที่อยากได้” กลายเป็น “กฎที่ CI ตรวจได้”—แล้วให้บอททำงานแทนคน

---

# 1) โครงเวิร์กโฟลว์ (Phaselet → PR → Merge)

1. เขียน **Story (BMAD)** ต่อ 1 งาน (phaselet) พร้อม:

   * Scope, Input Contract, Implementation Plan (ไฟล์/พาธที่จะถูกแก้), DoD (ตัวชี้วัด), Tests, Rollback
2. เปิด **branch**: `feat/p1-orchestrator-skeleton`
3. เปิด **PR** พร้อมแนบ story และ **Allowed-Paths**
4. ให้ **Claude Code** ทำงานเฉพาะไฟล์ที่กำหนด
5. CI รัน: contracts tests, unit/integration, SSE conformance, security scans
6. ผ่านทั้งหมด → reviewer กด Approve → Merge → **tag `v21.0.p1`**
7. เริ่ม phaselet ถัดไป

**Simple takeaway:** งานเล็ก-วัดได้-ตรวจได้—วนรอบเร็วและปลอดภัย

---

# 2) ข้อกำหนดใน PR (Template + CODEOWNERS)

**.github/PULL\_REQUEST\_TEMPLATE.md**

```md
# Story
- [ ] Linked: stories/<ID>.md

## Allowed-Paths
```

apps/orchestrator/src/agents/\*\*
apps/orchestrator/src/llm/\*\*
packages/contracts/\*\*
stories/<ID>.md

```

## DoD Checklist
- [ ] Contracts pass (zod/jsonschema/OpenAPI)
- [ ] Unit tests pass
- [ ] SSE conformance (ordering/dedup/lag)
- [ ] Security checks (gitleaks/gosec/osv)
- [ ] Artifacts uploaded (flatten.xml, sbom)

## Notes
- Scope creep = close PR, open new story
```

**CODEOWNERS**

```
/packages/contracts/ @you @lead
/apps/orchestrator/ @you @lead
/apps/backend/ @you @lead
/apps/frontend/ @you
/stories/ @you
```

**Simple takeaway:** ทุก PR บอก “ไฟล์ที่ยอมให้แตะ + เกณฑ์ผ่าน” ชัดเจน และต้องมีเจ้าของรีวิว

---

# 3) สคริปต์บังคับ “แก้ได้เฉพาะไฟล์ที่อนุญาต”

**.github/scripts/check-allowed-paths.js**

````js
const fs = require('fs');
const { execSync } = require('child_process');

const storyPath = (process.env.STORY || '').trim();
if (!storyPath) { console.error('STORY not set'); process.exit(1); }

const story = fs.readFileSync(storyPath, 'utf8');
const m = story.match(/Allowed-Paths:\s*```([\s\S]*?)```/m);
if (!m) { console.error('Allowed-Paths block not found in story'); process.exit(1); }

const allow = m[1].split('\n').map(s => s.trim()).filter(Boolean);
const changed = execSync('git diff --name-only origin/main...HEAD').toString().trim().split('\n');

function match(pat, file) {
  const rx = new RegExp('^' + pat.replace(/\*\*/g, '.*').replace(/\*/g, '[^/]*') + '$');
  return rx.test(file);
}

const bad = changed.filter(f => !allow.some(p => match(p, f)));
if (bad.length) {
  console.error('Disallowed changes:\n' + bad.join('\n'));
  process.exit(2);
}
console.log('Allowed-paths check OK.');
````

**ใช้ใน PR**: ระบุ env `STORY=stories/12B-orchestrator-skeleton.md` ใน workflow (ด้านล่าง)

**Simple takeaway:** PR ไหนแก้ไฟล์นอกแผน—CI ตีตกทันที

---

# 4) GitHub Actions (CI หลัก)

**.github/workflows/ci.yml**

```yaml
name: ci
on: [pull_request]
jobs:
  paths-guard:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Determine Story file
        id: story
        run: |
          FILE=$(grep -o 'stories/[-_a-zA-Z0-9./]\+\.md' -m1 $GITHUB_EVENT_PATH || true)
          echo "file=${FILE}" >> $GITHUB_OUTPUT
      - name: Check allowed paths
        if: steps.story.outputs.file != ''
        run: node .github/scripts/check-allowed-paths.js
        env: { STORY: ${{ steps.story.outputs.file }} }

  contracts:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm ci --prefix packages/contracts && npm test --prefix packages/contracts

  backend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with: { go-version: '1.22' }
      - run: cd apps/backend && go vet ./... && go test ./...

  orchestrator:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20 }
      - run: npm ci --prefix apps/orchestrator && npm test --prefix apps/orchestrator

  sse-conformance:
    runs-on: ubuntu-latest
    services:
      nats: { image: nats:2, ports: ['4222:4222'], options: --name nats }
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20 }
      - run: npm ci --prefix apps/orchestrator
      - run: npm run test:sse --prefix apps/orchestrator

  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: zricethezav/gitleaks-action@v2
      - uses: actions/setup-go@v5
        with: { go-version: '1.22' }
      - run: cd apps/backend && go install github.com/securego/gosec/v2/cmd/gosec@latest && ~/go/bin/gosec ./...
      - uses: google/osv-scanner-action@v1
        with: { path: . }

  artifacts:
    runs-on: ubuntu-latest
    needs: [contracts, backend, orchestrator, sse-conformance, security]
    steps:
      - uses: actions/checkout@v4
      - run: make sbom || true
      - run: make flatten || true
      - uses: actions/upload-artifact@v4
        with:
          name: review-artifacts
          path: |
            scripts/flattened-codebase.xml
            **/coverage/**
```

**Simple takeaway:** PR ต้องผ่าน 5 ด่าน: paths, contracts, unit/integration, SSE conformance, security

---

# 5) SSE Conformance Suite (ตัวอย่างเทสต์)

**apps/orchestrator/test/sse.conformance.spec.ts**

```ts
import { reorderBuffer } from '../src/sse/reorder';
test('ordering & dedup', () => {
  const inEvents = [
    { seq: 3 }, { seq: 1 }, { seq: 2 }, { seq: 2 }, { seq: 4 }
  ];
  const out: number[] = [];
  const push = (e:any)=> out.push(e.seq);
  const buf = reorderBuffer({ windowMs: 250, onEmit: push, startSeq: 0 });
  inEvents.forEach(e => buf.feed(e));
  buf.flushAll();
  expect(out).toEqual([1,2,3,4]); // no dup, ordered
});
```

**Simple takeaway:** เรามีเทสต์ยืนยัน “เรียงและตัดซ้ำ” จริง—not just claims

---

# 6) ตีกรอบ Claude Code ใน PR

**.github/workflows/claude-code.yml** (เพิ่มข้อจำกัด)

```yaml
# เพิ่ม env CLAUDE_FILE_GUARD=1 ให้ action อ่าน Allowed-Paths จาก story แล้วเตือนใน PR ถ้าหลุด
```

และใน `CLAUDE.md` เพิ่ม:

* “ห้ามแก้ไฟล์นอก Allowed-Paths”
* “PR ต้องเพิ่ม/อัปเดต tests ตาม DoD”
* “ตอบเฉพาะไฟล์/โค้ดที่ขอ ไม่ refactor ข้ามขอบเขต”

**Simple takeaway:** บอกเอเจนต์ตรง ๆ ว่า “แตะอะไรได้/ไม่ได้”—ลดความเสี่ยงแตกทั้ง repo

---

# 7) แท็กรีลีสอัตโนมัติ + เช็กเวอร์ชัน

**.github/workflows/release-tag.yml**

```yaml
name: tag-phaselet
on:
  push:
    branches: [main]
jobs:
  tag:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - id: calc
        run: |
          LAST=$(git tag --list 'v21.0.p*' | sort -V | tail -n1)
          NUM=${LAST##*p}; NUM=$((NUM+1))
          echo "TAG=v21.0.p${NUM}" >> $GITHUB_OUTPUT
      - run: |
          git tag ${{ steps.calc.outputs.TAG }}
          git push origin ${{ steps.calc.outputs.TAG }}
```

**Simple takeaway:** Merge ปุ๊บ ติดแท็ก `v21.0.pX` อัตโนมัติ—ย้อนเวอร์ชันสะดวก

---

# 8) โรลแบ็ก (Revert) แบบปลอดภัย

* ใช้ GitHub “Revert PR” → เปิด PR ย้อนโค้ด
* CI รันครบอีกครั้ง; ถ้าผ่าน → merge กลับ
* ถ้าเป็น **รีลีส**: ใช้ `git revert -m 1 <merge_commit>` แล้วแท็ก `v21.0.pX-revert1`

**Simple takeaway:** พังเมื่อไร—กดย้อนแบบมีเทสต์การันตี

---

# 9) Pre‑commit Hooks (ลด error ก่อนดันขึ้น PR)

**.pre-commit-config.yaml** (ถ้าใช้ pre-commit)

* fmt/lint (Go/TS), jsonschema lint, commit‑msg conventional

**Simple takeaway:** ตรวจตั้งแต่หน้าบ้าน—ผิดน้อยลงเยอะ

---

# 10) Contracts Tests (Schema/OpenAPI)

* `packages/contracts`:

  * `npm test` ตรวจ Zod/JSON Schema สอดคล้องกัน
  * OpenAPI lint → เส้นทาง `/v1/runs`, `/v1/sse`, `/v1/deploy`
* เงื่อนไข: เปลี่ยนสคีมาต้อง **เพิ่ม migration** และ **compat tests**

**Simple takeaway:** สัญญาเปลี่ยน = ต้องประกาศและเทสต์ compatibility

---

# 11) Flatten & SBOM แนบใน PR

* `make flatten` → สร้าง `scripts/flattened-codebase.xml`
* `make sbom` → CycloneDX SBOM
* อัปโหลดทั้งคู่เป็น PR artifacts

**Simple takeaway:** ผม/คุณรีวิวได้ทั้งโค้ดและซัพพลายเชนในไฟล์เดียว

---

# 12) Definition of Done (รวมศูนย์)

PR จะ “ผ่าน” ก็ต่อเมื่อ:

* ✅ **Paths guard**: แก้เฉพาะไฟล์ที่ระบุใน story
* ✅ **Contracts**: Zod/JSON Schema/OpenAPI ผ่าน
* ✅ **Unit/Integration**: ผ่าน 100%
* ✅ **SSE conformance**: ordering/dedup/lag ผ่าน
* ✅ **Security**: gitleaks, gosec, osv ผ่าน
* ✅ **Artifacts**: flatten.xml + coverage + sbom
* ✅ **Review**: CODEOWNERS Approve ≥ 1

**Simple takeaway:** เกณฑ์ผ่านชัด—ไม่มี “ความเห็นส่วนตัว” มาตัดสิน

---

# 13) เช็คลิสต์ ผู้เขียน / ผู้รีวิว

**นักพัฒนา**

* ใส่ Allowed-Paths ให้ครอบคลุมพอ แต่ไม่กว้าง
* เขียน tests ก่อน/พร้อมโค้ด
* อัปเดต story DoD ถ้ามีอะไรเพิ่ม

**รีวิวเวอร์**

* ตรวจว่าคีย์ DoD ครบ
* เปิด artifacts → diff ดู `flattened-codebase.xml`
* ถ้า scope creep → ขอแยก PR

**Simple takeaway:** คนละบทบาท ชัดเจน—งานจบไว

---

# 14) ความเสี่ยงของเวิร์กโฟลว์ & การ์ด

* **เอเจนต์แก้เกินไฟล์** → paths guard
* **สคีมาเบี้ยว** → contracts tests เป็นด่านแรก
* **เหตุการณ์สลับลำดับ** → SSE conformance suite
* **ค่าใช้จ่ายพุ่ง** → budget guard ใน orchestrator (preflight)
* **รีวิวไม่เห็นภาพรวม** → flatten snapshot + sbom

**Simple takeaway:** จุดเสี่ยงถูกล็อกด้วยเทสต์/การ์ดที่วัดได้

---

# 15) ตัวอย่างการเดินงาน (Phaselet ตัวอย่าง)

**Phaselet-1: Orchestrator Skeleton**

1. เขียน story: `stories/12B-orchestrator-skeleton.md` (Allowed-Paths: `apps/orchestrator/src/**`, `stories/**`)
2. เปิด PR → Claude Code ลงมือสร้าง `graph.ts`, `sse/reorder.ts`, tests
3. CI ผ่านทุกด่าน → reviewer approve → merge
4. ติดแท็ก `v21.0.p1` อัตโนมัติ

**Simple takeaway:** เทมเพลตทำซ้ำได้—เปลี่ยนเฉพาะไฟล์และ DoD ก็เดินต่อได้เรื่อย ๆ

---

## ไฟล์ที่ต้องเพิ่มใน repo (สรุปรวม)

```
.github/PULL_REQUEST_TEMPLATE.md
.github/scripts/check-allowed-paths.js
.github/workflows/ci.yml
.github/workflows/release-tag.yml
CODEOWNERS
.pre-commit-config.yaml           (ตัวเลือก)
apps/orchestrator/test/sse.conformance.spec.ts
```

**Simple takeaway:** เพิ่มไฟล์ไม่กี่ชิ้น—แล้วทั้งกระบวนการ “ล็อกเข้าราง” อัตโนมัติ

---

## ปิดท้าย

นี่คือ “โครงรีเลย์” ที่ทำให้ **งานออกมาตรงใจ 100%**: แยกเล็ก, วัดได้, ปลอดภัย, ย้อนกลับง่าย, และมีกฎให้เครื่องตรวจแทนคน—**Claude Code แค่ลงมือ coding ตามสัญญา** เราคุมเกมด้วย story + tests + CI.

**Simple takeaway:** “คุมด้วยสัญญา, วัดด้วยเทสต์, จำกัดขอบเขตไฟล์”—ผลลัพธ์นิ่ง เป๊ะ และเร็ว.
